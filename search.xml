<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Tomcat9安装使用]]></title>
    <url>%2Fposts%2F6286.html</url>
    <content type="text"><![CDATA[安装 (Ubuntu) 传统的方法 Tomcat官网下载地址 解压到 /usr/local/bin , 重命名为 tomcat9 . cd进去. 1cd /usr/local/bin/tomcat9 网上有教程说要编辑 bin/catalina.sh, 结果我打开该文件一看: 1234...# Do not set the variables in this script. Instead put them into a script# setenv.sh in CATALINA_BASE/bin to keep your customizations separate.... 人家明确要求不要改本文件... 那么根据 bin/catalina.sh 下的说法, 要新建一个 setenv.sh : 1code bin/setenv.sh 添加如下变量 (可添加的变量在 bin/catalina.sh 开头的注释里都写明了, 以下三个是必须写的) : 123export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CATALINA_HOME=/usr/local/bin/tomcat9 然后往 /etc/profile 里添加个 Tomcat 的环境变量: 1export CATALINA_HOME=/usr/local/bin/tomcat9 然后 sudo ./bin/startup.sh : 123456Using CATALINA_BASE: /usr/local/bin/tomcat9Using CATALINA_HOME: /usr/local/bin/tomcat9Using CATALINA_TMPDIR: /usr/local/bin/tomcat9/tempUsing JRE_HOME: /usr/lib/jdk/jdk1.8.0_161/jreUsing CLASSPATH: /usr/local/bin/tomcat9/bin/bootstrap.jar:/usr/local/bin/tomcat9/bin/tomcat-juli.jarTomcat started. 打开 http://localhost:8080/ 就有了. 然后 sudo ./bin/shutdown.sh 一下就关了. Docker 大法 1sudo docker pull tomcat Tomcat 镜像就下载完了. 1sudo docker run -d -p 8080:8080 --name tomcat tomcat Tomcat 容器就跑起来了.]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python安装使用]]></title>
    <url>%2Fposts%2F52363.html</url>
    <content type="text"><![CDATA[Pip 指令 1pip list # 查看已安装的包 踩坑 Ubuntu 下安装 pip3 12sudo apt-get install python3-pip# `sudo apt-get install python-pip` 安装的是 pip2 安装完可用 pip3 指令, 如果想将 pip3 映射到 pip, 则 1sudo ln -s /usr/bin/pip3 /usr/bin/pip 然后就能用 pip 指令了. 刚安装完是 8.1.1 版本... 有够旧的. 目前都 19.1.1 了. 所以要更新: 1pip install --upgrade pip 结果更新完之后 pip 就坏了... 总是提示: 1234Traceback (most recent call last): File "/usr/bin/pip", line 9, in &lt;module&gt; from pip import mainImportError: cannot import name 'main' 解决方法: 打开 /usr/bin/pip, 将 1from pip import main 改为 1from pip._internal import main]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>日常配环境</tag>
        <tag>快乐背指令</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Python</tag>
        <tag>Pip</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Go安装使用]]></title>
    <url>%2Fposts%2F62476.html</url>
    <content type="text"><![CDATA[官网 | 官方文档 安装 (Ubuntu) 123456# cd 到压缩包目录sudo tar -C /usr/local/lib/go -xzf go1.12.7.linux-amd64.tar.gzcd /usr/local/lib/gosudo mv go go1.12.7.linux-amd64code ~/.profile# export PATH=$PATH:/usr/local/lib/go/go1.12.7.linux-amd64/bin]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>Go</tag>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js安装使用]]></title>
    <url>%2Fposts%2F4723.html</url>
    <content type="text"><![CDATA[官网下载地址 | 官网安装教程 安装 (Ubuntu) 12345678910111213141516# cd 到下载的压缩包目录sudo mkdir -p /usr/local/lib/nodejssudo tar -xJvf node-v10.16.0-linux-x64.tar.xz -C /usr/local/lib/nodejs# 编辑 ~/.profilecode ~/.profile# 添加: # export PATH=/usr/local/lib/nodejs/node-v10.16.0-linux-x64/bin:$PATH# 刷新. ~/.profile# 测试一下node -vnpm versionnpx -v]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常用指令]]></title>
    <url>%2Fposts%2F21894.html</url>
    <content type="text"><![CDATA[12tar -zxvf &lt;name&gt;.tar.gz # 解压tar -zcvf &lt;name&gt;.tar.gz &lt;dir&gt; # 压缩 dir 下文件 查看端口占用 12lsof -i:8080netstat -tunlp | grep 8000 杀进程 1kill -9 &lt;pid&gt; Chrome 开机第一次启动后总是需要输入密码 (登陆密钥环) 打开 seahorse, 左侧第一行有个 &quot;login&quot; (或 &quot;登陆&quot;), 右键更改密码, 改为空的.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>快乐背指令</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven安装使用]]></title>
    <url>%2Fposts%2F36502.html</url>
    <content type="text"><![CDATA[安装 (Ubuntu) 用 apt-get 会比较方便, 但安装出来版本可能不是最新的. 1sudo apt-get install maven 安装完的目录为, Maven home: /usr/share/maven; Config file: /etc/maven. settings.xml 位置: /etc/maven/settings.xml . 指令 mvn clean install 12345mvn clean install -DskipTests # 跳过单元测试# -pl: 仅构建选中的项目 (而不是目录下所有项目)# -am: 同时处理选定模块所依赖的模块mvn clean install -pl :&lt;assemblyname&gt; -am 查看当前生效的 settings. 1mvn help:effective-settings 第一次使用该指令时会先下一坨东西. 踩坑 下载慢 换阿里云的源. 1code /etc/maven/settings.xml 在 &lt;mirrors&gt; 标签中添加 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;mirror&gt; &lt;id&gt;aliyun-public&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun public&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-central&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun central&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/central&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-spring&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun spring&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-spring-plugin&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun spring-plugin&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/spring-plugin&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-apache-snapshots&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun apache-snapshots&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/apache-snapshots&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-google&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun google&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/google&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-gradle-plugin&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun gradle-plugin&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/gradle-plugin&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-jcenter&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun jcenter&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/jcenter&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-releases&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun releases&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/releases&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-snapshots&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun snapshots&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/snapshots&lt;/url&gt;&lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;aliyun-grails-core&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun grails-core&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/grails-core&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;aliyun-mapr-public&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;aliyun mapr-public&lt;/name&gt; &lt;url&gt;https://maven.aliyun.com/repository/mapr-public&lt;/url&gt;&lt;/mirror&gt; 啊~~ 速度起飞了. 但阿里云镜像有时候会抽风, 就突然长时间无响应, 给人一种爬虫被 ban 的感觉. 更新: 好消息特大好消息, 就在刚刚 (2019年07月09日), 腾讯云开源软件镜像站突然就上线了!!! 123456&lt;mirror&gt; &lt;id&gt;nexus-tencentyun&lt;/id&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;name&gt;Nexus tencentyun&lt;/name&gt; &lt;url&gt;http://mirrors.cloud.tencent.com/nexus/repository/maven-public/&lt;/url&gt;&lt;/mirror&gt; 不过还没试过. 应该还可以. Eclipse 配置 Maven 现在的 Eclipse 自带 Maven 插件. Window -&gt; Preference -&gt; Maven -&gt; Installation, 添加本地 Maven 主目录, 不要用 Eclipse 自带的. Window -&gt; Preference -&gt; Maven -&gt; User Settings, 修改配置文件地址. This compilation unit is not on the build path of a java project. 在给 java 源文件导入包时如图报错: 解决方法: 未解决.]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>快乐背指令</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Eclipse</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu美化(主题图标等)]]></title>
    <url>%2Fposts%2F38422.html</url>
    <content type="text"><![CDATA[Ubuntu 16.04 美化. Unity Tweak Tool 首先安装 Unity Tweak Tool, 换主题和图标必备. 1sudo apt-get install unity-tweak-tool numix 图标与主题 123sudo add-apt-repository ppa:numix/ppasudo apt-get updatesudo apt-get install numix-gtk-theme numix-icon-theme-circle 在 Unity Tweak Tool -&gt; Appearance -&gt; Cursors 中找到 numix 图标并更换. 在 Unity Tweak Tool -&gt; Appearance -&gt; Theme 中找到 numix 主图并更换. flatabulous 主题 123sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>美化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse Che安装使用]]></title>
    <url>%2Fposts%2F34765.html</url>
    <content type="text"><![CDATA[安装使用 (Ubuntu) 环境: Ubuntu 16.04 Eclipse Che GitHub | 官方文档 | 官方安装文档 文档指出运行一个默认的 Eclipse Che, 在 Docker 下仅需如下命令. 1docker run -it --rm -v /var/run/docker.sock:/var/run/docker.sock -v &lt;path&gt;:/data eclipse/che start 由于 Docker 进程使用 Unix Socket 而不是 TCP 端口, 需要 sudo. cd 到一个目录, 输入: 12345# 指定了版本 6.16.0, 最新版总是提示 not found.sudo docker run -it -v /var/run/docker.sock:/var/run/docker.sock -v ~/Eclipse-Che:/data eclipse/che:6.16.0 start# 目前用的版本sudo docker run -it -v /var/run/docker.sock:/var/run/docker.sock -v ~/Workspace/Eclipse-Che/Eclipse-Che-6.16.0:/data -v ~/.m2:/home/user/.m2 eclipse/che:6.16.0 start 倒数第二行输出 INFO: (che start): Use: http://192.168.221.133:8080 即为浏览器访问地址. 踩坑 Workspace 中不显示且无法新建项目 如图. 而正常情况应该为: 出现该问题的原因: 访问的地址是 localhost:8080 或 127.0.0.1:8080, 正确应该访问本机ip+端口8080. 问题主要发生在 Windows 下, win 下终端直接提示的用 localhost 访问, 而 Linux 环境下则提示用本机ip访问所以没这个问题: 12INFO: (che sstart): Use: http://192.168.221.133:8080INFO: (che start): API: http://192.168.221.133:8080/swagger 解决方法查询自 GitHub Issue 12475: qurben commented on 25 Feb @skabashnyuk It seems to be related with #12476, before that CORS on wsagent was a bit more liberal. When running the normal setup on Docker (the one described on the wiki and in this issue) and accessing Che via http://localhost:8080 the following happens: In CheWsAgentCorsAllowedOriginsProvider the value of apiExternal is equal to http://10.0.75.2:8080/api (or whatever ip the container has on the Docker NAT). This sets allowedOrigins to http://10.0.75.2:8080. This causes the wsagent server to not respond with any CORS headers when a request is sent from http://localhost:8080 or http://127.0.0.1:8080 because the host does not match. I am currently not well known enough with the code to propose a proper solution for this. 代码补全快捷键 (Ctrl + Space) 不起作用 症状是报错与警告正常显示, 但在编辑器按快捷键 Ctrl + Space 尝试弹出代码补全的小框框时没有反应. 解决方法: 把 Win10 输入法关了...... Maven install 报错: Found 1 non-complying files 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[ERROR] Found 1 non-complying files, failing build[ERROR] To fix formatting errors, run "mvn fmt:format"[ERROR] Non complying file: /home/xie/Workspace/Eclipse-Che/Eclipse-Che-6.16.0/instance/data/workspaces/workspaceo7zayfpxbzrdvmqf/che-test-extension/plugins/plugin-xxx/plugin-xxx-ide/src/main/java/zzz/yyy/ide/XXXExtension.java[INFO] ------------------------------------------------------------------------[INFO] Reactor Summary:[INFO] [INFO] Plugin XXX :: Parent pom ........................... SUCCESS [ 1.921 s][INFO] Plugin XXX :: Plugins :: Parent ................... SUCCESS [ 0.053 s][INFO] Plugin XXX :: Plugin :: Parent ..................... SUCCESS [ 0.816 s][INFO] Plugin XXX :: Plugin :: Server ..................... SUCCESS [ 3.759 s][INFO] Plugin XXX :: Plugin :: IDE ........................ FAILURE [ 2.800 s][INFO] Plugin xxx :: Che Assembly :: Assembly Parent ...... SKIPPED[INFO] Plugin XXX :: Che Assembly :: Workspace Agent Assembly SKIPPED[INFO] Plugin XXX :: Che Assembly :: Workspace Agent Tomcat Assembly SKIPPED[INFO] Plugin XXX :: Che Assembly :: IDE Assembly ......... SKIPPED[INFO] Plugin XXX :: Che Assembly :: Assemblies Tomcat .... SKIPPED[INFO] ------------------------------------------------------------------------[INFO] BUILD FAILURE[INFO] ------------------------------------------------------------------------[INFO] Total time: 11.225 s[INFO] Finished at: 2019-07-08T10:26:53+08:00[INFO] Final Memory: 59M/1319M[INFO] ------------------------------------------------------------------------[ERROR] Failed to execute goal com.coveo:fmt-maven-plugin:2.5.1:check (default) on project plugin-xxx-ide: Found 1 non-complying files, failing build -&gt; [Help 1]org.apache.maven.lifecycle.LifecycleExecutionException: Failed to execute goal com.coveo:fmt-maven-plugin:2.5.1:check (default) on project plugin-xxx-ide: Found 1 non-complying files, failing build at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:212) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:153) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:145) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:116) at org.apache.maven.lifecycle.internal.LifecycleModuleBuilder.buildProject(LifecycleModuleBuilder.java:80) at org.apache.maven.lifecycle.internal.builder.singlethreaded.SingleThreadedBuilder.build(SingleThreadedBuilder.java:51) at org.apache.maven.lifecycle.internal.LifecycleStarter.execute(LifecycleStarter.java:128) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:307) at org.apache.maven.DefaultMaven.doExecute(DefaultMaven.java:193) at org.apache.maven.DefaultMaven.execute(DefaultMaven.java:106) at org.apache.maven.cli.MavenCli.execute(MavenCli.java:863) at org.apache.maven.cli.MavenCli.doMain(MavenCli.java:288) at org.apache.maven.cli.MavenCli.main(MavenCli.java:199) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:498) at org.codehaus.plexus.classworlds.launcher.Launcher.launchEnhanced(Launcher.java:289) at org.codehaus.plexus.classworlds.launcher.Launcher.launch(Launcher.java:229) at org.codehaus.plexus.classworlds.launcher.Launcher.mainWithExitCode(Launcher.java:415) at org.codehaus.plexus.classworlds.launcher.Launcher.main(Launcher.java:356)Caused by: org.apache.maven.plugin.MojoFailureException: Found 1 non-complying files, failing build at com.coveo.Check.postExecute(Check.java:63) at com.coveo.AbstractFMT.execute(AbstractFMT.java:99) at org.apache.maven.plugin.DefaultBuildPluginManager.executeMojo(DefaultBuildPluginManager.java:134) at org.apache.maven.lifecycle.internal.MojoExecutor.execute(MojoExecutor.java:207) ... 20 more[ERROR] [ERROR] [ERROR] For more information about the errors and possible solutions, please read the following articles:[ERROR] [Help 1] http://cwiki.apache.org/confluence/display/MAVEN/MojoFailureException[ERROR] [ERROR] After correcting the problems, you can resume the build with the command[ERROR] mvn &lt;goals&gt; -rf :plugin-xxx-ide 运行 mvn fmt:format 即可. Issue 8947. 插件开发 官网的 Demo 安装 官网的双开ide的教程复现不了 (第二个 ide 也是显示不了工作区项目的问题), 作罢. 以下是 GitHub 上找到的方法. 123456789git clone https://github.com/che-samples/che-ide-server-extensioncd che-ide-server-extensiongit checkout 6.16.0# 用 Maven 前先换阿里云的源, 不然大概率失败mvn clean install -DskipTests# 启动带插件的 Eclipse Chesudo docker run -ti --rm -v /var/run/docker.sock:/var/run/docker.sock -v ~/Check:/data -v $(pwd)/assembly/assembly-main/target/eclipse-che-6.16.0/eclipse-che-6.16.0:/assembly eclipse/che:6.16.0 start --fast 目前用的一些指令 Docker: 123456789101112131415161718192021# 无插件 IDEsudo docker run -it -v /var/run/docker.sock:/var/run/docker.sock -v ~/Workspace/Eclipse-Che/Eclipse-Che-6.16.0:/data -v ~/.m2:/home/user/.m2 eclipse/che:6.16.0 start# 测试 Pluginsudo docker run -ti --rm -v /var/run/docker.sock:/var/run/docker.sock -v ~/Workspace/Eclipse-Che/Eclipse-Che-6.16.0:/data -v $(pwd)/assembly/assembly-main/target/eclipse-che-6.16.0/eclipse-che-6.16.0:/assembly eclipse/che:6.16.0 start --fast# 测试本地 IDEsudo docker run -ti --rm -v ~/Workspace/Eclipse/Maven/che-6.16.0:/repo -v ~/Workspace/Eclipse-Che/Eclipse-Che-6.16.0:/data -v /var/run/docker.sock:/var/run/docker.sock eclipse/che:6.16.0 start --fast# 删除所有容器sudo docker rm -f $(sudo docker ps -a -q)# Tomcatsudo docker run -d -v /home/xie/Workspace/Eclipse/Maven/CLDIFF-WEB/target/CLDIFF-WEB.war:/usr/local/tomcat/webapps/CLDIFF-WEB.war -p 8080:8080 --name cldiff-server tomcatsudo docker cp /home/xie/Workspace/Eclipse/Maven/CLDIFF-WEB/target/CLDIFF-WEB.war cldiff-server:/usr/local/tomcat/webappssudo docker exec -it cldiff-server /bin/bashsudo /usr/local/bin/tomcat9/bin/startup.sh sudo /usr/local/bin/tomcat9/bin/shutdown.sh Maven: 1234567# 构建 che 整体mvn -DskipTests=true -Dfindbugs.skip=true -Dmdep.analyze.skip=true -Dlicense.skip=true -Dgwt.compiler.localWorkers=2 -T 1C -Pnative -pl '!dashboard' fmt:format clean install -e | tee ~/Desktop/che.log# 构建 plugin-gitcd ~/Workspace/Eclipse/Maven/che-6.16.0/plugins/plugin-gitmvn fmt:format clean install -e -Dlicense.skip=true]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Eclipse Che</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker安装使用]]></title>
    <url>%2Fposts%2F63135.html</url>
    <content type="text"><![CDATA[环境: Ubuntu 安装 (Ubuntu) 使用的官网安装教程: https://docs.docker.com/install/linux/docker-ee/ubuntu/ . 检查系统环境 安装的 CE, EE 要钱. 首先检查系统合不合要求. To install Docker CE, you need the 64-bit version of one of these Ubuntu versions: - Cosmic 18.10 - Bionic 18.04 (LTS) - Xenial 16.04 (LTS) 1234567891011uname -r # 要求内核版本大于 3.10# 4.4.0-21-genericcat /etc/lsb-release # 可以查看是不是 Xenial, 是不是 16.04 等# DISTRIB_ID=Ubuntu# DISTRIB_RELEASE=16.04# DISTRIB_CODENAME=xenial# DISTRIB_DESCRIPTION="Ubuntu 16.04.3 LTS"getconf LONG_BIT # 查看是不是 64 位# 64 先卸载旧版, 若本身就没有安装会提示 Package 'xxx' is not installed, so not removed . 1sudo apt-get remove docker docker-engine docker.io containerd runc 安装 前往 https://download.docker.com/linux/ubuntu/dists/ , 根据 Ubuntu 版本打开对应目录. 例如我的是 https://download.docker.com/linux/ubuntu/dists/xenial/pool/stable/amd64/ , 挑个新版本的 .deb 文件下载./ 上述方法在使用 dpkg 安装该 deb 时安装错误, 因为缺少一些依赖. 于是还是选择了官方最推荐又比较烦的方法. 123456789101112131415161718192021222324252627282930313233sudo apt-get update# 安装一些依赖,比如允许 apt 添加 https 的仓库sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ gnupg-agent \ software-properties-common# 添加 Docker 的官方 GPG Keycurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# 确保该指令输出 "9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88" 字样sudo apt-key fingerprint 0EBFCD88# 添加仓库sudo add-apt-repository \ "deb [arch=amd64] https://download.docker.com/linux/ubuntu \ $(lsb_release -cs) \ stable"sudo apt-get update# 安装**最新版** Dockersudo apt-get install docker-ce docker-ce-cli containerd.io# 安装**指定版本** Docker# apt-cache madison docker-ce # 检索版本# sudo apt-get install docker-ce=&lt;VERSION_STRING&gt; docker-ce-cli=&lt;VERSION_STRING&gt; containerd.io# 验证是否安装成功sudo docker run hello-world 卸载 12sudo apt-get purge docker-ce # 卸载软件sudo rm -rf /var/lib/docker # 删除图片, 容器等文件 指令 一个实例 1sudo docker run -it -v /var/run/docker.sock:/var/run/docker.sock -v ~/Eclipse-Che:/data eclipse/che:6.16.0 start -it: -t 让docker分配一个伪终端并绑定到容器的标准输入上, -i 则让容器的标准输入保持打开. -it 使得伪终端接管 stdin/stdout, 保持 bash 不退出. -v: 挂载宿主机的一个目录 (宿主机目录:容器内目录), 容器目录不可以为相对路径. 指令 123456789101112131415# 容器sudo docker ps # 查看运行中的容器sudo docker ps -a # 查看所有容器sudo docker start &lt;name&gt; # 启动已存在容器sudo docker start -a &lt;name&gt; # 启动容器并在控制台打印其输出sudo docker stop &lt;name&gt; # 关闭容器sudo docker rename &lt;old_name&gt; &lt;new_name&gt; # 重命名sudo docker export &lt;name&gt; &gt; &lt;name&gt;.tar # 导出容器sudo docker rm &lt;name&gt; # 删除容器sudo docker rm -f &lt;name&gt; # 强制删除运行中的容器# 镜像docker images # 查看所有镜像docker images -q # 仅查看所有镜像的iddocker rmi &lt;name&gt; # 删除镜像 启动/关闭 daemon 和 docker Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running? 1234sudo systemctl start docker # 开启 Docker daemonsudo systemctl restart docker # 重启 Docker daemonsudo systemctl daemon-reload # 刷新修改sudo systemctl stop docker # 关闭 Docker daemon]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>快乐背指令</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CMake安装使用]]></title>
    <url>%2Fposts%2F11689.html</url>
    <content type="text"><![CDATA[官方在线文档 安装与新建工程 (Ubuntu) CMake 官网下载: https://cmake.org/download/ . 找个地方解压并进入. 12tar -zxvf cmake-3.14.5.tar.gzcd cmake-3.14.5/ 根据目录下的 README 文件, 执行以下命令安装. 1./bootstrap &amp;&amp; make &amp;&amp; sudo make install 编译好慢啊... CMake 会默认安装在 /usr/local/bin 下面. 用 CMake 编译安装 CMake 1234cd build/cmake ..makesudo make install 构建一个简单的 CMake 项目 新建一个文件夹作为项目文件夹, 新建文件 CMakeLists.txt. 以下为一个典型的配置: 1234567891011# 项目名称PROJECT(CMakeTest CXX)# CMake最低版本需求，不加入此行会受到警告信息CMAKE_MINIMUM_REQUIRED(VERSION 3.14)# 把目录src下所有源代码文件和头文件加入变量SRC_LISTAUX_SOURCE_DIRECTORY(src SRC_LIST)# 生成应用程序 helloADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;) 在 src 文件夹写好源码后 (比如写个 hello_world.cpp), 在项目目录新建文件夹 build. 然后执行 123cd build/cmake ..make 在 build 文件夹下就会生成编译文件和最终的可执行文件 hello. GitHub 优秀 CMake 项目参考 CMake | Qt | OpenCV Visual Studio 对 CMake 的支持 CMake 语法 语法特性 赋值语句 1234567891011121314151617181920# 在当前及其子项目定义变量 VAR (不影响父域)# 使用 $&#123;&lt;var&gt;&#125; 访问# set(VAR a b c) 以定义 LIST (set(VAR "a b c") 则定义了个字符串)set(&lt;var&gt; &lt;value&gt;)# 在父域定义 VAR (而不影响当前环境!!)set(&lt;var&gt; &lt;value&gt; PARENT_SCOPE)# Cache 变量, 定义后全局访问, 且存在 CMakeCache.txt 中# 使用 $CACHE&#123;&lt;var&gt;&#125; 访问, 或当同名常规变量未被定义时也可用 $&#123;&lt;var&gt;&#125; 访问set(&lt;var&gt; &lt;value&gt; CACHE &lt;STRING | BOOL | FILEPATH | PATH&gt; INTERNAL)# 环境变量# 使用 $ENV&#123;&lt;var&gt;&#125; 访问set(ENV&#123;&lt;var&gt;&#125; &lt;path&gt;)# 不再定义unset(&lt;var&gt; [CACHE | PARENT_SCOPE])unset(ENV&#123;&lt;variable&gt;&#125;) LIST 操作 123456789101112131415161718192021222324# 读list(LENGTH &lt;list&gt; &lt;out-var&gt;)list(GET &lt;list&gt; &lt;element index&gt; [&lt;index&gt; ...] &lt;out-var&gt;)list(JOIN &lt;list&gt; &lt;glue&gt; &lt;out-var&gt;)list(SUBLIST &lt;list&gt; &lt;begin&gt; &lt;length&gt; &lt;out-var&gt;)# 查list(FIND &lt;list&gt; &lt;value&gt; &lt;out-var&gt;)# 删改list(APPEND &lt;list&gt; [&lt;element&gt;...])list(FILTER &lt;list&gt; &#123;INCLUDE | EXCLUDE&#125; REGEX &lt;regex&gt;)list(INSERT &lt;list&gt; &lt;index&gt; [&lt;element&gt;...])list(POP_BACK &lt;list&gt; [&lt;out-var&gt;...])list(POP_FRONT &lt;list&gt; [&lt;out-var&gt;...])list(PREPEND &lt;list&gt; [&lt;element&gt;...])list(REMOVE_ITEM &lt;list&gt; &lt;value&gt;...)list(REMOVE_AT &lt;list&gt; &lt;index&gt;...)list(REMOVE_DUPLICATES &lt;list&gt;)list(TRANSFORM &lt;list&gt; &lt;ACTION&gt; [...])# 排序list(REVERSE &lt;list&gt;)list(SORT &lt;list&gt; [...]) 条件语句 1234567if(&lt;condition&gt;) &lt;commands&gt;elseif(&lt;condition&gt;) &lt;commands&gt;else() # 或在括号内填上与 if 一模一样的 &lt;condition&gt; &lt;commands&gt;endif() # 或在括号内填上与 if 一模一样的 &lt;condition&gt; 函数 123function(&lt;func_name&gt; [arg1 [arg2 [arg3 ...]]]) &lt;commands&gt;endfunction() # 或在括号内一字不差地填上 function 括号内内容 宏 123macro(&lt;name&gt; [arg1 [arg2 [arg3 ...]]]) &lt;commands&gt;endmacro() # 或在括号内一字不差地填上 macro 括号内内容 内置函数 12345678910111213141516171819202122232425262728293031323334353637383940# 确定所需 CMake 版本 (最好放在文件的最开头)# cmake_minimum_required(VERSION 3.14 FATAL_ERROR)cmake_minimum_required(VERSION &lt;min&gt;[...&lt;max&gt;] [FATAL_ERROR])# 确定项目名project(&lt;project&gt;)# 添加并构建一个子项目 (即包含 CMakeLists.txt 的文件夹)add_subdirectory(&lt;project_dir&gt; [binary_dir] [EXCLUDE_FROM_ALL])# 将一整个文件夹里的 c/cpp 文件添加到源文件列表,# 得到如 "src/main.cpp;src/s.cpp;..." 的字符串# aux_source_directory(src SRC_LIST)aux_source_directory(&lt;src_dir&gt; &lt;source_list&gt;)# 根据提供的源文件参数生成可执行文件# add_executable(CMakeTest.exe $&#123;SRC_LIST&#125;)add_executable(&lt;target_exe&gt; [WIN32] [MACOSX_BUNDLE] [EXCLUDE_FROM_ALL] [source1] [source2 ...])# 同上, 生成库# add_library(Dependency.lib d1.cpp)add_library(&lt;target_lib&gt; [STATIC | SHARED | MODULE] [EXCLUDE_FROM_ALL] [source1] [source2 ...])# 添加头文件目录 (添加后可识别 #include "xxx.h" 而不用使用相对路径)# include_directories(Dependency)include_directories([AFTER|BEFORE] [SYSTEM] dir1 [dir2 ...])# 给指定目标添加头文件目录# target_include_directories(CMakeTest.exe PRIVATE Dependency)target_include_directories(&lt;target&gt; [SYSTEM] [BEFORE] &lt;INTERFACE|PUBLIC|PRIVATE&gt; [items1...] [&lt;INTERFACE|PUBLIC|PRIVATE&gt; [items2...] ...])# 链接先前已经生成的可执行文件和库# target_link_libraries(CMakeTest.exe Dependency.lib)target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...) 内置变量 CMAKE_SOURCE_DIR | PROJECT_SOURCE_DIR | CMAKE_CURRENT_SOURCE_DIR | &lt;PROJECT_NAME&gt;_SOURCE_DIR 都指向项目的源目录的绝对路径 (CMakeLists.txt 所在的绝对路径). CMAKE_SOURCE_DIR 指向当前最顶层项目 (父项目) CMakeLists.txt 的路径. PROJECT_SOURCE_DIR 指向当前项目 (子项目) CMakeLists.txt 的路径. CMAKE_CURRENT_SOURCE_DIR 指向当前正在处理的 CMakeLists.txt 的路径 (感觉和 PROJECT_SOURCE_DIR 没啥区别啊???). &lt;PROJECT_NAME&gt;_SOURCE_DIR 就是指定某项目的 CMakeLists.txt 的路径. 但是当该项目还未被调用过之前, 该变量未定义. 所以当没有子项目时这几个都相同. 例如对于父项目 Outer 与子项目 Inner: 12345678910# Outer/CMakeLists.txt...project(Outer)add_subdirectory(Inner)...# Outer/Inner/CMakeLists.txt...project(Inner)... 在 Outer/CMakeLists.txt 中的变量值为: CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR CMAKE_CURRENT_SOURCE_DIR Outer_SOURCE_DIR Inner_SOURCE_DIR /.../Outer /.../Outer /.../Outer /.../Outer /.../Outer/Inner 在 Outer/Inner/CMakeLists.txt 中的变量值为: CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR CMAKE_CURRENT_SOURCE_DIR Outer_SOURCE_DIR Inner_SOURCE_DIR /.../Outer /.../Outer/Inner /.../Outer/Inner /.../Outer /.../Outer/Inner TODO: PROJECT_SOURCE_DIR 与 CMAKE_CURRENT_SOURCE_DIR 区别. CMAKE_BINARY_DIR | PROJECT_BINARY_DIR | CMAKE_CURRENT_BINARY_DIR | &lt;PROJECT_NAME&gt;_BINARY_DIR 指向工程编译发生的绝对路径. 区别同上. 如果是 in source 编译, 指的就是工程顶层目录, 即与 &lt;?&gt;_SOURCE_DIR 一样. 而如果是: 123cd build/cmake ..make 这种, 则其路径为 /.../CMake_Project/build . 踩坑 项目依赖作图 (graphviz) 生成依赖图的文件: 12cd build/cmake .. --graphviz=&lt;graph&gt;.dot 在 build/ 下生成 &lt;graph&gt;.dot 文件, &lt;graph&gt;.dot.&lt;target&gt; 文件和 &lt;graph&gt;.dot.&lt;target&gt;.dependers 文件. 安装 graphviz 以生成 png: 1sudo apt-get install graphviz 导出依赖为图片: 1dot &lt;graph&gt;.dot -T png -o &lt;figure&gt;.png 例如对于 cmake-3.14.5 项目: 12345678910111213141516mkdir Buildcd Buildcmake .. --graphviz=graph.dotls | grep graph# graph.dot# graph.dot.cmake# graph.dot.cmake.dependers# graph.dot.CMakeLib# graph.dot.CMakeLib.dependers...# graph.dot.testConsoleBufChild# graph.dot.testConsoleBufChild.dependers# graph.dot.testEncoding# graph.dot.testEncoding.dependersdot graph.dot -T png -o graph.png 打开 graph.png: emmmm, 好丑的图.]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>快乐背指令</tag>
        <tag>CMake</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git安装使用]]></title>
    <url>%2Fposts%2F10606.html</url>
    <content type="text"><![CDATA[指令 Git Bash 使用 ssh 登陆 配置 Git Bash: 12345git config --global user.name &lt;name&gt;git config --global user.email &lt;email&gt;# 如果开了 Github 的 `Keep my email addresses private` 功能,# 设置 email 时 要填 Github 生成的 email, 而不是注册 email.# 还有一些其他可选设置 以下是我的一些配置: 1234567891011121314151617181920212223242526$ git config --listcore.symlinks=falsecore.autocrlf=truecore.fscache=truecolor.diff=autocolor.status=autocolor.branch=autocolor.interactive=truehelp.format=htmlrebase.autosquash=truehttp.sslbackend=opensslhttp.sslcainfo=C:/Program Files/Git/mingw64/ssl/certs/ca-bundle.crtcredential.helper=managercore.editor="C:\\Program Files\\Microsoft VS Code\\Code.exe" --waitdiff.astextplain.textconv=astextplainfilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=truefilter.lfs.clean=git-lfs clean -- %ffilter.lfs.smudge=git-lfs smudge -- %ffilter.lfs.process=git-lfs filter-processfilter.lfs.required=trueuser.name=XieNaobanuser.email=12345678+XieNaoban@users.noreply.github.comcore.quotepath=true 配置 ssh: 12345678910111213141516171819202122232425262728# 查看版本 (我的版本比较新, 老版本的指令略有不同)$ ssh -VOpenSSH_8.0p1, OpenSSL 1.1.1c 28 May 2019# 新开一个 ssh 代理$ ssh-agent -sSSH_AUTH_SOCK=/tmp/ssh-hoSfpFGbN64j/agent.1678; export SSH_AUTH_SOCK;SSH_AGENT_PID=1679; export SSH_AGENT_PID;echo Agent pid 1679;# 确定一下这个 ssh 还没有密钥$ ssh-add -l -E md5The agent has no identities.# 整一个新的密钥, 一路回车确定 (默认配置)$ ssh-keygen -t rsa -b 4096 -C "xjf19970000@live.com"# 新密钥的私钥和公钥储存位置 (id_rsa 和 id_rsa.pub)$ ls ~/.ssh/id_rsa id_rsa.pub known_hosts# 添加到 ssh-agent$ ssh-add ~/.ssh/id_rsaIdentity added: /c/Users/xie/.ssh/id_rsa (xjf19970000@live.com)# 再次查看 ssh-agent 的密钥, 已经成功添加$ ssh-add -l -E md54096 MD5:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx:xx xjf19970000@live.com (RSA) 然后登陆 Github, 复制公钥: 1clip &lt; ~/.ssh/id_rsa.pub 登陆后 https://github.com/settings/keys -&gt; New SSH Key, 'Title' 随意, 在 'Key' 粘贴. 提交三部曲 直接偷懒把当前时间作为本次提交版本的 &quot;提交说明&quot;, 每次都要思考 &quot;提交说明&quot; 怎么写真是太累了. 123456# 获取当前时间作为 "提交说明"readonly date=$(date +%Y-%m-%d\ %H:%M:%S)git add . # 添加当前目录所有文件到暂存区git commit -m "$&#123;date&#125;" # 提交到本地仓库, 以时间作为 "提交说明"git push origin master # origin 表示远程主机, master 为分支名称 分支操作 123456789git branch # 查看分支git branch &lt;branch&gt; # 创建分支git checkout &lt;branch&gt; # 切换分支git checkout -b &lt;branch&gt; # 创建并切换分支# 推送到远程分支: 远程还没有该分支git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; 找不同 123git status # 找出不同的文件、文件夹git status -s # 找不同, 显示很精简规整, 就很舒服git diff # 找出不同的每一行 踩坑 Git Bash 中文乱码 例如对于 git status 指令, 中文文件 &quot;新建文本文档.txt&quot; 会被显示为 1\346\226\260\345\273\272\346\226\207\346\234\254\346\226\207\346\241\243.txt 解决方法如下: 1git config --global core.quotepath false Git Bash 命令提示符的 $ 总是另起一行 命令前的那一串叫 &quot;系统终端命令提示符 (Prompt Sign)&quot; (就是那一串包含用户名, 工作目录和 $ 符号的东西). Windows 下的 Git Bash 的命令提示符的 $ 总是另起一行. 这玩意由 $PS1 控制. 输入 echo &quot;$PS1&quot;, 可得: 12345# 我的PS1被 conda 修改过, 所以前面有个 "(base)"(base)xie@DESKTOP-BAD47V8 MINGW64 ~$ echo "$PS1"(base) \[\033]0;$TITLEPREFIX:$PWD\007\]\n\[\033[32m\]\u@\h \[\033[35m\]$MSYSTEM \[\033[33m\]\w\[\033[36m\]`__git_ps1`\[\033[0m\]\n$ 修改它就能修改提示符样式. 而 Ubuntu 下的 $PS1 为: 12xie@xie-vm:~$ echo "$PS1"\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ 那么依葫芦画瓢改一改. 用 vim 或 code (vscode) 命令打开 ~/.bash_profile, 添加一行: 1export PS1="\[\e]0;\u@\h: \w\a\]$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[32m\]\u@\h\[\033[00m\]:\[\033[33m\]\w\[\033[00m\]\$ " 保存重启 Git Bash即可. Git Bash 中文乱码 然后 12git config --global core.quotepath false# 解决 Windows Git Bash、Linux 下的中文转码问题 使用 ssh 执行 git clone 报错 1234567$ git clone git@github.com:xxx/xxx.gitCloning into 'xxx'...git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 此时如果测试连接, 却显示正常: 12$ ssh -T git@github.comHi XieNaoban! You've successfully authenticated, but GitHub does not provide shell access. 网上的解决方案大多是说 ssh 配置出了问题. 但我这里不是这个原因. 原因是勾选了 https://github.com/settings/emails -&gt; Keep my email addresses private, 好像是我的隐私邮箱被系统更换了, 所以就挂了. 解决方案同下面的 Push 时报错 push declined due to email privacy restrictions Push 时报错 push declined due to email privacy restrictions 从某天开始突然不能 push 了, 错误信息: 1! [remote rejected] master -&gt; master (push declined due to email privacy restrictions) 原因是勾选了 https://github.com/settings/emails -&gt; Keep my email addresses private, 可能是因为它重置了隐私邮箱吧. 复制 Keep my email addresses private 下给的邮箱 (数字+名字@users.noreply.github.com), 12git config --global user.email 12345678+XieNaoban@users.noreply.github.comgit commit --amend --reset-author # 会打开文本编辑器, 直接关闭即可 就好了. Windows 下 Clone 的文件以 LF 为换行符而非 CRLF 设置: 123git config --global core.autocrlf input # 提交时转换为 LF, 签出时不转换# 或git config --global core.autocrlf false # 提交签出均不转换 以下载 LF 的版本. 折腾完了改回去 (毕竟 Win 下还是默认开着好): 1git config --global core.autocrlf true # 提交时转换为 LF, 签出时转换为 CRLF 解决方案: 直接干脆把文件统一成 LF, 不要转来转去了, 反正在 Win 下用 LF 大多数软件也支持. Win 下 warning: LF will be replaced by CRLF Windows 以 CRLF 为换行符, Linux 以 LF 为换行符, Git 仓库以 LF 为换行符. 从 Win 上 git clone 时, Git 会自动把仓库里所有的文件从 LF 转为 CRLF. 当提交时, 又会把 CRLF 转回 LF. 如果提交文件是纯 LF 文件, 会显示一个警告: warning: LF will be replaced by CRLF in xxx.. 直接关了这个 warning: 1git config --global core.safecrlf false # 默认是 'warn']]></content>
      <tags>
        <tag>Windows</tag>
        <tag>快乐背指令</tag>
        <tag>Linux</tag>
        <tag>Git</tag>
        <tag>Git Bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Anaconda安装使用]]></title>
    <url>%2Fposts%2F39659.html</url>
    <content type="text"><![CDATA[操作系统: Windows 10 安装 我选的全局安装 (装在了D盘) 而不是为用户安装 (会被装在C:\Users\name\Anaconda3), 要管理员权限. 安装会自动在 &quot;系统变量&quot; 添加Path: 12345D:\Anaconda3D:\Anaconda3\Library\mingw-w64\binD:\Anaconda3\Library\usr\binD:\Anaconda3\Library\binD:\Anaconda3\Scripts 下次重装系统了把 Path 添加回去兴许还能用. 选择镜像 选择清华的镜像以加速下载. 123conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/conda config --set show_channel_urls yes 环境搭建 创建/删除环境 12345678# 指定 Python 版本创建 "py37" 环境conda create -n py37 python=3.7.3# 列举创建的环境conda env list# 删除指定环境conda remove -n py35 –all 进出环境 1234567891011121314151617# Linuxsource activate py37source deactivate# Windows CMDactivate py37deactivate# Windows PowerShell运行 Anaconda3 目录下的 envs\py37\Lib\venv\scripts\nt\Activate.ps1或先安装这个: conda install -n root -c pscondaenvs pscondaenvs, 然后也能用 activate py37 有点复杂, 不管了# Git Bashsource activate py37source deactivate 更新: 上述指令官方已经不推荐了, 推荐下面的. 1234# 将 conda 更新到 4.7.5 后, # 下列指令在各个终端均通用conda activate py37conda deactivate 包的安装与管理 安装时会自动安装依赖包, 强无敌. 12345678conda search numpy* # 搜索 "numpy" 打头的包conda install numpy # 安装 numpy 在当前环境conda install -n py37 numpy # "-n py37" 以指定环境conda install -n py37 numpy=1.10 # 指定 numpy 安装版本conda install -n py37 numpy scipy pandas # 支持同时安装多个包conda update -n py37 numpy # 更新包conda remove -n py37 numpy # 删除包conda list -n py37 # 查看安装的包 乱七八糟的问题 Git Bash (Windows) 输入 source activate py37 时报错: CommandNotFoundError: No command 'conda conda'. 原因是版本太高. 我的是 4.6.11. 搞个低版本即可. 1conda install conda=4.6.8 或者使用如下替换指令 (高版本里移除了 source activate) 指令. 12conda activate py37conda deactivate # 该指令还是报错 "CommandNotFoundError: No command 'conda conda'." 还是等新版本把吧 更新: 把 conda 更新到了 4.7.5, 没问题了. conda activate 和 source activate 均可, 只不过后者不再被推荐. 在 PowerShell / CMD / Git Bash 均使用 conda activate 指令 在将 conda 更新到 4.7.5 之后, 发现其支持 PowerShell 了, 且 CMD 也支持 conda activate 了. 不过需要事先初始化一下. 在 Git Bash, PowerShell 分别输入一次 1conda init 然后重启该终端, 就能使用 conda activate 或 source activate 了.]]></content>
      <tags>
        <tag>Anaconda</tag>
        <tag>Windows</tag>
        <tag>日常配环境</tag>
        <tag>快乐背指令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[qBittorrent添加Tracker以提速]]></title>
    <url>%2Fposts%2F42107.html</url>
    <content type="text"><![CDATA[知乎uTorrent、qBittorrent、Transmission、Deluge全教程 qBittorrent 添加自定义 Tracker 的方法 qBittorrent -&gt; 工具 -&gt; 选项 -&gt; BitTorrent, 拉到最下面: 勾选 &quot;自动添加以下 trackers 到新的 torrents:&quot; 并填入如下内容 (来源: https://dns.icoa.cn/tracker/). 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990udp://tracker.tiny-vps.com:6969/announcehttps://1337.abcvg.info/announceudp://tracker.torrent.eu.org:451/announceudp://tracker4.itzmx.com:2710/announcehttp://tracker.corpscorp.online:80/announcehttps://tracker.fastdownload.xyz:443/announcehttps://opentracker.xyz:443/announcehttp://open.trackerlist.xyz:80/announcehttps://t.quic.ws:443/announceudp://open.demonii.si:1337/announcehttps://tracker.gbitt.info:443/announceudp://retracker.lanta-net.ru:2710/announcehttp://vps02.net.orel.ru:80/announceudp://tracker.filemail.com:6969/announcehttp://tracker2.dler.org:80/announcehttps://1337.abcvg.info:443/announceudp://explodie.org:6969/announceudp://tracker.internetwarriors.net:1337/announceudp://denis.stalker.upeer.me:6969/announceudp://exodus.desync.com:6969/announcehttps://tracker.vectahosting.eu:2053/announceudp://tracker.leechers-paradise.org:6969/announcehttps://tracker.parrotsec.org:443/announceudp://tracker.supertracker.net:1337/announcehttp://gwp2-v19.rinet.ru:80/announceudp://carapax.net:6969/announceudp://retracker.maxnet.ua:80/announcehttp://tracker.files.fm:6969/announcehttp://retracker.joxnet.ru:80/announcehttp://tracker.moxing.party:6969/announceudp://bt.xxx-tracker.com:2710/announceudp://zephir.monocul.us:6969/announceudp://tracker.iamhansen.xyz:2000/announcehttp://opentracker.h4ck.me:6969/announceudp://torrentclub.tech:6969/announceudp://retracker.netbynet.ru:2710/announcehttp://web4.obit.ru:80/announceudp://retracker.baikal-telecom.net:2710/announcehttp://bt1.xxxxbt.cc:6969/announceudp://tracker.uw0.xyz:6969/announceudp://thetracker.org:80/announceudp://tracker.filepit.to:6969/announceudp://retracker.akado-ural.ru:80/announcehttp://t.nyaatracker.com:80/announceudp://tracker.dyn.im:6969/announceudp://tracker.openbittorrent.com:80/announceudp://tracker.cyberia.is:6969/announcehttp://tracker3.itzmx.com:6961/announceudp://ipv4.tracker.harry.lu:80/announceudp://188.241.58.209:6969/announceudp://208.83.20.20:6969/announceudp://185.225.17.100:1337/announceudp://93.158.213.92:1337/announcehttp://93.158.213.92:1337/announcehttp://176.113.71.19:6961/announceudp://5.2.79.219:1337/announceudp://91.216.110.52:451/announceudp://95.211.168.204:2710/announceudp://5.206.58.23:6969/announceudp://159.100.245.181:6969/announceudp://176.31.241.153:80/announceudp://5.2.79.22:6969/announceudp://188.246.227.212:80/announceudp://184.105.151.164:6969/announcehttp://184.105.151.164:6969/announceudp://207.246.121.172:2000/announceudp://109.248.43.36:6969/announceudp://45.56.74.11:6969/announceudp://37.235.174.46:2710/announceudp://194.143.148.21:2710/announcehttp://78.30.254.12:2710/announceudp://190.146.242.80:7070/announceudp://89.35.39.197:1337/announceudp://52.58.128.163:6969/announceudp://212.1.226.176:2710/announceudp://94.177.237.99:6969/announcehttp://86.62.124.78:80/announceudp://185.83.215.123:6969/announceudp://199.247.2.19:6969/announcehttp://199.247.2.19:6969/announceudp://212.47.227.58:6969/announcehttp://95.107.48.115:80/announcehttp://91.207.136.85:80/announceudp://37.187.123.8:2710/announceudp://81.200.240.19:6969/announceudp://52.29.11.73:6969/announceudp://52.28.76.37:6969/announceudp://45.79.184.106:6969/announcehttp://193.148.69.107:80/announcehttp://54.39.98.124:80/announce qBittorrent -&gt; 工具 -&gt; 选项 -&gt; 高级: 勾选 &quot;总是向同级的所有 Tracker 汇报&quot;.]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>日常配环境</tag>
        <tag>qBittorrent</tag>
        <tag>Torrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019复旦计算机专硕考研经验]]></title>
    <url>%2Fposts%2F30183.html</url>
    <content type="text"><![CDATA[战果 本人双非科班, 初试排名大约为 70. 政治 英语二 数学二 专业课 (960) 初试总分 复试总分 64 82 121 110 377 78.91 初试 政治 我政治是从 10 月份开始复习 (预习)的. 政治完全没必要更早时间开始看, 一方面是因为每年政治考纲变化大, 所以往年教材参考意义不大, 另一方面 2 至 3 个月确实足以应付政治. 一轮预习: 10 月初 ~ 11 月初 使用材料: 徐涛强化视频 + 肖秀荣精讲精练 + 肖秀荣1000题. 时间分配: 每天花的时间其实不多, 看视频画重点还是挺轻松的, 就是做题耗时比较长, 但也不是每天都做题. 徐涛视频我直接看的强化视频 (2 倍速), 没看基础视频. 涛哥讲课确实很好. 听说腿姐的授课也不错, 用的人也很多, 自行选择. 但是肖秀荣团队的视频口碑反而好像很差... 徐涛视频本来是有一本配套的&quot;核心考案&quot;的, 我也买了, 但当时感觉核心考案内容较少 (相对于精讲精练), 总担心漏知识点, 于是教材使用的精讲精练. 徐涛视频和精讲精练绝大部分还是对的上的, 就可能有时候顺序不太一样, 会浪费一些时间找知识点位置. 现在想想没必要 &quot;徐涛视频 + 肖秀荣精讲精练&quot; 的组合, 毕竟当视频与精讲精练不太匹配时, 自己要两方考证, 有点费时费力. 徐涛的核心考案虽然看着字少但也不至于出现漏知识点的低级错误, 所以我现在推荐 &quot;徐涛视频 + 徐涛核心考案&quot; 即可. 肖秀荣1000题我刷了两遍. 第一遍和授课同步, 看一章做一章. 这玩意做起来错一半轻轻松松... 第二遍等看完一遍教材再复习一遍, 还是错一堆, 经常也要错三分之一. 一轮复习不涉及主观题, 做题也都是做客观题. 二轮复习: 11 月中旬 ~ 考试 使用材料: 肖八 + 肖四. 时间分配: 客观题每天一套, 耗时不长. 背肖四主观题还是很耗时的, 最后几天一下午 + 一晚上都在背政治. 一轮复习完肖八还没开售, 所以近半个月没看政治. 等肖八到了刷了两遍客观题, 主观题依然没去管. 肖八结束就等肖四发货, 期间没怎么看政治. 后来肖四到了, 这可是重中之重, 客观题必须全部理解, 主观题全部背诵. 我当时主观题背了一个星期. 事实证明今年政治主观题考了不少肖四原题. 期间我还尝试背过徐涛的小黄书. 小黄书名义上是 20 个背诵考点, 但每个考点里又有 3 到 5 个子问题, 每个子问题的答案又有好多好多行, 我背了 5 个考点 (也就是 20 来个子问题), 感觉要屎了, 遂怒弃之. 你肖爷爷还是你肖爷爷, 肖四在手, 六十不愁. 英语 英语我自己对答案下来客观题可能只扣了 2 分左右, 说明主观题做的不好, 只拿了 24 分. 重点就在背单词和做真题上面, 以及作文最好准备一下. 英语我花的时间最少, 大头还是背单词. 没必要看名师视频, 没必要整辅导资料 (除了真题的解析和临时抱佛脚用的作文辅导书). 看过朱伟的恋恋有词 (视频 + 书), 效率不高. 何凯文我也关注过, 也买了他的长难句解析, 效率不高 (以及后来他人设好像还崩了???). 前期: 1 月底 ~ 5 月 使用材料: 扇贝单词. 时间分配: 尽量每天 (也有好些天比较怠惰没背) 300 个单词, 40 ~ 70 分钟. 用的扇贝单词 APP, 有时间就背. 1 月底就开始背了, 从简单的单词书开始背, 最后上考研词汇. 到 5 月份基本上背完一遍. 然后就停了. 中期: 8 月 使用材料: 英一真题. 时间分配: 英一真题客观题每天一套, 做完为止. 除此之外这几个月没碰英语 (江苏考生的秘制自信). 然而英一真题做下来很不好, 每次都错一堆, 心态有点崩. 后期: 10 月(?) ~ 考试 使用材料: 扇贝单词 + 英二真题 + 一些作文辅导书 + 英语字帖. 时间分配: 上午到图书馆 (8 点多) 放下书包就出去背单词, 300 个单词 40 ~ 120 分钟不等, 视单词书难度而定. 做真题的话一套一般一上午. 复习作文是在考前一个月还是半个月的事了, 多花点时间整理整理一些骚句子, 练练真题的作文. 背单词还是最重要!!! 我兴冲冲地做了三天英二真题, 发现我这破词汇量是真的不行. 之前背的单词都忘光咯, 赶紧捡起来继续背 (背单词真滴累). 然后真题搁置了半个月再做. 考前半个月还是一个月开始捣鼓捣鼓作文, 学习学习满分范文 (学不会的), 从几本作文辅导书上找找好的句子摘抄下来, 在哪遇到好的句式或词组就记下来背背. 正所谓功夫不负有心人, 经过这半个月的努力写作文, 事实终于证明了像我这么考前抱佛脚并没有什么用 (如果我客观题只扣 2 分属实, 那我 40 分的主观题只拿了 24 分). 所以作文还是积累在平时啊, 不要学我. 另外当自己开始练习写作文了, 才发现几年不写, 自己的字愈发丑陋了, 真写这一坨交上去不如交白卷得了, 于是买了本英语字帖不定期中午睡午觉前练练. 数学 我做题很慢... 别人做卷子一个半小时就做完了, 我至少要两个半小时, 有时候三小时还做不完. 但是我做过的题正确率还是能保证的. 这次考研我就又炸了, 两道大题空着没来得及写... 另外我线代第一题我竟然忘了怎么写了... 复习时线代被轻视了, 教训惨痛. 另外关于&quot;跟汤家凤还是张宇&quot;, 我当时主要跟的汤家凤, 现在我还是推荐汤家凤. 网上常说:&quot;汤家凤讲的东西偏基础&quot;. 但汤的材料做下来, 我的感觉是, 那不叫&quot;汤家凤讲的基础&quot;, 而叫&quot;汤家凤讲的课基础扎实&quot;, 他的课不如张宇生动, 但是讲课稳稳当当. 以及, 1800做到后面其实并不基础 (和真题比还是拔高了不少的), 大家说他基础可能是和张宇比较的来的结论. 张宇讲的确实很深 (很难). 两位老师的教材我都买了 (本来想的是&quot;我全都看&quot;, 后来发现不仅来不及, 也没必要. 都是名师, 跟随一个老师走到底不会出岔子的), 但宇哥这些题可能有些太注重技巧性了, 而数二真题做下来我发现, 数二考的其实主要是计算 (数二的题计算量很大), 但没有什么题需要这么高技巧性去解. 这就导致宇哥和真题其实契合度不高 (上述主要对于数二, 数一可能确实比较难, 我没有发言权). 一轮复习: 5 月 ~ 9 月中旬 使用材料: 高等数学教材 + 汤家凤基础视频 + 汤家凤辅导讲义 + 汤家凤1800 + 张宇强化视频 + 李永乐线代基础&amp;强化视频 + 李永乐线代讲义 + 李永乐复习全书. 时间分配: 暑假之前比较水, 复习强度很低很低 (基本可以视作暑假开始复习). 暑假期间家旁边有图书馆, 9 点开门 5 点关门, 我每天也就这段时间学习, 中午图书馆旁边吃个饭再回图书馆睡个午觉, 晚上不怎么学. 暑假主要就数学和专业课, 我喜欢一天只学一门 (到后期才每门课每天复习复习), 所以专业课和数学差不多一天隔一天学. 貌似是在暑假前, 我把高数教材上下册过了一遍, 上面有一些定理的证明比如柯西中值定理的证明等等感觉还是要看看的. 过完一遍才发现大家不是很推荐刷教材, 网上说教材和考研差异还是比较大的. 汤家凤基础视频 (2 倍速) + 汤家凤辅导讲义 + 汤家凤1800 (的基础部分) 一起看. 7 月 20 多号结束. 看视频的时候记了笔记, 之后也经常会翻阅到, 挺有用的. 现在想来汤神的资料确实很好. 然后看线性代数. 线代看的永乐大帝线代基础视频 (2 倍速) + 李永乐线代讲义 (网友几乎一致推荐线代跟李永乐), 并做了汤家凤1800的线代基础部分. 大概花了一星期时间, 7 月 底看完. 我线代复习的不太好, 后期线代忘得特快. 然后我看的李永乐的全书, 两三天一章, 8 月 20 多号看完. 全书里对各种定义扣的很细, 很锻炼对所学知识的理解. 但我总感觉这本书里题目怪怪的... 尤其证明题那里的例题也太难了吧. 然后看的张宇的强化视频 (2 倍速) + 1800 (的提高部分), 看一章视频做一章 1800. 宇哥视频确实幽默, 讲的内容也很棒, 他讲的一些方法技巧很开阔眼界. 但是之前也说了, 宇哥技巧性很强, 挖的深但和真题并不很契合. 我舍友看的汤家凤强化觉得很棒 (他考上的南大). 最后是李永乐线代强化视频 + 1800 线代提高部分. 二轮复习: 9 月 ~ 10 月 使用材料: 同上 + 李永乐 660 + 汤家凤喊你起床.mp3. 时间分配: 一个上午或一个下午或一个晚上看数学. 主要是二刷上述所有材料, 整理整理错题. 一轮复习时给那些比较难的题画了星星, 二轮重点做这些画了星星的题. 10 月 20 日开始做 660. 660 我只做了选择题, 难题不多, 一星期做完. 二轮期间此时精力越来越转移到专业课上. 另外推荐每天早上花个 5 分钟过个几遍 &quot;汤家凤喊你起床.mp3&quot;, 考研分数提升立竿见影. 你怎么睡得着的啊? 你这个年龄段, 你这个阶段你睡得着觉? 有点出息没有??? ——汤家凤 三轮复习: 11 月 ~ 12 月 使用材料: 汤家凤历年真题全解析 + 合工大超越模拟卷 + 汤家凤喊你起床.mp3. 时间分配: 一个上午或一个下午或一个晚上. 真题只做了 2000 ~ 2018 的数二真题. 每天一套. 前面的真题很简单, 经常接近满分. 只有最近几年的题开始变难了, 计算量也猛增. 好像是 2016 和 2018 的题我做的非常差. 今年的难度和 2016, 2018 的比较像吧. 模拟卷我看大家都推荐合工大, 就做了几套它的超越卷. 质量很高 (或者说就是很难...), 做了几套放弃了, 还是看错题实在. 12 月后时间大多在政治背诵和专业课背诵上. 偶尔做做数学保持手感. 专业课 数据结构我还算擅长, 但考试时代码题最后写的, 差点来不及写, 代码写得很急, 涂涂改改的我自己都看不下去, 不知道老师有没有给分... 一题 15 分呢. 操作系统有考简述题, 我对这类题不太擅长, 写完了也没底. 网络我复习的不好, 也考的很差, 考完有种 30 分不要了的感觉. 一轮复习: 7 月 ~ 10 月 使用材料: 王道数据结构 + 王道操作系统 + 王道计算机网络 + 操作系统教程(费翔林) + 计算机网络(谢希仁) + 算法与数据结构考研试题精析. 时间分配: 暑假期间专业课花的时间比数学少. 开学后每天花一个上午或一个下午或一个晚上. 越往后专业课每日占比越大. 我是按 数据结构 -&gt; 操作系统 -&gt; 网络 的顺序复习的. 数据结构占比 90 分, 优先复习. 操作系统和网络都是 30 分, 但是操作系统容易拿分, 所以第二个复习. 而网络, 根据往年学长的经验帖, 很难拿分, 所以最后复习. 数据结构用王道或者天勤的教材就够了. 另外算法与数据结构考研试题精析 (俗称 1800 题) 非常非常重要, 按照考纲重点刷. 但是要注意的是 1800 题答案出错的地方不少! 所以有疑问多去考研群里提问. 操作系统我一开始只用的王道, 但后来发现王道里知识点太简略了 (现在想想其实这书写的不太好). 所以翻出了学校里用的操作系统教材看. 你们如果用的别的教材也可以, 按照考纲来. 题目就做王道的好了. 但要注意! 王道自己出的题很多都不好, 有的表述模糊, 有的答案还是错的! 它有一道计算题在考验群里被提起了无数次, 最后讨论下来是它答案错了. 网络的话, 王道的网络和 960 差距蛮大的, 而且王道的网络知识点少. 但是它的题目可以做做 (稍微做点即可, 这些题目和 960 方向也不太一致). 所以我用的学校用的谢希仁的教材. 说实话网络我不太会复习, 书很厚, 囫囵吞枣看下来不知道自己看了什么. 二轮复习: 11 月 ~ 考试 使用材料: 同上. 时间分配: 同上. 主要就二刷甚至三刷上述资料. 1800 第二第三遍只刷画星星的题. 另外考前背了背谢希仁网络的一张附录: 英文缩写/英文全称/中文翻译. 结果今年没考翻译. 复试 当时考研最终选择复旦也是考虑到它的复试机试考算法, 比较适合我. 我本科期间也稍微学过一点算法竞赛. 第一天上午机试遇到了些小状况, 就是机房电脑总是出各种毛病, 调试了快一个小时才正式开考. 我的电脑就出了状况, 还是比较影响状态的 (甚至手忙脚乱到忘记给志愿信息表勾选&quot;调剂&quot;了). 机试三道题, 也确实不难. 主要还是要细心啊. 虽然还不知道结果, 但我前两题应该还行, 各种细节也有考虑到. 第三题也不难, 但问题在于即便是使用 long long 也过不了很多用例. 所以最好使用 Java 的大数来写本题. 但是很遗憾当我后知后觉地突然意识到 long long 不够用的时候已经没时间改 Java 了, 才写几行就交卷了. 下午口语面试. 我开头的自我介绍也准备的比较充分, 虽然临场还是有点忘词. 老师也比较和蔼. 其中老师还问到我的 &quot;hobby&quot;, 我不小心脱口而出 &quot;computer games!&quot; emmmmm 老师我两分钟内能撤回吗. 口语问题很宽泛很个性化. 比如有大佬被问了乔丹有多高. 第二天一整天面试 (99% 的时间在排队). 由于复试人太多, 原定的一, 二志愿各面试一次, 改为只面试一志愿. 进房间, 一圈的老师, 老师超凶_(´ཀ`」 ∠)_ (明明前面进去的有人出来说老师很和蔼. 为什么会变成这样呢?)... 被怼到放弃治疗, 我表现真的很差劲. 最后临出来前我还是厚着脸皮问老师我机试成绩, &quot;你去问专门的老师.&quot; 老师严肃地说到. (无可奉告?!) 复试这两天还是很紧张的, 紧张的吃不下饭. 其他 作息 暑假前我复习很划水, 进度缓慢. 暑假期间家旁边的图书馆 9:00 开门, 17:00 点关门. 我也基本这个时间段学习. 中午就在图书馆旁边快餐店吃. 回来趴桌子上睡个午觉. 晚上不怎么学习. 开学后学校图书馆 (的考研教室) 6:00 开门, 21:30 关门. 6 点需要抢座位必须醒. 一开始还能坚持几天 6 点起床, 后来实在起不来. 最后决定抢完座位继续睡! 然后 8 点 (甚至更晚) 再起床去图书馆. 不然老犯困, 没有意义. 中午吃完趴桌子上睡午觉. 一开始还能半小时醒, 越到后期睡越久. 晚上闭馆后去通宵教室呆到 11 点以后. 时间分配也不细致. 前期一天只复习一门科目. 后期一天的时间主要就分为三块, &quot;一上午&quot;, &quot;一下午&quot;, 和 &quot;一晚上&quot;. 每块时间只做一个科目. 时间分配还是看自己的节奏吧. 每天看上去学的时间很久, 其实一天真正专注的时间也不会很长, 学一阵子还要逛逛知乎玩玩 B 站看看新闻. 太疲劳太枯燥我真的坚持不了. 健康 我备考期间有一阵子肠胃很不好, 然后咳嗽 (可能还是压力大了, 平常从没这样过), 什么小毛病一定要腾出半天一天去看医生. 考研战线还是很长的, 身体不好得不偿失. 另外要劳逸结合, 如果你是真心想考研, 那你压力应该还是不小的. 比如我越到考试前打游戏频率反而越频繁了, 因为考前容易烦躁, 游戏打打就平静了. 当然打游戏能克制还是克制. 关于考研群 经常会有人声称自己开学前就数学复习多少遍了, 以及各种想方设法劝退的, 如&quot;复旦今年不提供宿舍!&quot;, &quot;今年复旦必炸!&quot;, 搞得你很慌. 但事实上, 他们说的还真没错! 哈哈哈开玩笑的, 一方面考研群里信息要实时关注, 另一方流言还是满天飞的, 要学(习)会(惯)甄(就)别(好). 我和我舍友一开始就很容易被这类或真或假的消息搞得无心学习, 后来看得多了就好了. 最简单的方法是, 把所有同类学校的考研群都加一遍, 然后你会发现, 每个群都在复读着 &quot;今年必炸&quot;. 一个有趣的现象, 考试前群里很活跃的人和考试后群里活跃的人往往是不同的一拨人; 出成绩前很活跃的人和出成绩后很活跃的人又不是一批人.]]></content>
      <tags>
        <tag>考研</tag>
        <tag>反思总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hexo搭建Github博客]]></title>
    <url>%2Fposts%2F52843.html</url>
    <content type="text"><![CDATA[平台: Windows 10 使用的 Hexo 主题: Next 平台安装 安装 Git (Git 官网) 并如下配置: 打开Git Bash: 1234567891011121314151617181920# 针对你的 Github 账户生成一个 SSH key:ssh-keygen -t rsa -b 4096 -C "username@host.com"# 按三次回车, 密码设为空# 最终在 C:\Users\Username 下生成 .ssh 文件夹并产生 id_rsa, id_rsa.pub 文件# 验证 SSH 代理运行:eval $(ssh-agent -s)# 若正常运行则输出 Agent pid xxxxx# 添加 SSH 私钥至代理:ssh-add ~/.ssh/id_rsa# 复制 SSH 公钥到 Github 账号:clip &lt; ~/.ssh/id_rsa.pub# 然后网页转到 https://github.com/settings/keys (在登陆的前提下)# 点击 New SSH key, title 随意, 在 key 文本框 Ctrl+V# 验证 SSH 连接ssh -T git@github.com # 显示: Hi Username! You've successfully authenticated, but GitHub does not provide shell access. 安装 Node.js (Node.js 官网, 安装完即可使用 npm )). 在 Github 上创建 username.github.io 仓库. 安装并配置 Hexo: 安装: 1npm install -g hexo-cli (该指令表明 Hexo 为全局安装). 确定一个空文件夹(必须是空的)作为 Hexo 站点, 在文件夹内右键菜单,选择 &quot;Git Bash Here&quot; 打开 Git Bash, 输入: 1hexo init 在该文件夹下产生一些 Hexo 文件. 然后打开刚生成的站点配置文件 _config.yml, 必要的修改如下: 12345678910title: XXX's Blogauthor: XXXlanguage: zh-CH # 或 language: en 等等theme: nextdeploy:type: gitrepo: git@github.com:XXX/XXX.github.io.gitbranch: master Next 主题安装与配置 安装并配置 Next 主题 (Next 官网, 配置教程官网有). (Hexo 与 Next 主题各有一个 _config.yml 配置文件, 注意区分.) 网站发布至 github.io 在 Hexo 目录安装: 1npm install hexo-deployer-git 首先我们可以在本地调试而不急于上传 Github: (同样在 Hexo 目录) 123hexo cleanhexo ghexo s 执行完毕后打开 http://localhost:4000 即可查看主页. 针对 Markdown, 主题文件的任何修改, 保存后对网页按 F5 刷新立即可查看修改结果. 针对 Hexo 的修改似乎需要重启服务器. 要发布至 Github 则: 123hexo cleanhexo ghexo d 指令执行完毕即可前往 github.io 查看结果. 踩坑 生成页面 生成新文章页 1hexo n &lt;post_name&gt; 本质上就是在 source/_posts/ 下生成一个 &lt;post_name&gt;.md 和一个 &lt;post_name&gt; 的文件夹. 其中 md 文件根据模板生成. 生成标签 (Tags) 和分类 (Categories) 页面 默认是没有这些页面的, 当在主页点击标签, 分类页面时会显示 Cannot GET /tags/ 或 Cannot GET /categories/. 生成方法: 1hexo new page tags 然后进入 source/tags/, 修改 index.html: 123456---title: tagsdate: 2019-04-11 16:35:04type: "tags"comments: false--- categories, about 等同理. 文章的标题, 发布时间, 与标签等设置与模板 在 Markdown 文件最开头插入如下内容: 12345678910111213---title: 标题标题标题标题categories: - 分类 - 子分类 - 子子分类tags: - 标签1 - 标签2 - 标签3abbrlink: 41653date: 2017-10-22 15:12:50--- 其中 title 必须填写, 不会根据文件名自动生成; abbrlink 是自动生成的, 请勿自己输入; 其余三项可有可无. Hexo 提供 Markdown 生成模板(仅限使用 hexo n &lt;file_name&gt; 时), 打开 Hexo 站点目录下的 scaffolds/post.md, 若想要生成上述内容可如下填写: 12345678---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;categories: - tags: - --- Markdown 与图片的问题 在 Hexo 站点文件夹下打开 Git Bash, 输入: 1npm install hexo-asset-image --save 打开站点配置文件 _config.yml, 修改: 1post_asset_folder: true 以后再使用 hexo n &lt;post_name&gt; 命令新建 Markdown 文件时, 会对应生成同名文件夹, 存放该文件的图片等资源. 但问题没有被完全解决, 此时在 Markdown 文件引用图片时, 必须以 ![图片](&lt;post_name&gt;/123.png) 的方式引用, 而不能直接 ![图片](123.png). PS: Hexo 好像更新了方案! 现在可以直接 ![图片](123.png) 了! 修改文章与网址的映射关系 默认情况每篇文章的链接为: &quot;xxx.github.io/2019/01/01/标题&quot;, 这种以标题为组织方式的链接有时候不太好, 以下改为以 CRC 码为组织方式. 在 Hexo 站点文件夹下打开 Git Bash, 输入: 1npm install hexo-abbrlink --save 打开站点配置文件 _config.yml, 修改: 123456789# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.comroot: /permalink: posts/:abbrlink.htmlpermalink_defaults:abbrlink: alg: crc16 rep: dec 开启 LaTeX 公式并修复默认公式渲染的 Bug 默认 Next 主题不渲染公式. 开启渲染如下: 打开 Next 主题的配置文件 _config.yml, 修改: 1234math: enable: true per_page: false engine: mathjax 此时发现, 对于多行的公式, 如: 123456789$$\begin&#123;aligned&#125;a^&#123;[i+1]&#125; &amp; = z^&#123;[i+1]&#125; \\&amp; = w^&#123;[i+1]&#125;a^&#123;[i]&#125; + b^&#123;[i+1]&#125; \\&amp; = w^&#123;[i+1]&#125;(w^&#123;[i]&#125;a^&#123;[i-1]&#125; + b^&#123;[i]&#125; + b^&#123;[i+1]&#125; \\&amp; = (w^&#123;[i+1]&#125;w^&#123;[i]&#125;)a^&#123;[i-1]&#125; + (w^&#123;[i+1]&#125;b^&#123;[i]&#125;+b^&#123;[i+1]&#125;) \\&amp; = w'a^&#123;[i-1]&#125; + b'\end&#123;aligned&#125;$$ \[ \begin{aligned} a^{[i+1]} &amp; = z^{[i+1]} \\ &amp; = w^{[i+1]}a^{[i]} + b^{[i+1]} \\ &amp; = w^{[i+1]}(w^{[i]}a^{[i-1]} + b^{[i]} + b^{[i+1]} \\ &amp; = (w^{[i+1]}w^{[i]})a^{[i-1]} + (w^{[i+1]}b^{[i]}+b^{[i+1]}) \\ &amp; = w&#39;a^{[i-1]} + b&#39; \end{aligned} \] 渲染出来全挤在一行. 那肯定是不行的. 试过别的方法如 hexo-renderer-markdown-it-plus, hexo-math, 都不好用. 最好用的还是下面这个: 首先安装 Pandoc (Pandoc 官网), 然后执行下述指令以替换自带的 Renderer. 12npm uninstall hexo-renderer-marked --savenpm install hexo-renderer-pandoc --save 目前来看还不错. 开启 Markdown 的流程图支持 1npm install hexo-filter-flowchart --save 自定义非 Hexo 页面 例如我想在 xienaoban.github.io/demo/ 下新建自定义一些网页, 希望 demo 文件夹下的所有网页不受 Hexo 框架影响. 在 Hexo 站点目录打开 Git Bash, 在 source 文件夹下新建 demo 文件夹: 1hexo new page demo 在 source/demo/ 下建立想要展示的 html 文件. 修改站点配置文件 _config.yml: 1skip_render: demo/** 生成, 运行, Hexo 会将这些 html 直接复制到 public 文件夹下而不加以处理. 令 Next 主题默认展开所有子目录 打开 Next 主题下的 source/css/_custom/custom.styl, 添加一行 1.post-toc .nav .nav-child &#123; display: block; &#125; Hexo 本地搜索功能 于站点目录安装插件 1npm install hexo-generator-searchdb --save 于站点配置文件添加如下几行: 12345search: path: search.xml field: post format: html limit: 10000 于 Next 主题配置文件 _config.yml, 修改: 12local_search: enable: true]]></content>
      <tags>
        <tag>Windows</tag>
        <tag>日常配环境</tag>
        <tag>快乐背指令</tag>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深澜校园网无法打开(弹出)登陆网页解决方案]]></title>
    <url>%2Fposts%2F46279.html</url>
    <content type="text"><![CDATA[(适用于Windows) 打开CMD, 两行指令: 12ipconfig /releaseipconfig /renew]]></content>
      <tags>
        <tag>深澜</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Eclipse开启代码提示与关闭变量命名补全]]></title>
    <url>%2Fposts%2F32764.html</url>
    <content type="text"><![CDATA[[TOC] 增强代码提示功能 找到设置位置: Window -&gt; Preferences -&gt; Java -&gt; Editor -&gt; Content Assist. 将 Auto Activation 下的 Auto activation triggers for Java (默认为 .) 改为 ._abcdefghijklmnopqrstuvwsyzABCDEFGHIJKLMNOPQRSTUVWSYZ. (若此时发现, 输入一个字符时依然没有弹出自动提示的框框, 则继续执行下一步) 转到: Window -&gt; Preferences -&gt; Java -&gt; Editor -&gt; Content Assist -&gt; Advanced. 在上边那个大框中, 将 Java Proposals 与 Java Proposals (Task-Focused) 勾选上. PS: 介绍一下 Java Proposals 这些选项的含义: 选项 含义 Java Type Proposals 类名, 关键字的提示 Java Non-Type Proposals 其实就是变量名的提示 Java Proposals Java Non-Type Proposals 与 Java Type Proposals 的并集 Java Proposals (Task-Focused) 不太清楚, 感觉和 Java Proposals 差不多 (当同时勾选Java Type Proposals Java Non-Type Proposals Java Proposals时, 重启 Eclipse 会发现 Java Non-Type Proposals 与 Java Type Proposals 被取消勾选, 验证了三者关系) 此时代码补全提示应该如下图正常显示: 解决自动变量命名问题 增强代码提示后有个 bug, 即给变量命名时亦会自动补全, 就很蠢. 如下图: 此时不论按 = 还是 ;, 变量都会自动补全, 被命名为 abcdBigInteger. 解决方案: 这个 bug 产生于 Eclipse 自带的 org.eclipse.jface.text 插件. 我们可以在 Window -&gt; Show View -&gt; Other... -&gt; Plug-in Development -&gt; Plug-ins 视图下找到这个插件. 网上有的教程的做法是, 在 Plug-ins 视图下右键该插件然后 Import As -&gt; Source Project. 但该方法已经无法使用, 因为导入的工程现在没有源码只有 .jar 文件. 1. 获取工程 所以我们要去官网下载插件源码. 插件官网, 插件下载(eclipse.platform.text-I20190325-1800.zip). 在下载的压缩包中找到 org.eclipse.jface.text 工程文件夹, 解压到工作区并打开. 2. 修改代码 在 src 下找到 CompletionProposalPopup.java (如图)并打开. Ctrl+F 搜索 if (contains(triggers, key)) {, 并将其修改: 1234将if (contains(triggers, key)) &#123;修改为if (key != '=' &amp;&amp; key != ' ' &amp;&amp; key != ';' &amp;&amp; contains(triggers, key)) &#123; 目的很明显, 当我们输入 = ; 时不再自动补全. 以此曲线救国达到命名变量时不补全的目的... 3. 导出插件 File -&gt; Export -&gt; Deployable plug-ins and fragments 桌面上产生了一个 plugins 文件夹. 打开该文件夹, 即是插件文件. 打开 Eclipse 安装目录下的 plugins 文件夹. 搜索 org.eclipse.jface.text, 把搜索得的老插件删了, 把刚导出的修改版插件放进去. 重启 Eclipse 即可. 法二（更方便） 打开window -&gt; Preference -&gt;Java -&gt; Editor -&gt; Content Assist. 勾选 Disable insertion triggers except 'Enter'.]]></content>
      <tags>
        <tag>日常配环境</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带精英策略的非支配排序的遗传算法NSGAII]]></title>
    <url>%2Fposts%2F60126.html</url>
    <content type="text"><![CDATA[啊要出分数线了好紧张. 赶紧复习复习以前学的东西_(:з」∠)_ 竟然写了大半天, 全都忘光了, 怕不是要凉 (/ﾟДﾟ)/ [TOC] 遗传算法(Genetic Algorithm) 此处使用二进制编码法形成染色体. 种群初始化: 随机将染色体的某些 DNA 置 1, 进行 M 次, 形成 M 个不重复的个体组成第一代种群. 适应度评价: 对每个个体运行适应度评价函数, 区分群体中个体好坏. 并按照一定策略选择出部分适应度高的个体, 作为下一代的父代. 交叉与变异: 对挑选出的父代, 每次随机选择两个染色体, 在一定概率下将两者的某些 DNA 进行交换, 形成两个新的个体, 即为染色体的交叉; 同时上述新产生的个体有一定概率发生染色体变异, 即对染色体的某些位取反. 最后形成新的子代. 遗传算法就是上述步骤的反复. 非支配排序遗传算法(Non-Dominated Sorting Genetic Algorithm, NSGA) 有时候我们的优化目标不止一个, 比如买菜时同时要求菜越新鲜越好, 且单价越便宜越好. 这便是多目标优化问题. 面对此类问题时, 无法用 1 个指标衡量染色体的好坏, 在判断两个染色体孰优孰劣时将会产生困难. NSGA 解决多目标问题和普通 GA 的主要区别就是在选择算子执行之前对个体关系的分层, 而选择算子, 交叉算子, 变异算子没有区别. Pareto 支配关系 Pareto 最优解给出了多目标问题的判别的方法. 对于最小化多目标问题, n 个目标分量 \(f_i\) \((i=1,...,n)\) 组成的向量 \(\overline{f}(\overline{X})=(f_1(\overline{X}), f_2(\overline{X}), ..., f_n(\overline{X}))\), 给定两个决策变量 \(\overline{X}_u, \overline{X}_v \isin U\): 当且仅当 \(\forall i \isin \{1, ..., n\}\) 时, 都有 \(f_i(\overline{X}_u) &lt; f_i(\overline{X}_v)\), 则 \(\overline{X}_u\) 支配 \(\overline{X}_v\). 当且仅当 \(\forall i \isin \{1, ..., n\}\) 时, 都有 \(f_i(\overline{X}_u) \leqslant f_i(\overline{X}_v)\), 且至少存在一个 \(j \isin \{1, ..., n\}\) 则 \(\overline{X}_u\) 弱支配 \(\overline{X}_v\). 当且仅当 \(\exists i \isin \{1, ..., n\}\), 使 \(f_i(\overline{X}_u) &lt; f_i(\overline{X}_v)\), 且 \(\exists j \isin \{1, ..., n\}\), 使 \(f_j(\overline{X}_u) &gt; f_j(\overline{X}_v)\), 则 \(\overline{X}_u\) 和 \(\overline{X}_v\) 互不支配. 若 \(\overline{X}_u\) 为 Pareto 最优解, 则不存在 \(\overline{X}_v \isin U\) 支配 \(\overline{X}_u\). 非支配排序 对于互不支配的染色体, 我们称这些染色体处于同一层. 则所有的染色体可以被划分到若干层. 非支配排序就是将染色体分层的排序算法, 分得的层称为第一级非支配层, 第二级非支配层...... 其中第一级非支配层处于 Pareto 前沿(Pareto Front). 非支配排序步骤如下: (1)设 i = 1; (2)对所有的 j = 1, 2, ..., N(i != j), 基于适应度函数比较个体 xi, xj 之间的支配关系; (3)若不存在任何一个个体 xj 优于 xi, 则标记 xi 为非支配个体; (4)令 j = j + 1, 转到(1), 重复直至找到所有非支配个体. 上述步骤将得到第一级非支配层, 过滤第一层所有个体后再次运行非支配排序, 即可得到第二级非支配层. 虚拟适应度(略) 为了算法更快地收敛, 虚拟适应度越大(层数越低)的个体应该有更多机会进入下一代. 但同时, 我们期望的 Pareto 最优解集应该是均匀分布的(而不是都挤在一个或几个点附近), 因此还要保证当前非支配层上的个体具有多样性。NSGA 中引入了基于拥挤策略的小生境(NIChe)技术, 对每个个体计算共享适应度. 带精英策略的非支配排序遗传算法(NSGA-II) NSGA-II 是 NSGA 的改进. NSGA-II 相对于 NSGA, 1. 提出了快速非支配排序算子, 将非支配排序从 \(O(MN^3)\) 优化到了 \(O(MN^2)\) (M为目标数, N 为种群大小); 2. 提出了拥挤距离算子; 3. 提出了精英策略选择算子. NSGA-II 流程图 快速支配排序算子 (1)对种群 \(P\) 中的每个个体 \(p\), 计算 \(p\) 在种群 \(P\) 中支配的个体数 \(n_p\), 并将这些被 \(p\) 支配的个体存入 \(S_p\) 中(每个个体都要比较一次, 共比较 \(\frac{N(N-1))}{2}\) 次, 每次比较要遍历 \(M\) 个目标, 时间复杂度 \(O(MN^2)\)); (2)\(layer = 1\); (3)找出所有 \(n_p = 0\) 的个体, 保存在数组 \(F_{layer}\) 中; (4)对于 \(F_{layer}\) 中的每个个体 \(p\) 的支配集 \(S_p\): 遍历 \(S_p\), 对 \(S_p\) 中每个个体 \(l\), 执行 \(n_l = n_l - 1\); (5)\(layer = layer + 1\), 重复(3). 拥挤距离算子 (1)对每个个体 \(p\) 令拥挤距离 \(d_p = 0, p = 1, 2, ..., N\) (2)对 \(M\) 个目标的每个目标函数 \(f_m\): 1)根据目标 \(f_m\) 的数值大小, 对每个个体排序; 2)对每个个体 \(p\), 计算 \(d_p = d_p + (f_m(p+1) - f_m(p-1))\) (其中第一个和最后一个个体拥挤距离设为无穷 \(d_1 = d_N = \infty\)) 选择时优先选择拥挤距离 \(d\) 大的. 精英策略选择算子 即保留父代优良个体直接进入子代, 以防止 Pareto 前沿的解丢失. 具体操作就可以直接把父代子代合并到一起进行非支配排序. st=>start: 开始 init=>operation: 随机生成第一代种群 eval=>operation: 计算每个个体的所有目标 gene=>operation: 选择, 交叉, 变异 merg=>operation: 父代与子代合并 fnds=>operation: 快速非支配排序 cong=>operation: 拥挤距离计算 selc=>operation: 选择优秀个体组成新的父代 iter=>condition: 运行代数大于最大代数? opt=>inputoutput: 输出 Pareto 前沿 e=>end: 结束 st->init->eval->fnds->cong->iter iter(no)->selc(right)->gene(right)->merg(right)->eval iter(yes)->opt->e{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>NSGA-II</tag>
        <tag>遗传算法</tag>
        <tag>多目标</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Deep Learning笔记 超参数调试 Batch归一化 Softmax]]></title>
    <url>%2Fposts%2F2106.html</url>
    <content type="text"><![CDATA[调试(Tuning) 深度学习要处理很多参数, 从学习速率 \(\alpha\) 到 Momentum 的参数 \(\beta\), 若使用 Adam 优化算法,还得处理 \(\beta_1\), \(\beta_2\) 和 \(\varepsilon\). 同时还得选择层数, 每一层隐藏单元的数量, mini-batch 大小, 甚至如果还要使用学习率衰减. 其中学习速率 \(\alpha\) 是最优先调试的超参数. mini-batch 大小与隐藏单元次之. 而 Momentum 的参数 \(\beta\) 通常使用默认值 0.9, Adam 的参数 \(\beta_1\), \(\beta_2\) 和 \(\varepsilon\) 通常不进行调试, 使用默认的 0.9, 0.999 和 \(10^{-8}\). 参数选择有以下一些方法: 1. 随机选择点. 例如现在有 \(\alpha\) 与 Adam 的 \(\varepsilon\) 两个超参数要调试. 在更早的机器学习算法中, 常见的是在网格中等距离取样. 现在更推荐随机选择. 在参数取值范围内随机选择若干点, 可以发现哪个超参数更重要, 影响更大. 由粗糙到精细的策略. 由1, 发现在某个点效果最好, 可以预测在该点附近效果也很好, 于是放大这块区域, 更密集地取值. 随机选择点时, 有些参数不适合均匀(在线性轴上)的随机选择. 例如 \(\alpha\), 我们希望其在对数轴上随机取点(0.0001, 0.001, 0.01, 0.1, 1), 我们可以 a = 10**(-4*np.random.rand()), 即可得到 \(a \isin [10^{-4}, 10^0]\). Batch 归一化(Batch Norm) 训练 Logistic 回归时, 归一化 X 可以加快学习过程. 现在我们希望对隐藏层的 A 行归一化. 吴恩达老师介绍的版本是归一化 Z, 也有学者认为应该归一化 A. 我们对每一层的z, a 做如下操作: \[ \mu = \frac{1}{m} \sum_i z^{(i)} \\ \sigma^2 = \frac{1}{m} \sum_i (z^{(i)} - \mu)^2 \\ z_{\text{norm}}^{(i)} = \frac{z^{(i)} - \mu}{\sqrt{\sigma^2 + \varepsilon}} \\ \widetilde{z}^{(i)} = \gamma z_{\text{norm}}^{(i)} + \beta \] (\(\varepsilon\)是为了防止分母为0.) \(z_{\text{norm}}\) 就是标准化的 \(z\), 平均值为0, 方差为1. 当希望均值, 方差不是0和1时, 计算 \(\widetilde{z}\). \(\gamma\) 与 \(\beta\) 的作用是随意设置 \(\widetilde{z}^{(i)}\) 的平均值. 当\(A = \sqrt{\sigma^2+\varepsilon}\) 且 \(B = \mu\) 时, \(\widetilde{z}^{(i)} = z^{(i)}\). \(\gamma\) 与 \(\beta\)是模型的学习参数, 梯度下降时会像更新神经网络的权重一样更新 \(\gamma\) 和 \(\beta\). 使用该方法时, 参数 w 和 b 中的 b 可以不设立, 毕竟 b 总是会被归一化减去. 于是参数只剩下了 \(w\), \(\beta\), \(\gamma\). Batch 归一化减少了输入值改变的问题, 它的确使这些值变得更稳定, 它减弱了前层参数的作用与后层参数的作用之间的联系, 它使得网络每层都可以自己学习, 稍稍独立于其它层, 有助于加速整个网络的学习. 另外, 每个 mini-batch 子数据集的均值和方差均有一些噪音, 而 Batch 归一化将 \(z\) 缩放到 \(\widetilde{z}\) 的过程也有噪音, 因此有轻微的正则化效果. 在测试时, 我们很可能只想测一个样本, 此时均值 \(\mu\) 和方差 \(\sigma\) 没有意义. 因此我们要使用估算的 \(\mu\) 和 \(\sigma\) 进行测试. 估算方法很多, 通常运用指数加权平均来追踪在训练过程中的 \(\mu\) 和 \(\sigma\). 还可以用指数加权平均. Softmax 回归 类似 Logistic 回归, 但 Softmax 回归能识别多个分类. 因此 \(\hat{y}\) 是 C×1 维的向量, 给出 C 个分类的概率,所有概率加起来应该为1. 在神经网络的最后一层, 我们像往常一样计算各层的线性部分, 当计算了 \(z^{[L]} = W^{[L]}a^{[L-1]}+b^{[L]}\) 之后, 使用 Softmax 激活函数. \[ a^{[L]}_i = \frac{e^{z^{[L]}_i}}{\sum_{j=1}^{4} e^{z^{[L]}_i}} \] Softmax 分类中, 一般使用的损失函数及反向传播的导数是 \[ L(\hat{y}, y) = -\sum_{j=1}^{n}y_j \text{log } \hat{y}_j \\ J(w^{[1]}, b^{[1]}, ...) = \frac{1}{m} \sum_{i=1}^m L(\hat{y}^{(i)}, y^{(i)}) \\ \frac{\partial J}{\partial z^{[L]}} = \hat{y} - y \] Softmax 给出的是每个分类的概率. 而对应的 Hardmax 则是将最大的元素输出为 1, 其余元素置 0.]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Batch Norm</tag>
        <tag>Softmax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Deep Learning笔记 优化算法]]></title>
    <url>%2Fposts%2F58457.html</url>
    <content type="text"><![CDATA[Mini-batch 梯度下降 将 \(X = [x^{(1)}, x^{(2)}, x^{(3)}, ..., x^{(m)}]\) 矩阵所有 \(m\) 个样本划分为 \(t\) 个子训练集, 每个子训练集称为 \(x^{\{i\}}\), 每个子训练集内样本个数均相同(若每个子训练集有1000个样本, 则 \(x^{\{1\}} = [x^{(1)}, x^{(2)}, ..., x^{(1000)}]\), 维度 \((n_x,1000)\)). 若m不能被子训练集样本数整除, 则最后一个子训练集样本可以小于其他子训练集样本数. \(Y\) 亦然. 训练时, 每次迭代仅对一个子训练集进行梯度下降: \[ \begin{aligned} &amp; \text{Repeat} :\\ &amp; \qquad \text{For } i = 1, 2, ..., t: \\ &amp; \qquad \qquad \text{Forward Prop On } X^{\{i\}} \\ &amp; \qquad \qquad \text{Compute Cost } J^{\{i\}} \\ &amp; \qquad \qquad \text{Back Prop using } X^{\{i\}}, Y^{\{i\}}\\ &amp; \qquad \qquad \text{Update } w, b \end{aligned} \] 使用 batch 梯度下降法时, 每次迭代都遍历整个训练集, 预期每次迭代成本都会下降, 但若使用 mini-batch 梯度下降法, 若对成本函数作图, 并不是每次迭代都下降, 噪声较大, 但整体上走势还是朝下的. 若样本集较小(小于2000), 无需使用 mini-batch; 否则一般的 mini-batch 大小为 64~512, 通常为 2 的整数次方. 指数加权平均数(Exponentially Weighted Averages) 不是个具体的优化方法, 但是是下面的优化方法的数学基础. \[ v_t = \beta v_{t-1} + (1 - \beta)\theta_t, \qquad \beta \isin[0,1) \] \(\beta\) 越大, 画得曲线越平滑, 但画得图像会更为偏右. 为了让加权平均数运算更准确, 我们还需要偏差修正(Bias Correction). 由于我们默认 \(v_0 = 0\), 因此当t较小时, \(v_t\) 会比 \(\theta_t\) 小很多. 为解决这一问题, 得到更准确的估测, 我们不使用 \(v_t\), 而使用 \(\frac{v_t}{1-\beta^t}\). 动量梯度下降法(Gradient Descent With Momentum) 当你的成本函数图像不够圆润, 例如是个很扁的椭圆, 使得梯度下降在y轴很快而在x轴很慢, 此时增加学习率也不是,减少学习率也不是. 动量梯度下降法使用指数加权平均数: \[ \begin{aligned} v_{dW} &amp; = \beta v_{dW} + (1 - \beta)dW \\ v_{db} &amp; = \beta v_{db} + (1 - \beta)db \\ W &amp; = W - \alpha v_{dW} \\ b &amp; = b - \alpha v_{db} \end{aligned} \] 以此减缓梯度下降摆动幅度. RMSprop 同 Momentum, 能够很好的消除摆动. \[ \begin{aligned} S_{dW} &amp; = \beta S_{dW} + (1 - \beta)(dW)^2 \\ S_{db} &amp; = \beta S_{db} + (1 - \beta)(db)^2 \\ W &amp; = W - \alpha \frac{dW}{\sqrt{S_{dW}}} \\ b &amp; = b - \alpha \frac{db}{\sqrt{S_{db}}} \end{aligned} \] Adam 优化算法 RMSprop 与 Adam 是少有的经受住人们考验的两种算法. Adam 的本质就是将 Momentum 和 RMSprop 结合在一起. 使用该算法首先需要初始化: \[ v_{dW} = 0, S_{dW} = 0, v_{db} = 0, S_{db} = 0. \] 在第t次迭代中,梯度下降后: \[ \begin{aligned} v_{dW} &amp; = \beta_1 v_{dW} + (1 - \beta_1)dW \\ v_{db} &amp; = \beta_1 v_{db} + (1 - \beta_1)db \\ S_{dW} &amp; = \beta_2 S_{dW} + (1 - \beta_2)(dW)^2 \\ S_{db} &amp; = \beta_2 S_{db} + (1 - \beta_2)(db)^2 \\ v_{dW}^{\text{corrected}} &amp; = \frac{v_{dW}}{1-\beta_1^t}, \quad v_{db}^{\text{corrected}} = \frac{v_{db}}{1-\beta_1^t} \\ S_{dW}^{\text{corrected}} &amp; = \frac{S_{dW}}{1-\beta_2^t}, \quad S_{db}^{\text{corrected}} = \frac{S_{db}}{1-\beta_2^t} \\ W &amp; = W - \alpha\frac{v_{dW}^{\text{corrected}}}{\sqrt{S_{dW}^{\text{corrected}}}+\varepsilon} \\ b &amp; = b - \alpha\frac{v_{db}^{\text{corrected}}}{\sqrt{S_{db}^{\text{corrected}}}+\varepsilon} \end{aligned} \] 最后两个式子的 \(+ \varepsilon\) 是为了防止分母为0, 上面 RMSprop 的分母实践中一般也加上, \(\varepsilon\) 通常取 \(10^{-8}\). Adam 算法结合了 Momentum 和 RMSprop 梯度下降法, 并且是一种极其常用的学习算法, 被证明能有效适用于不同神经网络. 适用于广泛的结构. 学习率衰减(Learning Rate Decay) 如果使用固定的学习率 \(\alpha\), 在使用 mini-batch 时在最后的迭代过程中会有噪音, 不会精确收敛, 最终一直在附近摆动. 因此我们希望在训练后期 \(\alpha\) 不断减小. 以下为几个常见的方法: 法一: \[ \alpha = \frac{1}{1+decay\_rate*\text{epoch\_num}} \alpha_0 \] 其中 \(\alpha_0\) 为初始学习率; \(\text{epoch\_num}\) 为当前迭代的代数; \(decay\_rate\) 是衰减率, 一个需要调整的超参数. 法二: \[ \alpha = 0.95^{\text{epoch\_num}} \alpha_0 \] 其中 0.95 自然也能是一些其他的小于 1 的数字. 法三: \[ \alpha = \frac{k}{\sqrt{\text{epoch\_num}}} \alpha_0 \] 法四: 离散下降(discrete stair cease), 过一阵子学习率减半, 过一会又减半. 法五: 手动衰减, 感觉慢了就调快点, 感觉快了就调慢点. 局部最优问题(Local Optima) 人们经常担心算法困在局部最优点, 而事实上算法更经常被困在鞍点, 尤其是在高维空间中. 成熟的优化算法如 Adam 算法，能够加快速度，让你尽早往下走出平稳段.]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Gradient Descent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Deep Learning笔记 正则化与梯度相关]]></title>
    <url>%2Fposts%2F41302.html</url>
    <content type="text"><![CDATA[训练集、验证集、测试集(Train, Dev, Test Sets) 当数据量小的时候, 70% 训练, 30% 测试；或 60% 训练、20% 验证、20%测试. 当我们有大于100万条数据时, 测试集验证集各取1万条即可, 足以评估单个分类器. 确保验证集和测试集的数据来自同一分布. 如果不需要无偏估计, 可以不设置测试集. 当没设立测试集的时候, 验证集通常被人们称为测试集. 偏差、方差(Bias, Variance) 高偏差(high bias)称为&quot;欠拟合&quot;(underfitting), 练集误差与验证集误差都高. 高方差(high variance)称为过拟合(overfitting), 训练集误差很低而验证集误差很高. 解决方法是正则化或准备更多的数据. 正则化(Regularization) 逻辑回归中的L1正则化, L2正则化 对于L1正则化, 为代价函数添加L1范数: \[ J(w, b) = \frac{1}{m} \sum^{m}_{i=1} \mathcal{L}(a^{(i)}, y^{(i)}) + \frac{\lambda}{2m} ||w||_1 \] 其中 \[ ||w||_1 = \sum^{n_x}_{j=1} |w_j| \] 使用L1正则化, w最终会是稀疏的(w中含很多0), 有利于压缩模型, 但也没有降低太多内存, 所以不能将压缩作为L1正则化的目的. 通常我们使用L2正则化. 对于L2正则化, 为代价函数添加L2范数: \[ J(w, b) = \frac{1}{m} \sum^{m}_{i=1} \mathcal{L}(a^{(i)}, y^{(i)}) + \frac{\lambda}{2m} ||w||_2^2 \] 其中 \[ ||w||^2_2 = \sum^{n_x}_{j=1} w_j^2 = w^Tw \] 尽管 \(b\) 也是参数, 但我们没有必要添加 \(\frac{\lambda}{2m}b^2\) 项, 因为 \(w\) 几乎涵盖了所有参数, 而 \(b\) 只是众多参数中的一个, 可以忽略不计(当然加上也没问题). 神经网络中的L2正则化 弗罗贝尼乌斯范数(相当于矩阵的L2范数): \[ ||w^{[l]}||_F^2 = \sum_{i=1}^{n^{[l-1]}} \sum_{j=1}^{n^{[l]}} (w_{ij}^{[l]})^2 \] 则 \[ J(w, b) = \frac{1}{m} \sum^{m}_{i=1} \mathcal{L}(\hat{y}^{(i)}, y^{(i)}) + \frac{\lambda}{2m} \sum_{l=1}^{L}||w||_F^2 \] 则在反向传播时, \[ \begin{aligned} dw^{[l]} &amp; = (\text{from backprop}) + \frac{\lambda}{m}w^{[l]} \\ w^{[l]} &amp; = w^{[l]} -\alpha dw^{[l]} \\ \end{aligned} \] 正则项说明, 无论 \(w^{[l]}\) 是什么, 我们都试图使之更小(趋于0). 则计算得的 \(z^{[l]} = w^{[l]}a^{[l-1]} + b^{[l]}\)此时也更小, \(z^{[l]}\) 更容易(以tanh例)落在激活函数 \(g(z^{[l]})\) 中间那一段接近线性的部分, 以达到简化网络的目的(线性的激活函数使得无论多少层的网络, 效果都和一层一样). 随机失活(Dropout)正则化 对每一轮的训练, Dropout 遍历网络的每一层, 设置神经网络中每一层每个节点的失活概率, 被随机选中失活的节点临时被消除, 不参与本轮的训练, 于是得到一个更小的网络. 最常用的为反向随机失活(Inverted Dropout). 该方法在向前传播时, 根据随机失活的概率 (例如0.2), 将每一层(例如 \(l\) 层)的 \(a^{[l]}\) 矩阵(a=g(z))中被选中失活的元素置为0. 则该层的 \(a^{[l]}\) 相当于少了 20% 的元素. 为了不影响下一层 \(z^{[l+1]}\) 的期望值, 我们需要 \(a^{[l]}\) /= 0.8 以修正权重. 由于训练时的 &quot;\(a^{[l]}\) /= 0.8&quot; 修复了权重, 在测试阶段无需使用 Dropout. Dropout 不能与梯度检验同时使用, 因为 Dropout 在梯度下降上的代价函数J难以计算. 其他正则化 数据扩增: 比如训练分类猫咪的图片, 将图片左右翻转、旋转一个小角度、稍微变形处理等, 可以人工合成数据. Early Stopping: 运行梯度下降时, 我们可以绘制训练误差, 当验证集误差不降反增的时候, 停止训练. 缺点是可能导致代价J值不够小, 却又没解决继续训练可能导致的过拟合问题. 归一化(Normalizing) 输入的归一化有两个步骤: 均值调整为0, 方差归一化. 归一化直观的理解就是使得代价函数更圆, 更容易优化代价函数. 梯度消失/爆炸(Vanishing / Exploding Gradients) 为了方便理解，假设使用了线性激活函数 g(z)=z , 且 \[ W=W^{[L-1]}=...=W^{[2]}=W^{[1]} \] 则 \[ \begin{aligned} \hat{y} &amp; = W^{[L]}W^{[L-1]}...W^{[2]}W^{[1]}x \\ &amp; = W^{[L]}W^{L-1}x \end{aligned} \] 可知若 \(W\) 中有元素权重为 1.5 , 则最终得到 \(1.5^{L-1}\) , 若层数很深, 计算得 \(\hat{y}\) 也很大; 同理若权重为 0.5 , 进行 \(L-1\) 次幂运算后值会很小. 这便是梯度爆炸与梯度消失. 有效的解决方案: 由于 \(z=w_1x_1+w_2x_2+...+w_nx_n\) (忽略 \(b\) ), 为了预防 \(z\) 太大或太小, 则\(n\) 越大时, 期望 \(w_i\) 越小, 则在随机(0~1)初始化 \(W\) 时, 我们对其乘上一个小于1的倍数, 使之更小. 对于Tanh, 权重乘上 \(\sqrt{\frac{1}{n^{[l-1]}}}\), 或者 \(\sqrt{\frac{2}{n^{[l-1]}+n^{[l]}}}\) 对于Relu, 权重乘上 \(\sqrt{\frac{2}{n^{[l-1]}}}\) 梯度检验 在反向传播的时候, 如果怕自己 \(d\theta[i] = \frac{\partial J}{\partial \theta_i}\) 等算错, 可以用导数的定义, 计算 \[ d\theta_{approx}[i] = \frac{J(\theta_1, \theta_2, ..., \theta_i + \varepsilon, ...) - J(\theta_1, \theta_2, ..., \theta_i - \varepsilon, ...)}{2\varepsilon} \] 然后根据两者误差估计自己是否算错. 该方法仅用来调试, 且不能同 Dropout 同时使用.]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Gradient Descent</tag>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Deep Learning笔记 神经网络一些要点]]></title>
    <url>%2Fposts%2F12524.html</url>
    <content type="text"><![CDATA[[TOC] 激活函数 Sigmoid 不怎么用了. \(a = g(z) = \sigma(z) = \frac{1}{1+e^{-z}} \\ g&#39;(z) = a(1-a)\) Tanh 比Sigmoid好. 因为其值域为(-1, 1), 计算得a的平均值靠近0, 更好的centers the data(不知道怎么翻译比较好), 有利于下一层的计算. \(a = g(z) = tanh(z) = \frac{e^{z}-e^{-z}}{e^{z}+e^{-z}} \\ g&#39;(z) = 1 - (tanh(z))^2\) ReLU(Rectified Linear Unit) 收敛快. \(a = g(z) = max(0, z) \\ g&#39;(z) = \begin{cases} 0 &amp;\text{if } z&lt;0 \\ 1 &amp;\text{if } z&gt;0 \\ undefined &amp;\text{if } z=0 \end{cases}\) Leaky ReLU 比ReLU更优, 但不怎么用? \(a = g(z) = max(0.01z, z) \\ g&#39;(z) = \begin{cases} 0.01 &amp;\text{if } z&lt;0 \\ 1 &amp;\text{if } z&gt;0 \\ undefined &amp;\text{if } z=0 \end{cases}\) 为什么需要一个非线性的激活函数(Non-linear Activation Function) 因为如果是线性的, 即直接令 \(A = g(Z) = Z\) 那么对于每一层，都有: \[ a^{[i]} = z^{[i]} = w^{[i]}a^{[i-1]} + b^{[i]} \tag{*} \] 则对于第 \(i+1\) 层, 将 \((*)\) 带入: \[ \begin{aligned} a^{[i+1]} &amp; = z^{[i+1]} \\ &amp; = w^{[i+1]}a^{[i]} + b^{[i+1]} \\ &amp; = w^{[i+1]}(w^{[i]}a^{[i-1]} + b^{[i]} + b^{[i+1]} \\ &amp; = (w^{[i+1]}w^{[i]})a^{[i-1]} + (w^{[i+1]}b^{[i]}+b^{[i+1]}) \\ &amp; = w&#39;a^{[i-1]} + b&#39; \end{aligned} \] 即最终的模型相当于一个标准的, 没有隐藏层的逻辑回归. 即无论你的模型有多少层，最终效果也相当于只有一层。 如果要用线性激活函数, 一般也只用在回归问题的输出层(预测一些结果为实数的值), 隐藏层还是用 tanh, ReLU 等. 为什么神经网络要随机初始化参数(而逻辑回归不须要) 如果神经网络不随机初始化, 比如 w, b 都初始化为0, 则每次对隐藏层反向传播的时候计算得的导数 \(dz^{[i]}_1\) , \(dz^{[i]}_2\) , \(dz^{[i]}_3\) 等相同, \(dw\) 也是, 每个隐藏层单元都计算着一模一样的式子(不过b不受这种Symmetry Breaking Problem影响, 可以初始化为0). 而对于逻辑回归, 它没有隐藏层, 其导数取决于x, 问题不大. 随机初始化时参数范围可以设置在0~0.01(对于 sigmoid 和 tanh 而言), 如果参数过大(比如w=100) 在 sigmoid 或 tanh 的函数图像上可以看到参数十分靠右，导致导数趋于零, 梯度趋于零, 导致收敛很慢. 向前向后传播 向前传播: \[ \begin{aligned} &amp; \text{Input: } a^{[l-1]} \\ &amp; \text{Output: } a^{[l]} , \text{Cache: } z^{[l]} \\ &amp; z^{[l]} = W^{[l]}a^{[l-1]} + b^{[l]} &amp;&amp; Z^{[l]} = W^{[l]}A^{[l-1]} + b^{[l]} \\ &amp; a^{[l]} = g^{[l]}(z^{[l]}) &amp;&amp; A^{[l]} = g^{[l]}(Z^{[l]}) \\ \end{aligned} \] 向后传播: \[ \begin{aligned} &amp; \text{Input: } da^{[l]} \\ &amp; \text{Output: } da^{[l-1]} , dW^{[l]} , db^{[l]} \\ &amp; dz^{[l]} = da^{[l]}*g^{[l]&#39;}(z^{[l]}) &amp;&amp; dZ^{[l]} = dA^{[l]}*g^{[l]&#39;}(Z^{[l]}) \\ &amp; dW^{[l]} = dz^{[l]}a^{[l-1]} &amp;&amp; dW^{[l]} = \frac{1}{m} dZ^{[l]}A^{[l-1]^T} \\ &amp; db^{[l]} = dz^{[l]} &amp;&amp; db^{[l]} = \frac{1}{m} np.sum(dZ^{[l]}, axis=1, keepdims=True) \\ &amp; da^{[l-1]} = w^{[l]^T}dz^{[l]} &amp;&amp; dA^{[l-1]} = W^{[l]^T}dZ^{[l]} \end{aligned} \]]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript几何星空连线(鼠标跟随)完善]]></title>
    <url>%2Fposts%2F10178.html</url>
    <content type="text"><![CDATA[完善了一下星空连线背景效果. 添加了粒子的鼠标跟随的效果. 参考的类似功能的JS源码都处理压缩过, 没有换行缩进, 变量名都是a, b, c... 看着真累啊. 把两次遍历改成了一次遍历, 把鼠标所在的点 p0 与 points 数组 concat 到一起处理了. 舍弃了原来按时间间隔计算移动距离的方法, 直接每一帧移动一定距离. 优化了代码, 提高了些性能. 鼠标跟随的原理是, 当粒子靠近鼠标指针到一定距离区间内, 就每帧向鼠标靠近对应距离. 所以当粒子一边远离一边被吸引时在边界会有些许鬼畜. 点此访问演示DEMO 截图: 演示图片 源码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157//==========================================// File: background.js// Title: 星空连线(鼠标跟随)// Auther: XieNaoban// Version: v1.1// Note: 直接扔在&lt;body&gt;里//==========================================// 可调参数var BACKGROUND_COLOR = "rgba(0,43,54,1)"; // 背景色var POINT_NUM = 99; // 屏幕上点的数目var POINT_COLOR = "rgba(255,255,255,0.7)"; // 点的颜色var LINE_LENGTH = 10000; // 点之间连线长度(的平方)// 创建背景画布var cvs = document.createElement("canvas");cvs.width = window.innerWidth;cvs.height = window.innerHeight;cvs.style.cssText = "\ position:fixed;\ top:0px;\ left:0px;\ z-index:-1;\ opacity:1.0;\ ";document.body.appendChild(cvs);var ctx = cvs.getContext("2d");var startTime = new Date().getTime();//随机数函数function randomInt(min, max) &#123; return Math.floor((max - min + 1) * Math.random() + min);&#125;function randomFloat(min, max) &#123; return (max - min) * Math.random() + min;&#125;//构造点类function Point() &#123; this.x = randomFloat(0, cvs.width); this.y = randomFloat(0, cvs.height); var speed = randomFloat(0.3, 1.4); var angle = randomFloat(0, 2 * Math.PI); this.dx = Math.sin(angle) * speed; this.dy = Math.cos(angle) * speed; this.r = 1.2; this.color = POINT_COLOR;&#125;Point.prototype.move = function () &#123; this.x += this.dx; if (this.x &lt; 0) &#123; this.x = 0; this.dx = -this.dx; &#125; else if (this.x &gt; cvs.width) &#123; this.x = cvs.width; this.dx = -this.dx; &#125; this.y += this.dy; if (this.y &lt; 0) &#123; this.y = 0; this.dy = -this.dy; &#125; else if (this.y &gt; cvs.height) &#123; this.y = cvs.height; this.dy = -this.dy; &#125;&#125;Point.prototype.draw = function () &#123; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI * 2); ctx.closePath(); ctx.fill();&#125;var points = [];function initPoints(num) &#123; for (var i = 0; i &lt; num; ++i) &#123; points.push(new Point()); &#125;&#125;var p0 = new Point(); //鼠标p0.dx = p0.dy = 0;var degree = 2.5;document.onmousemove = function (ev) &#123; p0.x = ev.clientX; p0.y = ev.clientY;&#125;document.onmousedown = function (ev) &#123; degree = 5.0; p0.x = ev.clientX; p0.y = ev.clientY;&#125;document.onmouseup = function (ev) &#123; degree = 2.5; p0.x = ev.clientX; p0.y = ev.clientY;&#125;window.onmouseout = function () &#123; p0.x = null; p0.y = null;&#125;function drawLine(p1, p2, deg) &#123; var dx = p1.x - p2.x; var dy = p1.y - p2.y; var dis2 = dx * dx + dy * dy; if (dis2 &lt; 2 * LINE_LENGTH) &#123; if (dis2 &gt; LINE_LENGTH) &#123; if (p1 === p0) &#123; p2.x += dx * 0.03; p2.y += dy * 0.03; &#125; else return; &#125; var t = (1.05 - dis2 / LINE_LENGTH) * 0.2 * deg; ctx.strokeStyle = "rgba(255,255,255," + t + ")"; ctx.beginPath(); ctx.lineWidth = 1.5; ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.closePath(); ctx.stroke(); &#125; return;&#125;//绘制每一帧function drawFrame() &#123; cvs.width = window.innerWidth; cvs.height = window.innerHeight; ctx.fillStyle = BACKGROUND_COLOR; ctx.fillRect(0, 0, cvs.width, cvs.height); var arr = (p0.x == null ? points : [p0].concat(points)); for (var i = 0; i &lt; arr.length; ++i) &#123; for (var j = i + 1; j &lt; arr.length; ++j) &#123; drawLine(arr[i], arr[j], 1.0); &#125; arr[i].draw(); arr[i].move(); &#125; window.requestAnimationFrame(drawFrame);&#125;initPoints(POINT_NUM);drawFrame();]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>造轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Deep Learning笔记 逻辑回归典型的训练过程]]></title>
    <url>%2Fposts%2F59595.html</url>
    <content type="text"><![CDATA[Deep Learning 用逻辑回归训练图片的典型步骤. 学习Coursera上吴恩达老师Deep Learning第一课程前两周的笔记. 1. 处理数据 1.1. 向量化(Vectorization) 将每张图片的高和宽和RGB展为向量, 最终X的shape为 (height*width*3, m) . 1.2. 特征归一化(Normalization) 对于一般数据，使用标准化(Standardization), z_i = (x_i - mean) / delta , mean 与 delta 代表X的均值和标准差. 最终特征处于[-1, 1]区间. 对于图片, 可直接使用Min-Max Scaling, 即将每个特征除以255(每个像素分为R, G, B, 范围在0~255)使得值处于[0, 1]. 2. 初始化参数 一般将 w 和 b 随机选择. 作业为了方便设为0了. 3. 梯度下降(Gradient descent) 根据 w , b 和训练集，来训练数据. 需要设定迭代次数与学习率. 以下为大循环(迭代次数)中内容: 3.1. 计算代价函数 对于\(x^{(i)} \in X\), 有 \[z^{(i)} = w^T x^{(i)} + b\] \[ a^{(i)} = \hat{y}^{(i)} = sigmoid(z^{(i)}) = \sigma (z^{(i)}) = \frac{1}{1 + e^{-z^{(i)}}} \] \[\mathcal{L}(a^{(i)}, y^{(i)}) = - y^{(i)} \log(a^{(i)}) - (1-y^{(i)} ) \log(1-a^{(i)})\] \[ A = (a^{(1)}, a^{(2)}, ... , a^{(m-1)}, a^{(m)}) = \sigma(w^TX+b) = \dfrac{1}{1+e^{-(w^TX+b)}} \] \[ J = -\dfrac{1}{m} \sum^{m}_{i=1} \mathcal{L}(a^{(i)}, y^{(i)}) = -\dfrac{1}{m} \sum^{m}_{i=1} (y^{(i)} log(a^{(i)}) + (1-y^{(i)}) log(1-a^{(i)})) \] 1234# 激活函数A = sigmoid(w.T.dot(X) + b)# 代价函数cost = -np.sum(Y * np.log(A) + (1-Y) * np.log(1 - A)) / m 3.2. 计算反向传播的梯度 即计算导数. &gt; 注: 此处 \(L(a, y)\) 即上面公式的 \(\mathcal{L}(a^{(i)}, y^{(i)})\) . 即 \(L(a, y) = -y \log (a) -(1-y) \log (1-a)\) . 以下公式都省略了上标. \[ \dfrac{\partial L}{\partial a} = \dfrac{\partial L(a, y)}{\partial a} = -\frac{y}{a} + \frac{1-y}{1-a} \] \[ \dfrac{da}{dz} = (\frac{1}{1 + e^{-z}})&#39; = \dfrac{e^{-z}}{(1+e^{-z})^2} = \dfrac{1}{1+e^{-z}} - \dfrac{1}{(1+e^{-z})^2} = a-a^2 = a · (1-a) \] \[ \dfrac{\partial L}{\partial z} = \dfrac{\partial L}{\partial a} \dfrac{da}{dz} = (-\dfrac{y}{a} + \dfrac{1-y}{1-a}) · a · (1-a) = a - y \] \[ \dfrac{\partial L}{\partial w} = \dfrac{\partial L}{\partial z} \dfrac{\partial z}{\partial w} = (a-y) · x \] \[ \dfrac{\partial L}{\partial b} = \dfrac{\partial L}{\partial z} \dfrac{\partial z}{\partial b} = a-y \] 根据 \(J = -\dfrac{1}{m} \sum L(a, y)\) 最终可得： \[ \dfrac{\partial J}{\partial w} = \dfrac{\partial J}{\partial a} \dfrac{\partial a}{\partial w} = \dfrac{1}{m} X(A-Y)^T \] \[\dfrac{\partial J}{\partial b} = \dfrac{1}{m} \sum^{m}_{i=1} (a^{(i)} - y^{(i)})\] 12dw = X.dot((A - Y).T) / mdb = np.sum(A - Y) / m 3.3. 更新 w , b 12w = w - learning_rate * dwb = b - learning_rate * db 4. 预测测试集 使用训练出来的 w , b , 对测试集使用 y_pred = sigmoid(wx+b) , 计算得预测的概率, 对其取整, 例如大于0.7则判定为'是', 否则为'否'. Coursera作业是0.5就判定为'是', 那么使用内建函数四舍五入即可.]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Logistic Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu一些装机用到的指令]]></title>
    <url>%2Fposts%2F30914.html</url>
    <content type="text"><![CDATA[Ubuntu一些装机用到的指令 修改分辨率 1sudo gedit /etc/default/grub 找到以下行： 1234# The resolution used on graphical terminal # note that you can use only modes which your graphic card supports via VBE # you can see them in real GRUB with the command 'vbeinfo' # GRUB_GFXMODE=640×480 下面添加一行： 1GRUB_GFXMODE=1920×1080 #这里分辨率自行设置 然后保存返回终端： 1sudo update-grub 重新启动ubuntu使之生效。 固件刷入 1sudo dpkg -i linux-xxx.deb 重启 修改更新源 在系统设置里，清华的源速度蛮快的。 小键盘开机启动 安装numlockx： 1sudo apt-get install numlockx 编辑： 1sudo gedit /usr/share/lightdm/lightdm.conf.d/50-unity-greeter.conf 在最后添加： 1greeter-setup-script=/usr/bin/numlockx on 设置root密码并进入root 12sudo passwd rootsu 安装SSR(Python) 打开一键安装脚本，按照里面的步骤来。在ssr start的时候会缺少chacha20的库，使用root安装即可。（提前把它指定的vi改为gedit） 12sudo cp ssr /usr/local/binsudo chmod a=rwx /usr/local/bin/ssr 安装git： 1sudo apt-get install git 安装tsocks： 12sudo apt-get install tsockssudo gedit /etc/tsocks.conf 添加: 123server = 127.0.0.1server_type = 5server_port = 1080 安装libsodium获得chacha20： 1234567# 使用root运行# 先cd到一个临时目录sudo apt-get install build-essentialwget https://github.com/jedisct1/libsodium/releases/download/1.0.16/libsodium-1.0.16.tar.gztar xf libsodium-1.0.16.tar.gz &amp;&amp; cd libsodium-1.0.16./configure &amp;&amp; make -j4 &amp;&amp; make installldconfig 然后sudo ssr install。 然后ssr config编辑配置文件。 最后ssr start。 运行 apt-get update 报错 错误信息： 12E: Problem executing scripts APT::Update::Post-Invoke-Success 'if /usr/bin/test -w /var/cache/app-info -a -e /usr/bin/appstreamcli; then appstreamcli refresh &gt; /dev/null; fi'E: Sub-process returned an error code 解决方案： 12345sudo pkill -KILL appstreamcliwget -P /tmp https://launchpad.net/ubuntu/+archive/primary/+files/appstream_0.9.4-1ubuntu1_amd64.deb https://launchpad.net/ubuntu/+archive/primary/+files/libappstream3_0.9.4-1ubuntu1_amd64.debsudo dpkg -i /tmp/appstream_0.9.4-1ubuntu1_amd64.deb /tmp/libappstream3_0.9.4-1ubuntu1_amd64.deb 卸载Amazon等Web Apps 要卸载干净，不然装Unity Tweak Tool的时候又会回来 12sudo apt-get purge unity-webapps-commonsudo apt-get autoremove 安装deb软件时被替换成Amazon 1sudo apt-get install -f 安装Unity Tweak Tool 123sudo add-apt-repository ppa:freyja-dev/unity-tweak-tool-dailysudo apt-get updatesudo apt-get install unity-tweak-tool 切换Python版本 1234sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 2sudo update-alternatives --config python Flatabulous主题与Numix图标 123sudo add-apt-repository ppa:noobslab/themessudo apt-get updatesudo apt-get install flatabulous-theme 123sudo add-apt-repository ppa:numix/ppasudo apt-get updatesudo apt-get install numix-icon-theme numix-icon-theme-circle Java配置 sudo gedit /etc/profile里添加： 12345export JAVA_HOME=/usr/lib/jdk/jdk1.8.0_161export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JRE_HOME/bin:$PATH 123456sudo update-alternatives --install /usr/bin/java java /usr/lib/jdk/jdk1.8.0_161/bin/java 300sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jdk/jdk1.8.0_161/bin/javac 300sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jdk/jdk1.8.0_161/bin/jar 300 sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jdk/jdk1.8.0_161/bin/javah 300 sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jdk/jdk1.8.0_161/bin/javap 300]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>日常配环境</tag>
        <tag>快乐背指令</tag>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Machine Learning Week4,5 - 神经网络(Neural Networks)]]></title>
    <url>%2Fposts%2F1115.html</url>
    <content type="text"><![CDATA[概念与表述 线性回归与逻辑回归的缺点：特征太多的时候计算负荷太大。 神经网络模型是许多逻辑单元按照不同层级组织起来的网络，每一层的输出变量都是下一层的输入变量。 直观理解 神经网络的单层神经元的计算可以用来表示逻辑运算，比如AND、OR。 如果用多层的话就可以组成功能复杂的神经网络。 多类分类 代价函数 逻辑回归的代价函数： 神经网络代价函数：（\(h_{\theta}(x)\)为K维度的向量，因为神经网络中可以输出很多变量。训练集中的因变量也是K维度） 反向传播算法 预测结果时我们正向传播：从第一层正向一层层传播，直到最后一层\(h_{\theta}(x)\) 。 计算代价函数的偏导数时，从最后一层的误差算起，一层层反向求出各层误差，直到倒数第二层。设误差为\(\delta\) ： \(\delta^{(n)}=a^{(n)}-y\) \(\delta^{(n-1)}=(\theta^{(n-1)})^{T}\delta^{(n)}.*g&#39;(z^{(n-1)})\) \(...\) \(\delta^{(2)}=(\theta^{(2)})^{T}\delta^{(3)}.*g&#39;(z^{(2)})\) 于是偏导数的表达式即为：$ J()=a_{ij}^{(l)}_{i}^{l+1}$ 。 l代表目前所计算的是第几层。 j代表目前计算层中的激活单元（神经元）的下标，也将是下一层的第j个输入变量的下标。 i代表下一层中误差单元的下标，是受到权重矩阵中第i行影响的下一层中的误差单元的下标。 步骤总结 参数的随机初始化 利用正向传播方法计算所有的hθ(x) 编写计算代价函数J的代码 利用反向传播方法计算所有偏导数 利用数值检验方法检验这些偏导数 使用优化算法来最小化代价函数]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现几何星空]]></title>
    <url>%2Fposts%2F38878.html</url>
    <content type="text"><![CDATA[ACM忙完啦，最近想给自己的xienaoban.github.io做个博客网页，刚好没学过html之类的东西，就从零开始一边学一边做。之前一直对html5做的各种特效很感兴趣，就从网页背景开始写起吧。 曾经看到过别人的博客的背景有种特效，就是背景随机散布若干点不停移动，当两个点足够近的时候就会产生一条线连接两点，就像星座的连线一样；当点离鼠标很近的时候还会被吸引。于是自己也来实现个。 感觉js真的是个很神奇的语言，没有类，就把函数“假装”为类，并作为类似构造函数而存在，然后用prototype添加成员函数。看上去还真像那么回事，哈哈。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//==========================================// File: background.js// Title: 几何星空背景// Auther: XieNaoban// Version: v0.9//==========================================//创建背景画布var cvs = document.createElement("canvas");cvs.width = window.innerWidth;cvs.height = window.innerHeight;cvs.style.cssText="\ position:fixed;\ top:0px;\ left:0px;\ z-index:-1;\ opacity:1.0;\ ";document.body.appendChild(cvs);var ctx = cvs.getContext("2d");var startTime = new Date().getTime();//随机数函数function randomInt(min,max) &#123; return Math.floor((max-min+1)*Math.random()+min);&#125;function randomFloat(min,max) &#123; return (max-min)*Math.random()+min;&#125;//构造点类function Point() &#123; this.x = randomFloat(0,cvs.width); this.y = randomFloat(0,cvs.height); var maxD = 0.08, minD = 0.01; this.speed = randomFloat(minD,maxD); this.angle = randomFloat(0,2*Math.PI); this.r = 1; var grey = (this.r*30+200); this.color = "rgba("+grey+","+grey+","+grey+",1)";&#125;Point.prototype.move = function(dif) &#123; var dx = Math.sin(this.angle)*this.speed; var dy = Math.cos(this.angle)*this.speed; this.x += dx*dif; if (this.x&lt;0) &#123; this.x=0; this.angle=2*Math.PI-this.angle; &#125; else if (this.x&gt;cvs.width)&#123; this.x=cvs.width; this.angle=2*Math.PI-this.angle; &#125; this.y += dy*dif; if (this.y&lt;0) &#123; this.y=0; this.angle=Math.PI-this.angle; &#125; else if (this.y&gt;cvs.height)&#123; this.y=cvs.height; this.angle=Math.PI-this.angle; &#125;&#125;Point.prototype.draw = function() &#123; ctx.fillStyle = this.color; ctx.beginPath(); ctx.arc(this.x,this.y,this.r,0,Math.PI*2); ctx.closePath(); ctx.fill();&#125;//绘制每一帧var points = [];function initPoints(num) &#123; for (var i = 0; i&lt;num; ++i) &#123; points.push(new Point()); &#125;&#125;var p0 = new Point();var degree=5.0;document.onmousemove = function(ev) &#123; p0.x = ev.clientX; p0.y = ev.clientY;&#125;document.onmousedown = function(ev) &#123; degree = 10.0; p0.x = ev.clientX; p0.y = ev.clientY;&#125;document.onmouseup = function(ev) &#123; degree = 5.0; p0.x = ev.clientX; p0.y = ev.clientY;&#125;function drawLine(p1,p2,d) &#123; var dis = (p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y); var t = 100/dis; t = Math.min(t,0.4); if(t&lt;0.01) return false; t = Math.min(1,t*d); ctx.strokeStyle = "rgba(255,250,250,"+ t +")"; ctx.beginPath(); ctx.lineWidth=1; ctx.moveTo(p1.x,p1.y); ctx.lineTo(p2.x,p2.y); ctx.closePath(); ctx.stroke(); return true;&#125;function drawFrame() &#123; cvs.width = window.innerWidth; cvs.height = window.innerHeight; ctx.fillStyle = "rgba(0,43,54,1)"; ctx.fillRect(0,0,cvs.width,cvs.height); var endTime = new Date().getTime(); var dif = endTime-startTime; startTime = endTime; for(var i = 0; i&lt;points.length; ++i) &#123; for(var j = i+1; j&lt;points.length; ++j) &#123; var p1 = points[i], p2 = points[j]; drawLine(p1,p2,3.0); &#125; &#125; for(var i = 0; i&lt;points.length; ++i) &#123; var p = points[i]; drawLine(p0,p,degree); p.draw(); p.move(dif); &#125; window.requestAnimationFrame(drawFrame);&#125;initPoints(70);drawFrame(); 没有去实现那个鼠标跟随，因为感觉我以后应该会自己想一个原创的更好玩的特效，这个就练练手好了。不过实现效果还是蛮炫酷的很满意啊，就是当最大化窗口就会显得稀疏，窗口小了看着太密。 还有个问题就是cpu占用太高了。。。每一帧要渲染70个点、判断\(70*70=490\)条线（以及70个sin、cos可以优化为dx、dy）。。。果然以后必须得换个背景。。。（或者减少点并放大整个图形倒也不错）。 还有个八(te)哥(xing)，就是切换到别的页面后不是本页面会停止渲染嘛，过半分钟再切回来会发现所有点挤在四个角落。原因是我是按照时间差来定下一帧每个点的位置的，当下一帧与当前帧的时间差太大的时候，每个点的移动距离都跑到屏幕外面了，于是被强制拉回屏幕的边缘。（感觉我这个实现方法会导致动画在低配电脑上看着很卡）。]]></content>
      <tags>
        <tag>JavaScript</tag>
        <tag>造轮子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU2242 - 考研路茫茫——空调教室 (双连通分量)]]></title>
    <url>%2Fposts%2F52996.html</url>
    <content type="text"><![CDATA[Problem Description 众所周知，HDU的考研教室是没有空调的，于是就苦了不少不去图书馆的考研仔们。Lele也是其中一个。而某教室旁边又摆着两个未装上的空调，更是引起人们无限YY。 一个炎热的下午，Lele照例在教室睡觉的时候，竟然做起了空调教室的美梦。 Lele梦到学校某天终于大发慈悲给某个教室安上了一个空调。而且建造了了M条通气管道，让整个教学楼的全部教室都直接或间接和空调教室连通上，构成了教室群，于是，全部教室都能吹到空调了。 不仅仅这样，学校发现教室人数越来越多，单单一个空调已经不能满足大家的需求。于是，学校决定封闭掉一条通气管道，把全部教室分成两个连通的教室群，再在那个没有空调的教室群里添置一个空调。 当然，为了让效果更好，学校想让这两个教室群里的学生人数尽量平衡。于是学校找到了你，问你封闭哪条通气管道，使得两个教室群的人数尽量平衡，并且输出人数差值的绝对值。 Input 本题目包含多组数据，请处理到文件结束。 每组测试第一行包含两个整数N和M(0&lt;N&lt;=10000,0&lt;M&lt;20000)。其中N表示教室的数目(教室编号从0到N-1)，M表示通气管道的数目。 第二行有N个整数Vi(0&lt;=Vi&lt;=1000)，分别代表每个教室的人数。 接下来有M行，每行两个整数Ai，Bi(0&lt;=Ai,Bi&lt;N)，表示教室Ai和教室Bi之间建了一个通气管道。 Output 对于每组数据，请在一行里面输出所求的差值。 如果不管封闭哪条管道都不能把教室分成两个教室群，就输出&quot;impossible&quot;。 Sample Input 123456789104 31 1 1 10 11 22 34 31 2 3 50 11 22 3 Sample Output 1201 Key1 边的双连通分量。首先是求分量，然后缩点。然后简单的树形DP即可。 要点是，它的图可以有重边。被坑了好久。 Code1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;set&gt;const int Maxn = 10000 + 23;using namespace std;class CutEdge &#123;private: int N; int clk, pre[Maxn]; int DFS(int u, int f) &#123; int lowu = pre[u] = ++clk; for (auto e = G[u].begin(); e != G[u].end(); ++e) &#123; int v = *e; if (!pre[v]) &#123; int lowv = DFS(v, u); lowu = min(lowu, lowv); if (lowv &gt; pre[u]) &#123; Cut[u].insert(v); Cut[v].insert(u); &#125; &#125; else if (pre[u] &gt; pre[v]) &#123; int cnt = 0; //重复边的处理 for (const auto &amp;e : G[u]) if (e == v) ++cnt; if (cnt &gt; 1 || v != f) &#123; lowu = min(lowu, pre[v]); &#125; &#125; &#125; return lowu; &#125; //求边双联通部分 void DFS2(int u, int id) &#123; ID[u] = id; for (const auto &amp;v : G[u]) if (!ID[v]) &#123; if (Cut[u].count(v)) &#123; ++Num; G2[id].push_back(Num); G2[Num].push_back(id); DFS2(v, Num); &#125; else DFS2(v, id); &#125; &#125;public: vector&lt;int&gt; G[Maxn]; set&lt;int&gt; Cut[Maxn]; //求边双联通部分 vector&lt;int&gt; G2[Maxn]; //缩点后的图（以ID为结点） int ID[Maxn]; //每个点所在的子图 int Num; //ID个数 void Clear(int n) &#123; N = n; memset(ID, 0, sizeof(ID)); memset(pre, 0, sizeof(pre)); for (int i = 1; i &lt;= N; ++i) &#123; G[i].clear(); G2[i].clear(); Cut[i].clear(); &#125; clk = 0; Num = 1; &#125; void AddEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; void Find() &#123; for (int i = 1; i &lt;= N; ++i) if (!pre[i]) DFS(i, -1); &#125; //求边双联通部分 int BCC() &#123; DFS2(1, Num); return Num; &#125;&#125;;int N, M;int V[Maxn];int V2[Maxn];int DP[Maxn];bool vis[Maxn];CutEdge C;int DFS(int u) &#123; vis[u] = true; DP[u] = V2[u]; for (const auto &amp;v : C.G2[u]) &#123; if (!vis[v]) DP[u] += DFS(v); &#125; return DP[u];&#125;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; N &gt;&gt; M) &#123; memset(V2, 0, sizeof(V2)); memset(vis, 0, sizeof(vis)); memset(DP, 0, sizeof(DP)); C.Clear(N); for (int i = 1; i &lt;= N; ++i) cin &gt;&gt; V[i]; int u, v; for (int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; C.AddEdge(++u, ++v); &#125; C.Find(); C.BCC(); if (C.Num == 1) &#123; cout &lt;&lt; "impossible\n"; continue; &#125; int sum = 0; for (int i = 1; i &lt;= N; ++i) &#123; sum += V[i]; V2[C.ID[i]] += V[i]; &#125; DFS(1); int res = sum; for (int i = 1; i &lt;= C.Num; ++i) &#123; res = min(abs(sum - 2 * DP[i]), res); &#125; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125; Key2 可以的优化是，其实在第一个DFS的时候，由于知道了桥的位置，可以在DFS的时候直接求出v以及v的子节点的和。那么在找到桥{u, v}的时候就直接顺便DP了。 Code2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;set&gt;const int Maxn = 10000+23;using namespace std;int N, M;int V[Maxn];int res,sum;class BCC &#123;private: int N; int clk, pre[Maxn]; int DFS(int u, int f) &#123; int &amp;lowu = ID[u]; lowu= pre[u] = ++clk; for (auto e = G[u].begin(); e != G[u].end(); ++e) &#123; int v = *e; if (!pre[v]) &#123; int lowv = DFS(v, u); lowu = min(lowu, lowv); if (lowv &gt; pre[u]) &#123; ++Num; res = min(abs(sum - 2 * V[v]), res); &#125; &#125; else if (pre[u] &gt; pre[v]) &#123; int cnt = 0; //重复边的处理 for (const auto &amp;e : G[u]) if (e == v) ++cnt; if (cnt &gt; 1 || v != f) &#123; lowu = min(lowu, pre[v]); &#125; &#125; /*else if (pre[u]&gt;pre[v] &amp;&amp; v != f) lowu = min(lowu, pre[v]);*/ &#125; if(f!=-1) V[f] += V[u]; return lowu; &#125;public: vector&lt;int&gt; G[Maxn]; int ID[Maxn]; int Num; void Clear(int n) &#123; N = n; memset(ID, 0, sizeof(ID)); memset(pre, 0, sizeof(pre)); for (int i = 1; i &lt;= N; ++i) &#123; G[i].clear(); &#125; clk = 0; Num = 1; &#125; void AddEdge(int u, int v) &#123; G[u].push_back(v); G[v].push_back(u); &#125; int Find() &#123; for (int i = 1; i &lt;= N; ++i) if (!pre[i]) DFS(i, -1); return Num; &#125;&#125;;BCC C;int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; N &gt;&gt; M) &#123; C.Clear(N); sum = 0; for (int i = 1; i &lt;= N; ++i) &#123; cin &gt;&gt; V[i]; sum += V[i]; &#125; int u, v; for (int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; C.AddEdge(++u, ++v); &#125; res = sum; if (C.Find() == 1) &#123; cout &lt;&lt; "impossible\n"; &#125; else cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDU3157 - Crazy Circuits 和 SGU176 - Flow construction (网络流)]]></title>
    <url>%2Fposts%2F6930.html</url>
    <content type="text"><![CDATA[两道有上下界有源汇最小流。 步骤之前写的笔记里有。但是原理。。。确实不太懂。 步骤： 1. 按照无源汇有上下界的最大流的做法找出可行流（但不要建立t-&gt;s）； 2. 添加t-&gt;s，流量上界INF； 3. 再次运行最大流，找出ss-&gt;st可行流； 4. 若ss不满载，则无可行流。反之，最小流为t-&gt;s的流量，每条边的流量为逆向边的流量（加上下界b）。 SGU176 - Flow construction 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127//下界网络流#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define INF 0x3f3f3f3f#define Maxn 200using namespace std;struct Edge &#123; int c, f, id; unsigned v, flip; Edge(unsigned v, int c, int f, unsigned flip, int id) :v(v), c(c), f(f), flip(flip), id(id) &#123;&#125;&#125;;class Dinic &#123;public: bool b[Maxn]; int a[Maxn]; unsigned p[Maxn], cur[Maxn], d[Maxn]; vector&lt;Edge&gt; G[Maxn]; unsigned s, t; void Init(unsigned n) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); &#125; void AddEdge(unsigned u, unsigned v, int c, int id) &#123; G[u].push_back(Edge(v, c, 0, G[v].size(),0)); G[v].push_back(Edge(u, 0, 0, G[u].size() - 1, id)); // 使用无向图时将0改为c即可 &#125; bool BFS() &#123; unsigned u, v; queue&lt;unsigned&gt; q; memset(b, 0, sizeof(b)); q.push(s); d[s] = 0; b[s] = 1; while (!q.empty()) &#123; u = q.front(); q.pop(); for (auto it = G[u].begin(); it != G[u].end(); ++it) &#123; Edge &amp;e = *it; if (!b[e.v] &amp;&amp; e.c&gt;e.f) &#123; b[e.v] = 1; d[e.v] = d[u] + 1; q.push(e.v); &#125; &#125; &#125; return b[t]; &#125; int DFS(unsigned u, int a) &#123; if (u == t || a == 0) return a; int flow = 0, f; for (unsigned &amp;i = cur[u]; i&lt;G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (d[u] + 1 == d[e.v] &amp;&amp; (f = DFS(e.v, min(a, e.c - e.f)))&gt;0) &#123; a -= f; e.f += f; G[e.v][e.flip].f -= f; flow += f; if (!a) break; &#125; &#125; return flow; &#125; int MaxFlow(unsigned s, unsigned t) &#123; int flow = 0; this-&gt;s = s; this-&gt;t = t; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;;int Flow[10000+23];int N, M;int Dif[Maxn];int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; N &gt;&gt; M) &#123; const int ss = N + 1, st = N + 2; memset(Dif, 0, sizeof(Dif)); memset(Flow, 0, sizeof(Flow)); Dinic Din; Din.Init(N); int u, v, b, c; for (int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; c &gt;&gt; b; if (b) &#123; b = c; Dif[u] -= b; Dif[v] += b; Flow[i] = b; &#125; else Din.AddEdge(u, v, c - b, i); &#125; int sum = 0; for (int i = 1; i &lt;= N; ++i) &#123; if (Dif[i] &gt; 0) &#123; Din.AddEdge(ss, i, Dif[i], 0); sum += Dif[i]; &#125; if (Dif[i] &lt; 0) Din.AddEdge(i, st, -Dif[i], 0); &#125; int ans = Din.MaxFlow(ss, st); Din.AddEdge(N, 1, INF, 0); ans += Din.MaxFlow(ss, st); if (sum != ans) cout &lt;&lt; "Impossible\n"; else &#123; cout &lt;&lt; Din.G[N].rbegin()-&gt;f &lt;&lt; '\n'; for (int i = 1; i &lt;= N; ++i) for (const auto &amp;e : Din.G[i]) &#123; if (e.id) Flow[e.id] += -e.f; &#125; for (int i = 1; i &lt; M; ++i) cout &lt;&lt; Flow[i] &lt;&lt; ' '; cout &lt;&lt; Flow[M] &lt;&lt; '\n'; &#125; &#125; return 0;&#125; HDU3157 - Crazy Circuits 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;#define INF 0x3f3f3f3fconst int Maxn = 100;int N, M, S, T, SS, ST;int Dif[Maxn];bool QIn(int &amp;x) &#123; char c; while ((c = getchar()) != EOF &amp;&amp; (!isdigit(c) &amp;&amp; (c != '+'&amp;&amp;c != '-'))); switch (c) &#123; case '+':x = S; return true; case '-':x = T; return true; case EOF: return false; &#125; x = 0; do &#123; x *= 10; x += c - '0'; &#125; while ((c = getchar()) != EOF&amp;&amp;isdigit(c)); return true;&#125;struct Edge &#123; int c, f; unsigned v, flip; Edge(unsigned v, int c, int f, unsigned flip) :v(v), c(c), f(f), flip(flip) &#123;&#125;&#125;;class Dinic &#123;private: bool b[Maxn]; int a[Maxn]; unsigned p[Maxn], cur[Maxn], d[Maxn];public: vector&lt;Edge&gt; G[Maxn]; unsigned s, t; void Init(unsigned n) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); &#125; void AddEdge(unsigned u, unsigned v, int c) &#123; G[u].push_back(Edge(v, c, 0, G[v].size())); G[v].push_back(Edge(u, 0, 0, G[u].size() - 1)); //使用无向图时将0改为c即可 &#125; bool BFS() &#123; unsigned u, v; queue&lt;unsigned&gt; q; memset(b, 0, sizeof(b)); q.push(s); d[s] = 0; b[s] = 1; while (!q.empty()) &#123; u = q.front(); q.pop(); for (auto it = G[u].begin(); it != G[u].end(); ++it) &#123; Edge &amp;e = *it; if (!b[e.v] &amp;&amp; e.c&gt;e.f) &#123; b[e.v] = 1; d[e.v] = d[u] + 1; q.push(e.v); &#125; &#125; &#125; return b[t]; &#125; int DFS(unsigned u, int a) &#123; if (u == t || a == 0) return a; int flow = 0, f; for (unsigned &amp;i = cur[u]; i&lt;G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (d[u] + 1 == d[e.v] &amp;&amp; (f = DFS(e.v, min(a, e.c - e.f)))&gt;0) &#123; a -= f; e.f += f; G[e.v][e.flip].f -= f; flow += f; if (!a) break; &#125; &#125; return flow; &#125; int MaxFlow(unsigned s, unsigned t) &#123; int flow = 0; this-&gt;s = s; this-&gt;t = t; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;;void Input(Dinic &amp;d) &#123; memset(Dif, 0, sizeof(Dif)); int u, v, b; char c; for (int i = 1; i &lt;= M; ++i) &#123; QIn(u); QIn(v); QIn(b); d.AddEdge(u, v, INF); //由于无上界，直接写INF好了，反正流量不可能达到INF-b Dif[u] -= b; Dif[v] += b; &#125;&#125;int main() &#123; while (~scanf("%d %d",&amp;N,&amp;M) &amp;&amp; M) &#123; //N可以等于0！ S = N + 1, T = N + 2; SS = S + 2, ST = T + 2; Dinic D; Input(D); int sum = 0; for (int i = 1; i &lt;= T; ++i) &#123; //建立与超级源汇点ss、st的边（别漏了源汇点！） if (Dif[i] &gt; 0) &#123; D.AddEdge(SS, i, Dif[i]); sum += Dif[i]; &#125; if (Dif[i] &lt; 0) D.AddEdge(i, ST, -Dif[i]); &#125; int ans=D.MaxFlow(SS, ST); D.AddEdge(T, S, INF); ans += D.MaxFlow(SS, ST); if (ans != sum) &#123; puts("impossible"); &#125; else &#123; printf("%d\n", D.G[T].rbegin()-&gt;f); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>HDU</category>
      </categories>
      <tags>
        <tag>HDU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA11248 - Frequency Hopping (网络流)]]></title>
    <url>%2Fposts%2F28286.html</url>
    <content type="text"><![CDATA[Description uva的pdf格式题目复制有问题，直接贴原题链接了。 UVA11248 - Frequency Hopping Key 给一个N点E条边的网络流，问能否找出1-&gt;N的一条流量等于C的流。若不能，若修改一条弧的上界，可否找到？列出所有可修改的弧。 先求出最大流，若大于C，输出“possible”。 若小于C，枚举修改每一条弧再次运行最大流（记得记录每条修改过的弧，本次最大流运行过后再重新把每条弧的流量恢复。不能每次都从头开始计算最大流，会超时）。 可以如下优化，不需要求最大流，只需流量大于等于C时就可以停止。不过既然已经AC了就不管了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;#define INF 0x3f3f3f3fstruct UIF &#123; int u, i, f; UIF(const int &amp;u, const int &amp;i, const int &amp;f) :u(u), i(i), f(f) &#123;&#125;&#125;;const int Maxn = 150;typedef pair&lt;int, int&gt; UV;int N, E, C;vector&lt;UV&gt; Q;vector&lt;UIF&gt; Chg;struct Edge &#123; int c, f; unsigned v, flip; Edge(unsigned v, int c, int f, unsigned flip) :v(v), c(c), f(f), flip(flip) &#123;&#125;&#125;;class Dinic &#123;private: bool b[Maxn]; int a[Maxn]; unsigned p[Maxn], cur[Maxn], d[Maxn];public: vector&lt;Edge&gt; G[Maxn]; unsigned s, t; void Init(unsigned n) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); &#125; void AddEdge(unsigned u, unsigned v, int c) &#123; G[u].push_back(Edge(v, c, 0, G[v].size())); G[v].push_back(Edge(u, 0, 0, G[u].size() - 1)); //使用无向图时将0改为c即可 &#125; bool BFS() &#123; unsigned u, v; queue&lt;unsigned&gt; q; memset(b, 0, sizeof(b)); q.push(s); d[s] = 0; b[s] = 1; while (!q.empty()) &#123; u = q.front(); q.pop(); for (auto it = G[u].begin(); it != G[u].end(); ++it) &#123; Edge &amp;e = *it; if (!b[e.v] &amp;&amp; e.c &gt; e.f) &#123; b[e.v] = 1; d[e.v] = d[u] + 1; q.push(e.v); &#125; &#125; &#125; return b[t]; &#125; int DFS(unsigned u, int a) &#123; if (u == t || a == 0) return a; int flow = 0, f; for (unsigned &amp;i = cur[u]; i &lt; G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (d[u] + 1 == d[e.v] &amp;&amp; (f = DFS(e.v, min(a, e.c - e.f))) &gt; 0) &#123; a -= f; e.f += f; G[e.v][e.flip].f -= f; flow += f; Chg.push_back(UIF(u, i, f)); Chg.push_back(UIF(e.v, e.flip, -f)); if (!a) break; &#125; &#125; return flow; &#125; int MaxFlow(unsigned s, unsigned t) &#123; int flow = 0; this-&gt;s = s; this-&gt;t = t; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); //if (flow &gt;= C) break; &#125; return flow; &#125;&#125;;void Traverse(Dinic &amp;din, int lf) &#123; for (int u = 1; u &lt;= N; ++u) &#123; for (auto &amp;e : din.G[u]) if (e.c) &#123; int tmp = e.c; e.c = C; Chg.clear(); int f = din.MaxFlow(1, N); if (f &gt;= lf) Q.push_back(make_pair(u, e.v)); e.c = tmp; for (const auto &amp;e : Chg) din.G[e.u][e.i].f -= e.f; &#125; &#125;&#125;int main() &#123; int Case = 0; while (~scanf("%d%d%d", &amp;N, &amp;E, &amp;C) &amp;&amp; (N | E | C)) &#123; Dinic Din; int u, v, c; for (int i = 1; i &lt;= E; ++i) &#123; scanf("%d%d%d", &amp;u, &amp;v, &amp;c); Din.AddEdge(u, v, c); &#125; int f = Din.MaxFlow(1, N); printf("Case %d: ", ++Case); if (f &gt;= C) &#123; puts("possible"); &#125; else &#123; Q.clear(); Traverse(Din, C - f); if (Q.empty()) &#123; puts("not possible"); &#125; else &#123; printf("possible option:"); sort(Q.begin(), Q.end()); for (auto p = Q.begin(); p != Q.end(); ++p) &#123; printf("(%d,%d)%c", p-&gt;first, p-&gt;second, ",\n"[p + 1 == Q.end()]); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有上下界的网络流笔记]]></title>
    <url>%2Fposts%2F30673.html</url>
    <content type="text"><![CDATA[从大佬的博客里学到了很多东西，以下是自己的小总结。 无源汇有上下界可行流 步骤 建立超级源点ss与汇点st； 像普通网络流一样建图，但其中边的上界为c-b（上界-下界）； 计算所有点的Dif（流入下界之和 - 流出下界之和）。 如果Dif[u]大于0，建立ss到u的上界为Dif的附加边； 如果Dif[u]小于0，建立u到st的上界为-Dif的附加边； 计算从ss到st的最大流； 计算每条附加边的流量。若每条附加边u的流量均为Dif[u]（即每条附加边都满载），则说明找到了可行流。 算竞训练指南上说还要建立一条st到ss的流量上界INF的边，翻了很多资料博客，其实应该不可以添加。应该是书上错了？ 模板题 SGU194 - Reactor Cooling 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123//上下界网络流#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;cstring&gt;#define INF 0x7FFFFFFF#define Maxn 22222using namespace std;struct Edge &#123; int c, f,id; unsigned v, flip; Edge(unsigned v, int c, int f, unsigned flip,int id) :v(v), c(c), f(f), flip(flip),id(id) &#123;&#125;&#125;;class Dinic &#123;public: bool b[Maxn]; int a[Maxn]; unsigned p[Maxn], cur[Maxn], d[Maxn]; vector&lt;Edge&gt; G[Maxn]; unsigned s, t; void Init(unsigned n) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); &#125; void AddEdge(unsigned u, unsigned v, int c,int id) &#123; G[u].push_back(Edge(v, c, 0, G[v].size(),id)); G[v].push_back(Edge(u, 0, 0, G[u].size() - 1,0)); // 使用无向图时将0改为c即可 &#125; bool BFS() &#123; unsigned u, v; queue&lt;unsigned&gt; q; memset(b, 0, sizeof(b)); q.push(s); d[s] = 0; b[s] = 1; while (!q.empty()) &#123; u = q.front(); q.pop(); for (auto it = G[u].begin(); it != G[u].end(); ++it) &#123; Edge &amp;e = *it; if (!b[e.v] &amp;&amp; e.c&gt;e.f) &#123; b[e.v] = 1; d[e.v] = d[u] + 1; q.push(e.v); &#125; &#125; &#125; return b[t]; &#125; int DFS(unsigned u, int a) &#123; if (u == t || a == 0) return a; int flow = 0, f; for (unsigned &amp;i = cur[u]; i&lt;G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (d[u] + 1 == d[e.v] &amp;&amp; (f = DFS(e.v, min(a, e.c - e.f)))&gt;0) &#123; a -= f; e.f += f; G[e.v][e.flip].f -= f; flow += f; if (!a) break; &#125; &#125; return flow; &#125; int MaxFlow(unsigned s, unsigned t) &#123; int flow = 0; this-&gt;s = s; this-&gt;t = t; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;;int Flow[1000000];int N, M;int Dif[Maxn];int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; N &gt;&gt; M) &#123; const int ss = N + 1, st = N + 2; memset(Dif, 0, sizeof(Dif)); memset(Flow, 0, sizeof(Flow)); Dinic Din; Din.Init(N); int u, v, b, c; for (int i = 1; i &lt;= M; ++i) &#123; cin &gt;&gt; u &gt;&gt; v &gt;&gt; b &gt;&gt; c; Din.AddEdge(u, v, c - b,i); Dif[u] -= b; Dif[v] += b; Flow[i] = b; &#125; for (int i = 1; i &lt;= N; ++i) &#123; if (Dif[i] &gt; 0) Din.AddEdge(ss, i, Dif[i],0); if (Dif[i] &lt; 0) Din.AddEdge(i, st, -Dif[i],0); &#125; Din.MaxFlow(ss, st); bool flg = false; for (const auto &amp;e : Din.G[ss]) &#123; if (e.f != e.c) &#123; flg = true; break; &#125; &#125; if (flg) cout &lt;&lt; "NO\n"; else &#123; cout &lt;&lt; "YES\n"; for (int i = 1; i &lt;= M;++i) for (const auto &amp;e : Din.G[i]) &#123; if (e.id) Flow[e.id] += e.f; &#125; for (int i = 1; i &lt;= M; ++i) cout &lt;&lt; Flow[i] &lt;&lt; '\n'; &#125; &#125; return 0;&#125; 有源汇有上下界最大流 步骤 从t到s连一条流量下界为0，上界INF的边，将其转换为无源汇有上下界的最大流； 按照无源汇有上下界可行流的做法找出可行流（保证了每条边的流量大于下界）； 在2的基础上删除超级源汇点ss、st与附加边（名义上说是要先删除ss、st，但实际上，此时每条附加边已经满流，在运行s-t的最大流时，ss与st的流量不会再变化，所以其实不用做任何操作），从s到t再次寻找一次最大流。（可以直接在上面的建图中运行，然后给每条边加上对应b）。 模板题 在 \[ 大大大大大大\\ 大大大大大大\\ 大大大大大大\\ 大 \] 期间各大学校的OJ都挂了。。。以后更新吧。 有源汇有上下界最小流 步骤 按照无源汇有上下界的最大流的做法找出可行流（但不要建立t-&gt;s）； 添加t-&gt;s，流量上界INF； 再次运行最大流，找出ss-&gt;st可行流； 若ss不满载，则无可行流。反之，最小流为t-&gt;s的流量，每条边的流量为逆向边的流量（加上下界b）。 模板题 HDU3157 - Crazy Circuits 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;#define INF 0x3f3f3f3fconst int Maxn = 100;int N, M, S, T, SS, ST;int Dif[Maxn];bool QIn(int &amp;x) &#123; char c; while ((c = getchar()) != EOF &amp;&amp; (!isdigit(c) &amp;&amp; (c != '+'&amp;&amp;c != '-'))); switch (c) &#123; case '+':x = S; return true; case '-':x = T; return true; case EOF: return false; &#125; x = 0; do &#123; x *= 10; x += c - '0'; &#125; while ((c = getchar()) != EOF&amp;&amp;isdigit(c)); return true;&#125;struct Edge &#123; int c, f; unsigned v, flip; Edge(unsigned v, int c, int f, unsigned flip) :v(v), c(c), f(f), flip(flip) &#123;&#125;&#125;;class Dinic &#123;private: bool b[Maxn]; int a[Maxn]; unsigned p[Maxn], cur[Maxn], d[Maxn];public: vector&lt;Edge&gt; G[Maxn]; unsigned s, t; void Init(unsigned n) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); &#125; void AddEdge(unsigned u, unsigned v, int c) &#123; G[u].push_back(Edge(v, c, 0, G[v].size())); G[v].push_back(Edge(u, 0, 0, G[u].size() - 1)); //使用无向图时将0改为c即可 &#125; bool BFS() &#123; unsigned u, v; queue&lt;unsigned&gt; q; memset(b, 0, sizeof(b)); q.push(s); d[s] = 0; b[s] = 1; while (!q.empty()) &#123; u = q.front(); q.pop(); for (auto it = G[u].begin(); it != G[u].end(); ++it) &#123; Edge &amp;e = *it; if (!b[e.v] &amp;&amp; e.c&gt;e.f) &#123; b[e.v] = 1; d[e.v] = d[u] + 1; q.push(e.v); &#125; &#125; &#125; return b[t]; &#125; int DFS(unsigned u, int a) &#123; if (u == t || a == 0) return a; int flow = 0, f; for (unsigned &amp;i = cur[u]; i&lt;G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (d[u] + 1 == d[e.v] &amp;&amp; (f = DFS(e.v, min(a, e.c - e.f)))&gt;0) &#123; a -= f; e.f += f; G[e.v][e.flip].f -= f; flow += f; if (!a) break; &#125; &#125; return flow; &#125; int MaxFlow(unsigned s, unsigned t) &#123; int flow = 0; this-&gt;s = s; this-&gt;t = t; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;;void Input(Dinic &amp;d) &#123; memset(Dif, 0, sizeof(Dif)); int u, v, b; char c; for (int i = 1; i &lt;= M; ++i) &#123; QIn(u); QIn(v); QIn(b); d.AddEdge(u, v, INF); //由于无上界，直接写INF好了，反正流量不可能达到INF-b Dif[u] -= b; Dif[v] += b; &#125;&#125;int main() &#123; while (~scanf("%d %d",&amp;N,&amp;M) &amp;&amp; M) &#123; //N可以等于0！ S = N + 1, T = N + 2; SS = S + 2, ST = T + 2; Dinic D; Input(D); int sum = 0; for (int i = 1; i &lt;= T; ++i) &#123; //建立与超级源汇点ss、st的边（别漏了源汇点！） if (Dif[i] &gt; 0) &#123; D.AddEdge(SS, i, Dif[i]); sum += Dif[i]; &#125; if (Dif[i] &lt; 0) D.AddEdge(i, ST, -Dif[i]); &#125; int ans=D.MaxFlow(SS, ST); D.AddEdge(T, S, INF); ans += D.MaxFlow(SS, ST); if (ans != sum) &#123; puts("impossible"); &#125; else &#123; printf("%d\n", D.G[T].rbegin()-&gt;f); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UVA11082 - Matrix Decompressing (上下界网络流)]]></title>
    <url>%2Fposts%2F55526.html</url>
    <content type="text"><![CDATA[Description UVA11082 - Matrix Decompressing Some RxC matrix of positive integers is encoded and represented by its R cumulative row sum and C column sum entries. Given, R, C and those R+C cumulative row sum and column sums, you want to decode the matrix (i.e., find all the individual R * C entries). In other words, the i-th row sum is the sum of all the entries in row i. And the cumulative i-th row sum is the sum of all the row sums from row 1 to row i (inclusive). Input There can be multiple test cases. The first line of input contains the number of test cases, T (1 ≤T ≤ 100). Each test case contains 3 lines of input. The first line of the test case gives the size of the matrix: the number of rows, R (1 ≤ R ≤ 20) and the number of columns C (1 ≤ C ≤20). The next line contains all the R cumulative row sums, and the last line of the test case contains the C cumulative column sums. Any two successive numbers in the same line is separated by a single space. Output For each test case print the label of the test case in the first line. The format of this label should be “Matrix x” where x would be replaced by the serial number of the test case starting at 1. In each of the following R lines print C integers giving all the individual entries of the matrix. You can assume that there is at least one solution for each of the given encodings. To simplify the problem further, we add the constraint that each entry in the matrix must be an integer between 1 and 20. In case of multiple solutions, you can output any one of them. Sample Input 123456723 410 31 5810 20 37 583 410 31 5810 20 37 58 Sample Output 12345678Matrix 11 6 1 21 2 2 168 2 14 3Matrix 21 1 1 71 1 7 128 8 9 2 Key1 给一矩阵每一行每一列的和，求一个可行矩阵。行数列数在[1, 20]之间，每个元素大小在[1,20]之间。 从输入可以得到没一行、每一列的和。以行、列建立二分图。以所有行、所有列为结点，建立源汇点s、t。s向所有行结点建边，上界为该行的和。所有列结点向t建边，上界为该列的和。所有行向所有列建边，上界为20。 由于矩阵每个元素都大于零，可以知道，每条行-列的边下界为1。 使用有源汇有上下界的最大流的方法。s-&gt;每个行结点 的c减去m，每个行节点-&gt;每个列结点的c减去1（则都变成了19），每个列结点-&gt;t的c减去n。然后就是按照通用方法连接t-&gt;s，建立超级源汇点ss、st并建立附加边，运行maxflow(ss, st)，然后去除附加边与ss、st，再次运行maxflow(s, t)。行节点-&gt;列结点的flow+1即为矩阵元素值。 Code1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;queue&gt;using namespace std;#define INF 0x7FFFFFFFconst int maxn = 50;struct Edge &#123; int c, f; unsigned v, flip; Edge(unsigned v, int c, int f, unsigned flip) :v(v), c(c), f(f), flip(flip) &#123;&#125;&#125;;class Dinic &#123;public: bool b[maxn]; int a[maxn]; unsigned p[maxn], cur[maxn], d[maxn]; vector&lt;Edge&gt; G[maxn]; unsigned s, t; void Init(unsigned n) &#123; for (int i = 0; i &lt;= n; ++i) G[i].clear(); &#125; void AddEdge(unsigned u, unsigned v, int c) &#123; G[u].push_back(Edge(v, c, 0, G[v].size())); G[v].push_back(Edge(u, 0, 0, G[u].size() - 1)); //使用无向图时将0改为c即可 &#125; bool BFS() &#123; unsigned u, v; queue&lt;unsigned&gt; q; memset(b, 0, sizeof(b)); q.push(s); d[s] = 0; b[s] = 1; while (!q.empty()) &#123; u = q.front(); q.pop(); for (auto it = G[u].begin(); it != G[u].end(); ++it) &#123; Edge &amp;e = *it; if (!b[e.v] &amp;&amp; e.c&gt;e.f) &#123; b[e.v] = 1; d[e.v] = d[u] + 1; q.push(e.v); &#125; &#125; &#125; return b[t]; &#125; int DFS(unsigned u, int a) &#123; if (u == t || a == 0) return a; int flow = 0, f; for (unsigned &amp;i = cur[u]; i&lt;G[u].size(); ++i) &#123; Edge &amp;e = G[u][i]; if (d[u] + 1 == d[e.v] &amp;&amp; (f = DFS(e.v, min(a, e.c - e.f)))&gt;0) &#123; a -= f; e.f += f; G[e.v][e.flip].f -= f; flow += f; if (!a) break; &#125; &#125; return flow; &#125; int MaxFlow(unsigned s, unsigned t) &#123; int flow = 0; this-&gt;s = s; this-&gt;t = t; while (BFS()) &#123; memset(cur, 0, sizeof(cur)); flow += DFS(s, INF); &#125; return flow; &#125;&#125;;int Dif[maxn];int T, R, C;int main() &#123; scanf("%d", &amp;T); for (int Case = 1; Case &lt;= T; ++Case) &#123; scanf("%d%d", &amp;R, &amp;C); memset(Dif, 0, sizeof(Dif)); Dinic din; const int s = R + C + 1, t = R + C + 2; const int ss = s+2, st = t + 2; int ipt, last_ipt; last_ipt = 0; for (int i = 1; i &lt;= R; ++i) &#123; scanf("%d", &amp;ipt); din.AddEdge(s, i, ipt - last_ipt - C); last_ipt = ipt; Dif[s] -= C; Dif[i] += C; &#125; last_ipt = 0; for (int i = 1; i &lt;= C; ++i) &#123; scanf("%d", &amp;ipt); din.AddEdge(R + i, t, ipt - last_ipt - R); last_ipt = ipt; Dif[R + i] -= R; Dif[t] += R; &#125; for (int i = 1; i &lt;= R; ++i) for (int j = 1; j &lt;= C; ++j) &#123; din.AddEdge(i, R + j, 20 - 1); Dif[i] -= 1; Dif[R + j] += 1; &#125; din.AddEdge(t, s, INF); for (int i = 1; i &lt;= R*C+2; ++i) &#123; if (Dif[i] &gt; 0) din.AddEdge(ss, i, Dif[i]); if (Dif[i] &lt; 0) din.AddEdge(i, st, -Dif[i]); &#125; din.MaxFlow(ss, st); for (auto &amp;e : din.G[ss]) din.G[e.v][e.flip].f = din.G[e.v][e.flip].c = e.c = e.f = 0; for (auto &amp;e : din.G[st]) din.G[e.v][e.flip].f = din.G[e.v][e.flip].c = e.c = e.f = 0; din.MaxFlow(s, t); printf("Matrix %d\n", Case); for (int i = 1; i &lt;= R; ++i) &#123; for (const auto &amp;e : din.G[i]) if (e.c) &#123; printf("%d ", e.f + 1); &#125; puts(""); &#125; &#125; return 0;&#125; Key2 上述有源汇有上下界最大流的通用解法之所以通用，是因为“上界减去下界后图中的流量不一定平衡”。而本题的每条边的流量下界被减去后，流量依然是平衡的，所以可以优化。（即上述代码运行完后会发现，Dif[i]均为0，即ss和st没有边连接原图。） 在把s-&gt;行的c减去m、行-&gt;列的c减去1、列-&gt;t的c减去n后，直接运行maxflow(s, t)，行-&gt;列的flow加上1即为答案。 Code2 1234567891011121314151617181920212223242526272829303132333435//main函数之前内容一样int T, R, C;int main() &#123; scanf("%d", &amp;T); for (int Case = 1; Case &lt;= T; ++Case) &#123; scanf("%d%d", &amp;R, &amp;C); Dinic din; const int s = R + C + 1, t = R + C + 2; int ipt, last_ipt; last_ipt = 0; for (int i = 1; i &lt;= R; ++i) &#123; scanf("%d", &amp;ipt); din.AddEdge(s, i, ipt - last_ipt-C); last_ipt = ipt; &#125; last_ipt = 0; for (int i = 1; i &lt;= C; ++i) &#123; scanf("%d", &amp;ipt); din.AddEdge(R + i, t, ipt - last_ipt-R); last_ipt = ipt; &#125; for (int i = 1; i &lt;= R; ++i) for (int j = 1; j &lt;= C;++j) &#123; din.AddEdge(i, R + j, 20-1); &#125; din.MaxFlow(s, t); printf("Matrix %d\n", Case); for (int i = 1; i &lt;= R; ++i) &#123; for (const auto &amp;e : din.G[i]) if (e.c) &#123; printf("%d ", e.f+1); &#125; puts(""); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>UVa</category>
      </categories>
      <tags>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 441(Div. 2) - D. Sorting the Coins]]></title>
    <url>%2Fposts%2F39930.html</url>
    <content type="text"><![CDATA[Description Recently, Dima met with Sasha in a philatelic store, and since then they are collecting coins together. Their favorite occupation is to sort collections of coins. Sasha likes having things in order, that is why he wants his coins to be arranged in a row in such a way that firstly come coins out of circulation, and then come coins still in circulation. For arranging coins Dima uses the following algorithm. One step of his algorithm looks like the following: He looks through all the coins from left to right; If he sees that the i-th coin is still in circulation, and (i + 1)-th coin is already out of circulation, he exchanges these two coins and continues watching coins from (i + 1)-th. Dima repeats the procedure above until it happens that no two coins were exchanged during this procedure. Dima calls hardness of ordering the number of steps required for him according to the algorithm above to sort the sequence, e.g. the number of times he looks through the coins from the very beginning. For example, for the ordered sequence hardness of ordering equals one. Today Sasha invited Dima and proposed him a game. First he puts n coins in a row, all of them are out of circulation. Then Sasha chooses one of the coins out of circulation and replaces it with a coin in circulation for n times. During this process Sasha constantly asks Dima what is the hardness of ordering of the sequence. The task is more complicated because Dima should not touch the coins and he should determine hardness of ordering in his mind. Help Dima with this task. Input The first line contains single integer n (1 ≤ n ≤ 300 000) — number of coins that Sasha puts behind Dima. Second line contains n distinct integers p1, p2, ..., pn (1 ≤ pi ≤ n) — positions that Sasha puts coins in circulation to. At first Sasha replaces coin located at position p1, then coin located at position p2 and so on. Coins are numbered from left to right. Output Print n + 1 numbers a0, a1, ..., an, where a0 is a hardness of ordering at the beginning, a1 is a hardness of ordering after the first replacement and so on. Examples 12345678910input41 3 4 2output1 2 3 2 1input86 8 3 4 7 2 1 5output1 2 2 3 4 3 4 5 1 Note Let's denote as O coin out of circulation, and as X — coin is circulation. At the first sample, initially in row there are coins that are not in circulation, so Dima will look through them from left to right and won't make any exchanges. After replacement of the first coin with a coin in circulation, Dima will exchange this coin with next three times and after that he will finally look through the coins and finish the process. XOOO → OOOX After replacement of the third coin, Dima's actions look this way: XOXO → OXOX → OOXX After replacement of the fourth coin, Dima's actions look this way: XOXX → OXXX Finally, after replacement of the second coin, row becomes consisting of coins that are in circulation and Dima will look through coins from left to right without any exchanges. Key 读题读了半天才懂。n个硬币O面朝上排成一个序列。游戏一共n轮，在每一轮的一开始，所有硬币O面朝上，然后把第p[1]~p[i]个硬币（共i个硬币）翻转为X面。然后进行如下操作： 从左往右遍历整个序列，如果第j个硬币为X且第j+1个硬币为O，交换两者，然后从j+1个硬币继续进行。 持续进行上述遍历，直至最后一遍遍历没有交换任何硬币。把第i轮进行的遍历次数记为a[i]。要求求出每一轮游戏的a[i]（以及初始状态下的遍历次数a[0]）。 规律是，找出序列最右的O的下标idx（则其右侧为一个连续的X序列或为空），每一轮维护之。计算idx左边有多少X即可。实际计算时，只需判断当前轮翻转的硬币是否使得idx向左移动，若是，a[i]=a[i-1]+1-(new_idx-idx)。否则，a[i]=a[i-1]+1。 Code 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;const int maxn = 300000 + 17;int n, p;bool s[maxn];int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; n; int idx = n + 1; int res = 1; cout &lt;&lt; "1"; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; p; s[p] = true; ++res; if (idx == p + 1) &#123; int pre_idx = idx; while (s[--pre_idx]); ++pre_idx; res -= idx - pre_idx; idx = pre_idx; &#125; cout &lt;&lt; ' ' &lt;&lt; res; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 ACM Qingdao Online - Brute Force Sorting]]></title>
    <url>%2Fposts%2F63088.html</url>
    <content type="text"><![CDATA[2017 ACM-ICPC Asia Regional Qingdao Online - 1010 - Brute Force Sorting（HDU6215） Time Limit: 1000/1000 MS (Java/Others) Memory Limit: 65535/32768 K (Java/Others)Total Submission(s): 1195 Accepted Submission(s): 309 Problem Description Beerus needs to sort an array of N integers. Algorithms are not Beerus's strength. Destruction is what he excels. He can destroy all unsorted numbers in the array simultaneously. A number A[i] of the array is sorted if it satisfies the following requirements. 1. A[i] is the first element of the array, or it is no smaller than the left one A[i−1]. 2. A[i] is the last element of the array, or it is no bigger than the right one A[i+1]. In [1,4,5,2,3], for instance, the element 5 and the element 2 would be destoryed by Beerus. The array would become [1,4,3]. If the new array were still unsorted, Beerus would do it again. Help Beerus predict the final array. Input The first line of input contains an integer T (1≤T≤10) which is the total number of test cases. For each test case, the first line provides the size of the inital array which would be positive and no bigger than 100000. The second line describes the array with N positive integers A[1],A[2],⋯,A[N] where each integer A[i] satisfies 1≤A[i]≤100000. Output For eact test case output two lines. The first line contains an integer M which is the size of the final array. The second line contains M integers describing the final array. If the final array is empty, M should be 0 and the second line should be an empty line. Sample Input 1234567891011551 2 3 4 555 4 3 2 151 2 3 2 151 3 5 4 252 4 1 3 5 Sample Output 1234567891051 2 3 4 5 021 2 21 3 32 3 5 Source 2017 ACM/ICPC Asia Regional Qingdao Online Key 比赛时想不出怎么做，暴力模拟了一遍，果不其然TLE。。。。大佬对我表示很无奈。 大佬：不是让你这么模拟啊！！！ 大佬提醒说用个审查队列维护，猛然醒悟。。。事后看了大佬的AC代码，又自己撸了一遍，终于AC了。（以及大佬的代码是真的优美） 用链表模拟，方便删除。关键点：模拟的时候用一个审查队列维护下一轮需要更新（可能删除）的点。每一轮删除都O(n)检查整个剩余序列肯定是不行的，把可能需要删除的点加入审查队列，每次只要检查队列里的每个元素即可。 哪些属于下一轮可能删除的点呢？上一轮删除的结点的左右结点。以及有一些小坑要注意。以下是我事后的AC的代码。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;const int Maxn = 100000 + 23;struct Node &#123; Node *l, *r; int v; Node(int _v, Node *_l) :v(_v), l(_l), r(nullptr) &#123;&#125;&#125;;int T, N;queue&lt;Node*&gt; ToDel, ToChk;Node *head;Node *Del(Node *p) &#123; Node *pl = p-&gt;l; Node *pr = p-&gt;r; pl-&gt;r = pr; pr-&gt;l = pl; delete p; return pl;&#125;void Input() &#123; cin &gt;&gt; N; head = new Node(0, nullptr); Node *now = head; int v; for (int i = 1; i &lt;= N; ++i) &#123; cin &gt;&gt; v; now-&gt;r = new Node(v, now); now = now-&gt;r; &#125; now-&gt;r = new Node(Maxn, now);&#125;void Output() &#123; int num = 0; Node *i; for (i = head-&gt;r; i-&gt;v != Maxn; i = i-&gt;r) ++num; cout &lt;&lt; num &lt;&lt; '\n'; for (i = head-&gt;r; i-&gt;v != Maxn; i = i-&gt;r) &#123; delete i-&gt;l; cout &lt;&lt; i-&gt;v &lt;&lt; ' '; &#125; delete i; cout &lt;&lt; '\n';&#125;int main() &#123; ios::sync_with_stdio(false); cin &gt;&gt; T; while (T--) &#123; Input(); for (Node *i = head-&gt;r; i-&gt;v != Maxn; i = i-&gt;r) &#123; if (i-&gt;v &lt; i-&gt;l-&gt;v || i-&gt;v &gt; i-&gt;r-&gt;v) &#123; ToDel.push(i); &#125; &#125; while (!ToDel.empty()) &#123; do &#123; Node *now = ToDel.front(); ToDel.pop(); Node *pre = now-&gt;l; Node *nxt = now-&gt;r; Del(now); if (pre-&gt;v != 0 &amp;&amp; (ToChk.empty() || ToChk.back() != pre)) ToChk.push(pre); if (nxt-&gt;v != Maxn &amp;&amp; (ToDel.empty() || ToDel.front() != nxt)) ToChk.push(nxt); &#125; while (!ToDel.empty()); while (!ToChk.empty()) &#123; Node *now = ToChk.front(); ToChk.pop(); Node *pre = now-&gt;l; Node *nxt = now-&gt;r; if (now-&gt;v&lt;pre-&gt;v || now-&gt;v&gt;nxt-&gt;v) ToDel.push(now); &#125; &#125; Output(); &#125;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python实现备份CSDN博客(未完成)]]></title>
    <url>%2Fposts%2F12203.html</url>
    <content type="text"><![CDATA[想着把我CSDN上所有博客的markdown源文件备份一遍，但其实没学过这方面的东西，就做了个半成品。。。以后完善吧（应该） 实现了提取所有文章的名字与其对应文章ID和发布时间，并找到编辑文档的网页。 上面这些信息提取很方便，网页源码里翻就找得到。 然后按照文件名与日期给每一篇文章建立每一个空文件夹。 但是最关键的一步是，我不知道怎么提取每一篇.md文件。。。 渲染好的已经发布的文本我不要，我要.md源文件。只有编辑文本的时候遇得到md文件，所以就得实现模拟浏览器登陆。。。然而并不会做。。。 http://write.blog.csdn.net/postedit/xxxxxxxx是文章的编辑页面，（打开来可以是markdown编辑器也可以是传统的那个），传统的编辑器的源码里倒是可以看到带样式的每个字，但是md编辑器的源码里面就没有。。。 md编辑器有个功能叫导出到本地，可以直接把.md文件下载下来。但是每次下载生成的链接都是随机的，我也不知道怎么找到这个函数。 有没有大神会的求留言:P。 半成品代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding=utf-8'''Created on 2017年8月19日@author: XieNaoban@github: https://github.com/xienaoban@blog: http://blog.csdn.net/xienaoban'''import osimport urllib#########################################################################def log(str): print("log: " + str + ".")##########################################################################参数设定auth = "xienaoban"wsp = "C:\\Users\\xjf19\\Desktop\\"#########################################################################s = urllib.request.urlopen("http://blog.csdn.net/" + auth).read().decode('utf-8')pages = ord(s[s.find("尾页") - 3]) - ord('0') + 1fout = open(wsp + "articles.txt",'w', encoding='utf-8')log(str(pages) + " page(s) found")key = "&lt;span class=\"link_title\"&gt;&lt;a href=\"/" + auth + "/article/details/"key2 = "link_postdate"edit = "http://write.blog.csdn.net/postedit/"articles = 0for page in range(1, pages): url = "http://blog.csdn.net/" + auth + "/article/list/"+str(page) sc = urllib.request.urlopen(url).read().decode('utf-8') i = 0 while True: tmp = sc.find(key, i) if(tmp &lt; i): break i = tmp + len(key) fout.write(edit) while sc[i]!='\"': fout.write(sc[i]) i += 1 i += 12 d = sc.find(key2, i) + len(key2) + 2 fout.write(" " + sc[d]+sc[d+1]+sc[d+2]+sc[d+3] + sc[d+5]+sc[d+6] + sc[d+8]+sc[d+9]) ed = sc.find("&lt;/a&gt;",i) - 22 while i != ed: if sc[i] !='/' and sc[i] != '*' and sc[i] != '?': fout.write(sc[i]) i += 1 fout.write("\n") articles += 1fout.close()log(str(articles) + " article(s) found")fin = open(wsp + "articles.txt", "r", encoding='utf-8')wsp += "Blog\\"if not os.path.exists(wsp): os.mkdir(wsp)new_dir = 0for arti in range(0, articles): line = fin.readline() if not line: break line = line[len(edit) + 4 + 8:-1] if not os.path.exists(wsp + line): os.mkdir(wsp + line) new_dir += 1log(str(new_dir) + " directory(s) added")log("program finished")#########################################################################]]></content>
      <tags>
        <tag>造轮子</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM ICPC 2015合肥网络赛 - Removed Interval]]></title>
    <url>%2Fposts%2F21829.html</url>
    <content type="text"><![CDATA[Problem Description Given a sequence of numbers A=a1,a2,…,aN, a subsequence b1,b2,…,bk of A is referred as increasing if b1&lt;b2&lt;…&lt;bk. LY has just learned how to find the longest increasing subsequence (LIS). Now that he has to select L consecutive numbers and remove them from A for some mysterious reasons. He can choose arbitrary starting position of the selected interval so that the length of the LIS of the remaining numbers is maximized. Can you help him with this problem? Input The first line of input contains a number T indicating the number of test cases (T≤100). For each test case, the first line consists of two numbers N and L as described above (1≤N≤100000,0≤L≤N). The second line consists of N integers indicating the sequence. The absolute value of the numbers is no greater than \(10^9\). The sum of N over all test cases will not exceed 500000. Output For each test case, output a single line consisting of “Case #X: Y”. X is the test case number starting from 1. Y is the maximum length of LIS after removing the interval. Sample Input 1234525 21 2 3 4 55 35 4 3 2 1 Sample Output 12Case #1: 3Case #2: 1 Source 2015 ACM/ICPC Asia Regional Hefei Online Key 啊被这题折磨了两天。最后发现是我数据范围错了。。题目说“The absolute value of the numbers is no greater than \(10^9\)”，我理解成\([1,1^9)\)了。。。 LIS题的一个变种。用\(O(n^2)\)的DP做是没法做的，\(O(n^2)\)本身就超时了，更别说别的处理。得用\(O(n \log n)\)的那个算法。 基本思路是，先计算出以每个\(A[i]\)为开头的LIS（即从右向左找以\(A[i]\)结尾的最大降序子序列）。 然后枚举所有挖掉的连续字串的位置：对于挖掉的\([i-L, i-1]\) \((i&gt;L)\)，LIS最大值为右侧以\(A[i]\)打头时的LIS加上左侧以比\(A[i]\)小的值结尾的最大LIS。 于是关键是怎么在左侧找出一个以\(A[i-L-1]\)结尾的LIS，要求LIS尽量大且\(A[i-L-1]&lt;A[i]\)。查了题解，才知道可以利用那个\(O(n \log n)\)算法，二分找出在左侧x个值中小于A[i]的最大LIS。真是太强了。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;functional&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int Maxn = 100000 + 10;int T, N, L;int A[Maxn], LIS[Maxn], BG[Maxn];int main() &#123; //freopen("F:\\Projects\\ConsoleApplication2\\ConsoleApplication2\\in.txt", "r", stdin); //freopen("F:\\Projects\\Debug Tools\\Comparison1.txt", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; T; for (int Case = 1; Case &lt;= T; ++Case) &#123; cin &gt;&gt; N &gt;&gt; L; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; A[i]; &#125; int res = 0; int len, idx; len = 1; LIS[0] = 0x7fffffff; for (int i = N - 1; i &gt;= 0; --i) &#123; idx = lower_bound(LIS, LIS + len, A[i], greater&lt;int&gt;()) - LIS; if (idx == len) ++len; LIS[idx] = A[i]; BG[i] = idx; if (i &gt;= L) res = max(res, idx); &#125; len = 1; LIS[0] = 0x80000000; for (int i = L; i &lt; N; ++i) &#123; idx = lower_bound(LIS, LIS + len, A[i], less&lt;int&gt;()) - LIS; res = max(res, BG[i] + idx - 1); idx = lower_bound(LIS, LIS + len, A[i - L], less&lt;int&gt;()) - LIS; if (idx == len) ++len; LIS[idx] = A[i - L]; res = max(res, idx); &#125; printf("Case #%d: %d\n", Case, res); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017百度之星资格赛 - 度度熊与邪恶大魔王]]></title>
    <url>%2Fposts%2F30936.html</url>
    <content type="text"><![CDATA[Problem Description 度度熊为了拯救可爱的公主，于是与邪恶大魔王战斗起来。 邪恶大魔王的麾下有n个怪兽，每个怪兽有a[i]的生命值，以及b[i]的防御力。 度度熊一共拥有m种攻击方式，第i种攻击方式，需要消耗k[i]的晶石，造成p[i]点伤害。 当然，如果度度熊使用第i个技能打在第j个怪兽上面的话，会使得第j个怪兽的生命值减少p[i]-b[j]，当然如果伤害小于防御，那么攻击就不会奏效。 如果怪兽的生命值降为0或以下，那么怪兽就会被消灭。 当然每个技能都可以使用无限次。 请问度度熊最少携带多少晶石，就可以消灭所有的怪兽。 Input 本题包含若干组测试数据。 第一行两个整数n，m,表示有n个怪兽，m种技能。 接下来n行，每行两个整数，a[i],b[i]，分别表示怪兽的生命值和防御力。 再接下来m行，每行两个整数k[i]和p[i]，分别表示技能的消耗晶石数目和技能的伤害值。 数据范围: 1&lt;=n&lt;=100000 1&lt;=m&lt;=1000 1&lt;=a[i]&lt;=1000 0&lt;=b[i]&lt;=10 0&lt;=k[i]&lt;=100000 0&lt;=p[i]&lt;=1000 Output 对于每组测试数据，输出最小的晶石消耗数量，如果不能击败所有的怪兽，输出-1 Sample Input 123456781 23 57 106 81 23 510 78 6 Sample Output 12618 Key 完全背包DP。防御力最高就10，则枚举每个防御力的情况。 在每个防御力b下，枚举所有技能，对于第c个攻击： 令atk=p[c]-b，DP血量a从1到1000， 若血量小于等于atk（一刀秒杀），则dp[a] = min(dp[a], k[c])； 若血量大于atk，则dp[a] = min(dp[a], dp[a-atk] + k[c])； 统计b防御力的所有怪物血量与其对应所需最小晶石。 若在b防御力下所有怪物的防御力均大于大于所有技能，则输出-1。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int maxn = 100000 + 10;const int maxm = 1000 + 10;int n, m;LL num[1000 + 10][13];LL k[maxm], p[maxm];LL dp[1000 + 10];int main() &#123; ios::sync_with_stdio(false); while (cin &gt;&gt; n &gt;&gt; m) &#123; memset(num, 0, sizeof(num)); LL ipt1, ipt2; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; ipt1 &gt;&gt; ipt2; ++num[ipt1][ipt2]; &#125; for (int i = 0; i &lt; m; ++i) &#123; cin &gt;&gt; k[i] &gt;&gt; p[i]; &#125; LL res = 0; for (int b = 0; b &lt;= 10; ++b) &#123; memset(dp, 0x7f, sizeof(dp)); dp[0] = 0; bool fail = true; for (int c = 0; c &lt; m; ++c) &#123; LL atk = p[c] - b; if (atk &lt;= 0) &#123; continue; &#125; fail = false; for (int a = 1; a &lt;= 1000; ++a) &#123; if (a - atk &lt;= 0)dp[a] = min(dp[a], k[c]); else &#123; dp[a] = min(dp[a], dp[a - atk] + k[c]); &#125; &#125; &#125; if (fail) &#123; for (int i = 1; i &lt;= 1000; ++i) &#123; if (num[i][b]) goto NOO; &#125; &#125; else &#123; for (int i = 1; i &lt;= 1000; ++i) &#123; res += num[i][b] * dp[i]; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; continue; NOO:cout &lt;&lt; -1 &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Win10一周年更新冻屏可能原因解决方案]]></title>
    <url>%2Fposts%2F41520.html</url>
    <content type="text"><![CDATA[辣鸡Win10要折腾死我啊。一开始还以为硬件烧坏了。写下来方自己以后使用。 条件 win10一周年更新； SSD、HDD混合，SSD作为系统盘 BIOS的：AHCI、SATA、IDE模式：BIOS里面没找到这玩意。。。Acer宏碁VN7的笔记本，BIOS里面选项很少，仿佛很老旧的感觉。。。 设备管理器-&gt;IDE ATA/ATAPI 控制器驱动：标准 SATA AHCI 控制器。 症状 长时间挂机导致冻屏：比如启动了电脑而没有登陆，过一会回来登录界面就卡住了；又比如开着电脑出去了一趟，回来就卡住了。 卡住的症状：鼠标可以灵活的移动，鼠标移动到任务栏的图标有高亮显示，但是点击、右击无反应；开始菜单第一次点击可以弹出，关了重按就卡住；前台软件无响应且无法弹出”程序无响应，等待还是强制关闭？“的弹窗；前台软件按关闭无响应，但拖动窗口很流畅；ctrl+alt+delete启动任务管理器没有任何动静。。。 玩GTA卡住：背景声音没有停，但是屏幕冻住了，半分钟后恢复了；后来又卡住了，这次没有恢复。 症状产生后，尝试强制重启，无线加载进不去登录界面；再强制重启，安全模式也进不去；尝试重装系统，U盘启动也无限加载。。。（于是以为是硬件坏了。的确，休息片刻散散热过后又很正常的开机了） 但是又感觉不是硬件问题，卡住前夕已经感觉哪里不对，但是卡住的瞬间是在执行某条命令时实现的：比如按了浏览器的收藏、比如试图启动别的程序。 综上，所有在前台正在运行的东西可以勉强反应一下，但已无法进行任何操作，给人一种无限卡在缺页中断的感觉。 网上教程 &quot;安装Windows 10周年更新后出现冻屏&quot; - Microsoft Community &quot;Task Manager might show 100% disk utilization on Windows 10 devices with Message Signaled Interrupt (MSI) mode enabled&quot; - Microsoft Support &quot;WIN10卡顿？&quot; - 知乎 &quot;win10周年版 SSD+加机械双硬盘假死的问题。？&quot; - 知乎 或许可行的方案 关闭MSI SSD也卡机？驱动人生解决Win10 SSD卡顿 我的MSI地址： 计算机\HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Enum\PCI\VEN_8086&amp;DEV_8C03&amp;SUBSYS_09261025&amp;REV_05\3&amp;11583659&amp;0&amp;FA\Device Parameters\Interrupt Management\MessageSignaledInterruptProperties 关闭虚拟内存 听说会好很多。。 更新英特尔的SATA AHCI驱动 在英特尔官网搜索: rst, 快速存储技术 具体驱动（最新版） 具体驱动（比最新版老一点的版本） 页面左侧的下载界面往下翻，找到SetupRST，下载安装驱动。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 425(Div. 2) - D. Misha, Grisha and Underground]]></title>
    <url>%2Fposts%2F39929.html</url>
    <content type="text"><![CDATA[Description Misha and Grisha are funny boys, so they like to use new underground. The underground has n stations connected with n - 1 routes so that each route connects two stations, and it is possible to reach every station from any other. The boys decided to have fun and came up with a plan. Namely, in some day in the morning Misha will ride the underground from station sto station f by the shortest path, and will draw with aerosol an ugly text &quot;Misha was here&quot; on every station he will pass through (including sand f). After that on the same day at evening Grisha will ride from station t to station f by the shortest path and will count stations with Misha's text. After that at night the underground workers will wash the texts out, because the underground should be clean. The boys have already chosen three stations a, b and c for each of several following days, one of them should be station s on that day, another should be station f, and the remaining should be station t. They became interested how they should choose these stations s, f, t so that the number Grisha will count is as large as possible. They asked you for help. Input The first line contains two integers n and q (2 ≤ n ≤ 105, 1 ≤ q ≤ 105) — the number of stations and the number of days. The second line contains n - 1 integers p2, p3, ..., p n (1 ≤ p i ≤ n). The integer p i means that there is a route between stations p i and i. It is guaranteed that it's possible to reach every station from any other. The next q lines contains three integers a, b and c each (1 ≤ a, b, c ≤ n) — the ids of stations chosen by boys for some day. Note that some of these ids could be same. Output Print q lines. In the i-th of these lines print the maximum possible number Grisha can get counting when the stations s, t and f are chosen optimally from the three stations on the i-th day. Examples 1234567891011121314input3 21 11 2 32 3 3output23input4 11 2 31 2 3output2 Note In the first example on the first day if s = 1, f = 2, t = 3, Misha would go on the route 1 2, and Grisha would go on the route 3 1 2. He would see the text at the stations 1 and 2. On the second day, if s = 3, f = 2, t = 3, both boys would go on the route 3 1 2. Grisha would see the text at 3 stations. In the second examle if s = 1, f = 3, t = 2, Misha would go on the route 1 2 3, and Grisha would go on the route 2 3 and would see the text at both stations. Key 给一棵树，从中取三点\(a\)、\(b\)、\(c\)，任取其中两点作为起点\(s\)、\(t\)，剩余一点作为终点\(f\)。问“s到f的最短路径”与“t到f的最短路径”重叠部分最大有多少。 使用了LCA与倍增。可以看到，三个点两两搭配的最近公共祖先中，必至少有两对是同一个祖先。 三个点只有以下两种情况：（令\(dep[lca(b,c)]&gt;=dep[lca(a,b)]\)，这样就可以把b、c看作一个整体了（b、c是不是处于一条链、是不是重叠也不影响bc整体与a的判断），此时\(dep[lca(a,b)]\)必等于\(dep[lca(a,c)]\)。） 第一种情况： a与bc不在一条链上。·可以看到答案要么是a到\(lca(b,c)\)的距离，要么是b、c分别到\(lca(b,c)\)的距离。 第二种情况： a与bc处于一条链。答案与上面类似，也是三种情况，但是没有经过分叉，计算上略微不同。 然而输入的abc位置随机，直接判断很麻烦。可以像上图一样，把lca深度大的设为b、c，就很方便了。 Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#define mset(a,b) memset(a,b,sizeof(a))using namespace std;const int maxn = (int)1e5 + 10;int n, q;int a, b, c;vector&lt;int&gt; T[maxn];int d[maxn];int p[maxn][28];void dfs(int u) &#123; for (auto &amp;i:T[u]) &#123; if (i == p[u][0]) continue; d[i] = d[u] + 1; p[i][0] = u; dfs(i); &#125;&#125;void init() &#123; for (int j = 1; (1 &lt;&lt; j) &lt;= n; j++) &#123; for (int i = 1; i &lt;= n; i++) &#123; p[i][j] = p[p[i][j - 1]][j - 1]; &#125; &#125;&#125;int lca(int a, int b) &#123; if (d[a]&gt;d[b])swap(a, b); int f = d[b] - d[a]; for (int i = 0; (1 &lt;&lt; i) &lt;= f; i++) &#123; if ((1 &lt;&lt; i)&amp;f)b = p[b][i]; &#125; if (a != b) &#123; for (int i = (int)log2(n); i &gt;= 0; i--) &#123; if (p[a][i] != p[b][i]) &#123; a = p[a][i]; b = p[b][i]; &#125; &#125; a = p[a][0]; &#125; return a;&#125;int main()&#123; mset(d, 0); mset(p, 0); ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; q; for (int i = 2; i &lt;= n; ++i) &#123; int p; cin &gt;&gt; p; T[i].push_back(p); T[p].push_back(i); &#125; dfs(1); init(); while (q--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; int f1 = lca(a, b); int f2 = lca(a, c); int f3 = lca(b, c); if (d[f1] &gt; d[f2]) &#123; swap(b, c); swap(f1, f2); &#125; if (d[f2] &gt; d[f3]) &#123; swap(a, b); swap(f2, f3); &#125; int res1 = (f1 == a ? (d[f3] - d[f1]) : (d[a] - d[f1]) + (d[f3] - d[f1])); int res2 = max(d[b] - d[f3], d[c] - d[f3]); cout &lt;&lt; max(res1, res2) + 1 &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 420(Div. 2) - D. Okabe and City]]></title>
    <url>%2Fposts%2F39927.html</url>
    <content type="text"><![CDATA[Description Okabe likes to be able to walk through his city on a path lit by street lamps. That way, he doesn't get beaten up by schoolchildren. Okabe's city is represented by a 2D grid of cells. Rows are numbered from 1 to n from top to bottom, and columns are numbered 1 to mfrom left to right. Exactly k cells in the city are lit by a street lamp. It's guaranteed that the top-left cell is lit. Okabe starts his walk from the top-left cell, and wants to reach the bottom-right cell. Of course, Okabe will only walk on lit cells, and he can only move to adjacent cells in the up, down, left, and right directions. However, Okabe can also temporarily light all the cells in any single row or column at a time if he pays 1 coin, allowing him to walk through some cells not lit initially. Note that Okabe can only light a single row or column at a time, and has to pay a coin every time he lights a new row or column. To change the row or column that is temporarily lit, he must stand at a cell that is lit initially. Also, once he removes his temporary light from a row or column, all cells in that row/column not initially lit are now not lit. Help Okabe find the minimum number of coins he needs to pay to complete his walk! Input The first line of input contains three space-separated integers n, m, and k (2 ≤ n, m, k ≤ 104). Each of the next k lines contains two space-separated integers r i and c i (1 ≤ r i ≤ n, 1 ≤ c i ≤ m) — the row and the column of the i-th lit cell. It is guaranteed that all k lit cells are distinct. It is guaranteed that the top-left cell is lit. Output Print the minimum number of coins Okabe needs to pay to complete his walk, or -1 if it's not possible. Examples 123456789101112131415161718192021222324252627282930313233input4 4 51 12 12 33 34 3output2input5 5 41 12 13 13 2output-1input2 2 41 11 22 12 2output0input5 5 41 12 23 34 4output3 Note In the first sample test, Okabe can take the path , paying only when moving to (2, 3) and (4, 4). In the fourth sample, Okabe can take the path , paying when moving to (1, 2), (3, 4), and (5, 4). Key 看了好多题解终于写了出来。。。 题意：\(n \times m\)的图中有\(k\)个点，若某每个点周围四个方向有点，则可耗费0代价到达，若某点的周围的上下五行（向上两行，向下两行，当前行）、左右五列也有点，则可耗费1代价到达。求从左上角到右下角的最短路径。 以\(k\)个点建图，可以看见由于和周围5行5列的点均有边，边非常多，所以不能直接连边。在运行时枚举所有周围的点即可。本质上就是一张无负权边的图，用Dijkstra跑即可。 右下角的点\((n,m)\)可能不在\(k\)个结点里，有点难处理，但思路是赋予它一个结点。一开始我跟着一个题解的思路做，他是把右下角的点赋值一个1。还是挺烦的。后来看到一个高级的：若\((n,m)\)不是\(k\)点中之一，则\(++n\)，\(++m\)，再把\((n,m)\)加入为\(k+1\)个点。很巧妙啊。 不要试图开二维数组，哪怕是开了个\(bool vis[10000][10000]\)，也会在第36个案例MLE。一开始不懂，感觉应该不要紧，因为在本地没什么问题。。。结果为此疯狂WA。 既然不能开二维数组，就只能给每个点编号了，于是一共开了三个类，越写越乱。。。也想过用哈希，但对此不是很熟练，不敢写。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;queue&gt;#define INF 0x3f3f3f3f#define mset(a, b) memset(a,b,sizeof(a))#define abs(a) ((a)&gt;0?(a):-(a))using namespace std;const int maxn = (unsigned)1e4 + 10;struct Point &#123; int r, c, d; bool v; bool operator &lt;(const Point &amp;p) const &#123; if (r == p.r) return c &lt; p.c; return r &lt; p.r; &#125;&#125;P[maxn];struct Node &#123; int rc, id;&#125;;struct QNode &#123; int d, id; QNode(int _d, int _id) :d(_d), id(_id) &#123;&#125; bool operator &lt;(const QNode &amp; p) const &#123; return d &gt; p.d; &#125;&#125;;int n, m, k;vector&lt;Node&gt; R[maxn], C[maxn];int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k; bool flg = true; for (int i = 0; i &lt; k; ++i) &#123; auto &amp;now = P[i]; now.d = INF; now.v = false; cin &gt;&gt; now.r &gt;&gt; now.c; if (now.r == n&amp;&amp;now.c == m) &#123; flg = false; &#125; &#125; if (flg) &#123; auto &amp;now = P[k]; now.r = ++n; now.c = ++m; now.d = INF; now.v = false; ++k; &#125; sort(P, P + k); Node nod; for (int i = 0; i &lt; k; ++i) &#123; auto &amp;now = P[i]; nod.id = i; nod.rc = now.c; R[now.r].push_back(nod); nod.rc = now.r; C[now.c].push_back(nod); &#125; priority_queue&lt;QNode&gt; que; P[0].d = 0; que.push(QNode(0, 0)); while (!que.empty()) &#123; auto &amp;now = P[que.top().id]; que.pop(); if (now.v) continue; now.v = true; if (now.r == n&amp;&amp;now.c == m) &#123; cout &lt;&lt; now.d; return 0; &#125; for (int i = -2; i &lt;= 2; ++i) &#123; int r = now.r + i; if (r &gt;= 1 &amp;&amp; r &lt;= n) for (const auto&amp; c : R[r]) &#123; if (abs(i) == 1 &amp;&amp; c.rc == now.c) &#123; if (now.d &lt; P[c.id].d) &#123; P[c.id].d = now.d; que.push(QNode(P[c.id].d, c.id)); &#125; &#125; else if (now.d + 1 &lt; P[c.id].d) &#123; P[c.id].d = now.d + 1; que.push(QNode(P[c.id].d, c.id)); &#125; &#125; int c = now.c + i; if (c &gt;= 1 &amp;&amp; c &lt;= m) for (const auto&amp; r : C[c]) &#123; if (abs(i) == 1 &amp;&amp; r.rc == now.r) &#123; if (now.d &lt; P[r.id].d) &#123; P[r.id].d = now.d; que.push(QNode(P[r.id].d, r.id)); &#125; &#125; else if (now.d + 1 &lt; P[r.id].d) &#123; P[r.id].d = now.d + 1; que.push(QNode(P[r.id].d, r.id)); &#125; &#125; &#125; &#125; cout &lt;&lt; -1; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 420(Div. 2) - E. Okabe and El Psy Kongroo]]></title>
    <url>%2Fposts%2F39928.html</url>
    <content type="text"><![CDATA[Description Okabe likes to take walks but knows that spies from the Organization could be anywhere; that's why he wants to know how many different walks he can take in his city safely. Okabe's city can be represented as all points (x, y) such that x and y are non-negative. Okabe starts at the origin (point (0, 0)), and needs to reach the point (k, 0). If Okabe is currently at the point (x, y), in one step he can go to (x + 1, y + 1), (x + 1, y), or (x + 1, y - 1). Additionally, there are n horizontal line segments, the i-th of which goes from x = a i to x = b i inclusive, and is at y = c i. It is guaranteed that a1 = 0, a n ≤ k ≤ b n, and a i = b i - 1 for 2 ≤ i ≤ n. The i-th line segment forces Okabe to walk with y-value in the range 0 ≤ y ≤ c i when his x value satisfies a i ≤ x ≤ b i, or else he might be spied on. This also means he is required to be under two line segments when one segment ends and another begins. Okabe now wants to know how many walks there are from the origin to the point (k, 0) satisfying these conditions, modulo 109 + 7. Input The first line of input contains the integers n and k (1 ≤ n ≤ 100, 1 ≤ k ≤ 1018) — the number of segments and the destination x coordinate. The next n lines contain three space-separated integers a i, b i, and c i (0 ≤ a i &lt; b i ≤ 1018, 0 ≤ c i ≤ 15) — the left and right ends of a segment, and its y coordinate. It is guaranteed that a1 = 0, a n ≤ k ≤ b n, and a i = b i - 1 for 2 ≤ i ≤ n. Output Print the number of walks satisfying the conditions, modulo 1000000007 (109 + 7). Examples 1234567891011input1 30 3 3output4input2 60 3 03 10 2output4 Note img The graph above corresponds to sample 1. The possible walks are: img The graph above corresponds to sample 2. There is only one walk for Okabe to reach (3, 0). After this, the possible walks are: Key 看了题解才知道矩阵快速幂是这么用的。。。用了之后才知道原来这么简单。。 首先每个点只能向3个方向向右行动，明显的DP问题。 一步步dp肯定不行，要走18次方步呢。使用矩阵快速幂可以针对每一个段计算，一共就最多一百个段。每个段中，每一步将上一步的结果乘以如下矩阵： \[ \left[ \begin{matrix} 1 &amp; 1 &amp; 0 &amp; 0 &amp; ...\\ 1 &amp; 1 &amp; 1 &amp; 0 &amp; ...\\ 0 &amp; 1 &amp; 1 &amp; 1 &amp; ...\\ 0 &amp; 0 &amp; 1 &amp; 1 &amp; ...\\ ... &amp; ... &amp; ... &amp; ... \end{matrix} \right] \] 就得到这一步的dp答案。一个段有\(b_i-a_i\)次dp，即进行\(b_i-a_i\)次幂。 边界处也好处理，若\(c_{i+1}&lt;c_{i}\)，就直接取dp数组的低\(c_{i}\)位结果即可；若\(c_{i+1}&gt;c_{i}\)，dp数组\(c_{i+1}\)以上的高位补0即可。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;typedef long long LL;const int Maxn = 17;const int Pr = 1e9 + 7;struct Matrix &#123; LL n, m; LL mat[Maxn][Maxn]; Matrix() = default; Matrix(LL _n, LL _m) :n(_n), m(_m) &#123;&#125; void Clear() &#123; memset(mat, 0, sizeof(mat)); &#125; Matrix operator +(const Matrix &amp;M) const &#123; Matrix res(n, m); for (LL i = 0; i &lt; n; ++i) for (LL j = 0; j &lt; m; ++j) &#123; res.mat[i][j] = (mat[i][j] + M.mat[i][j]) % Pr; &#125; return res; &#125; Matrix operator *(const Matrix &amp;M) const &#123; if (m != M.n) return Matrix(-1, -1); Matrix res(n, M.m); res.Clear(); for (LL i = 0; i &lt; n; ++i) for (LL j = 0; j &lt; M.m; ++j) &#123; for (LL k = 0; k &lt; m; ++k) &#123; res.mat[i][j] += mat[i][k] * M.mat[k][j]; res.mat[i][j] %= Pr; &#125; &#125; return res; &#125; Matrix operator ^(LL b) const &#123; if (n != m) return Matrix(-1, -1); Matrix a(*this); Matrix res(n, n); res.Clear(); for (LL i = 0; i &lt; n; ++i) res.mat[i][i] = 1; for (; b; b &gt;&gt;= 1) &#123; if (b &amp; 1) &#123; res = a*res; &#125; a = a*a; &#125; return res; &#125; void Print() &#123; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) cout &lt;&lt; mat[i][j] &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125;&#125;;LL N, K;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; N &gt;&gt; K; Matrix pwr(Maxn, Maxn); pwr.Clear(); for (int i = 0; i &lt; Maxn; ++i) &#123; pwr.mat[i][i] = 1; if (i &gt; 0) pwr.mat[i][i - 1] = 1; if (i + 1 &lt; Maxn) pwr.mat[i][i + 1] = 1; &#125; Matrix dp(Maxn, 1); dp.Clear(); dp.mat[0][0] = 1; LL a, b, c; while (N--) &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; ++c; if (b &gt; K) b = K; for (int i = dp.n; i &lt; Maxn; ++i) dp.mat[i][0] = 0; dp.n = c; pwr.n = pwr.m = c; dp = (pwr ^ (b - a)) * dp; &#125; cout &lt;&lt; dp.mat[0][0]; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-14UVa12118 - Inspector's Dilemma]]></title>
    <url>%2Fposts%2F62830.html</url>
    <content type="text"><![CDATA[Desicription In a country, there are a number of cities. Each pair of city is connected by a highway, bi-directional of course. A road-inspector s task is to travel through the highways (in either direction) and to check if everything is in order. Now, a road-inspector has a list of highways he must inspect. However, it might not be possible for him to travel through all the highways on his list without using other highways. He needs a constant amount of time to traverse any single highway. As you can understand, the inspector is a busy fellow does not want to waste his precious time. He needs to know the minimum possible time to complete his task. He has the liberty to start from and end with any city he likes. Please help him out. Input The input file has several test cases. First line of each case has three integers: \(V (1 &lt;= V &lt;= 1000)\), the number of cities, \(E (0 &lt;= E &lt;= V * (V-1) / 2)\), the number of highways the inspector needs to check and$ T (1 &lt;= T &lt;= 10)$, time needed to pass a single highway. Each of the next E lines contains two integers a and b \((1 &lt;= a,b &lt;= V, a!=b)\) meaning the inspector has to check the highway between cities a and b. The input is terminated by a case with \(V=E=T=0\). This case should not be processed. Output For each test case, print the serial of output followed by the minimum possible time the inspector needs to inspect all the highways on his list. Look at the output for sample input for details. Sample Input 123456789105 3 11 21 34 54 4 11 21 42 33 40 0 0 Output 12Case 1: 4Case 2: 4 Key 题意：V个点每个点均可两两相连。现已连E条边，要求添加k条边使得E+k条边组成的图是个欧拉通路。求k。 思路：讲道理V不告诉你都可以，没什么用的条件。在题意里也说的很明白了，要求一个欧拉通路。E条边可组成若干张子图，每张图可能是颗复杂的树、可能是个欧拉通路、可能是个欧拉回路、也可能只是一条孤立的边、一条链。搜索子图个数用DFS即可。 我的思路是，首先把每个子图加边连成一个欧拉通路，然后把所有通路连接。 其中，若子图有大于2个奇数节点（奇数节点必为偶数）则需要额外的\((奇数节点/2-1)\)条边；若子图无奇数节点或只有2个，则无需额外边。 另外，连接n个通路需要n-1条边。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//UVa12118 - Inspector's Dilemma//Accepted 0.070s#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;int V, E, T;int Case = 0;map&lt;int, vector&lt;int&gt; &gt; mp;bool vis[1010];int num;void DFS(int idx) &#123; if (vis[idx]) return; vis[idx] = true; if (mp[idx].size() &amp; 1) ++num; for (auto &amp;e : mp[idx]) &#123; DFS(e); &#125;&#125;int main()&#123; ios::sync_with_stdio(false); while ((cin &gt;&gt; V &gt;&gt; E &gt;&gt; T)&amp;&amp;(V+E+T)) &#123; memset(vis, 0, sizeof(vis)); mp.clear(); int u, v; for (int i = 0; i &lt; E; ++i) &#123; cin &gt;&gt; u &gt;&gt; v; mp[u].push_back(v); mp[v].push_back(u); &#125; int res = -1; for (auto &amp;e : mp) &#123; if (vis[e.first]) continue; num = 0; DFS(e.first); if (num == 0) num = 2; res += num/2; &#125; if (res &lt; 0) res = 0; cout &lt;&lt; "Case " &lt;&lt; ++Case &lt;&lt; ": " &lt;&lt; T*(res + E) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 393(Div. 2) - A. Petr and a calendar]]></title>
    <url>%2Fposts%2F39925.html</url>
    <content type="text"><![CDATA[Description Petr wants to make a calendar for current month. For this purpose he draws a table in which columns correspond to weeks (a week is seven consequent days from Monday to Sunday), rows correspond to weekdays, and cells contain dates. For example, a calendar for January 2017 should look like on the picture: img Petr wants to know how many columns his table should have given the month and the weekday of the first date of that month? Assume that the year is non-leap. Input The only line contain two integers m and d (1 ≤ m ≤ 12, 1 ≤ d ≤ 7) — the number of month (January is the first month, December is the twelfth) and the weekday of the first date of this month (1 is Monday, 7 is Sunday). Output Print single integer: the number of columns the table should have. Examples 123456789101112input1 7output6input1 1output5input11 6output5 Note The first example corresponds to the January 2017 shown on the picture in the statements. In the second example 1-st January is Monday, so the whole month fits into 5 columns. In the third example 1-st November is Saturday and 5 columns is enough. Key 写过的最短的题哈哈哈，贴上来以表纪念。其中用到了老司机教我的除法向上取整的方法。 Code 12345678#include&lt;iostream&gt;int m, d;const int D[] = &#123; 0,31,28,31,30,31,30,31,31,30,31,30,31 &#125;;int main()&#123; std::cin &gt;&gt; m &gt;&gt; d; std::cout &lt;&lt; (D[m] + (d - 1) - 1) / 7 + 1;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 389(Div. 2) - D. Santa Claus and a Palindrome]]></title>
    <url>%2Fposts%2F39924.html</url>
    <content type="text"><![CDATA[Description Santa Claus likes palindromes very much. There was his birthday recently. k of his friends came to him to congratulate him, and each of them presented to him a string si having the same length n. We denote the beauty of the i-th string by ai. It can happen that ai is negative — that means that Santa doesn't find this string beautiful at all. Santa Claus is crazy about palindromes. He is thinking about the following question: what is the maximum possible total beauty of a palindrome which can be obtained by concatenating some (possibly all) of the strings he has? Each present can be used at most once. Note that all strings have the same length n. Recall that a palindrome is a string that doesn't change after one reverses it. Since the empty string is a palindrome too, the answer can't be negative. Even if all ai's are negative, Santa can obtain the empty string. Input The first line contains two positive integers k and n divided by space and denoting the number of Santa friends and the length of every string they've presented, respectively (1 ≤ k, n ≤ 100 000; n·k ≤ 100 000). k lines follow. The i-th of them contains the string si and its beauty ai ( - 10 000 ≤ ai ≤ 10 000). The string consists of n lowercase English letters, and its beauty is integer. Some of strings may coincide. Also, equal strings can have different beauties. Output In the only line print the required maximum possible beauty. Examples 123456789101112131415161718192021222324input7 3abb 2aaa -3bba -1zyz -4abb 5aaa 7xyx 4output12input3 1a 1a 2a 3output6input2 5abcde 10000abcde 10000output0 Note In the first example Santa can obtain abbaaaxyxaaabba by concatenating strings 5, 2, 7, 6 and 3 (in this order). Key 给出若干等长字符串与其对应价值（可重复，重复的字符串价值可不同），从字符串中选出若干字符串，组成一个回文串，问最大价值多少。 一个字符串要被使用，就必须有对应的逆序字符串，比如要使用abb，就必须有对应的bba。先预处理将重复字符串的价值们放在数组里从大到小排列。对于abb、bba式的自身非回文的串很简单，只要两两价值相加大于零就选中（贪心）。 对于aba式的自身就是回文的，可以选择如上的成对出现，也可以选择放在正中间（然而最多只能有一个放在目标回文串的正中间，为了方便描述称其为“中间串”）。首先成对的处理，两两价值相加大于零就选中（贪心）。若该串重复的个数为奇数，可能有唯一落单的正价值，将其成为“中间串”候补。但还有个有问题，比如输入： 1232 3aba 5aba -1 两者结合结果为4，大于0。但是此处只选择第一个更优。因而当成对串的第二个串为负时，第一个串也成为“中间串”候补。 以上两种成为“中间串”候补的情况，对于第一种情况：若选中，则总价值+=该串价值。 对于第二种情况：若选中，则\(V_{总}-=V_{该串对应的负价值串}\)，即\(V_{总}+=-V_{该串对应的负价值串}\)。 则找出最大的\(|V_{候补串}|\)或\(|V_{候补串对应的负价值串}|\)即可。若没有候补串就不要中间串了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;int k, n;map&lt;string, vector&lt;int&gt; &gt; mp;char sp[100000];void pal(string s) &#123; int idx = n; for (const auto&amp; c : s) &#123; sp[--idx] = c; &#125; sp[n] = '\0';&#125;bool cmp(int a, int b) &#123; return a &gt; b;&#125;int main()&#123; cin &gt;&gt; k &gt;&gt; n; for (int i = 0; i &lt; k; ++i) &#123; string s; int v; cin &gt;&gt; s &gt;&gt; v; mp[s].push_back(v); &#125; int res = 0; int mid = 0; for (auto &amp;e : mp) &#123; vector&lt;int&gt; &amp;now = e.second; if (now.empty()) continue; sort(now.begin(), now.end(), cmp); pal(e.first); if (e.first == sp) &#123; int l = now.size(); int i; for (i = 0; i &lt; l - 1; i += 2) &#123; if (now[i] + now[i + 1] &lt;= 0) break; res += now[i] + now[i + 1]; &#125; if (i &amp;&amp; i-1&lt;l &amp;&amp; now[i - 1] &lt; 0) &#123; mid = max(-now[i - 1], mid); &#125; else if(i&lt;l) &#123; mid = max(now[i],mid); &#125; &#125; else &#123; vector&lt;int&gt; &amp;nxt = mp[sp]; sort(nxt.begin(), nxt.end(), cmp); int l = min(nxt.size(), now.size()); for (int i = 0; i &lt; l; ++i) &#123; if (nxt[i] + now[i] &lt;= 0) break; res += nxt[i] + now[i]; &#125; nxt.clear(); &#125; &#125; cout &lt;&lt; res + mid; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round 412(Div. 2) - C. Success Rate]]></title>
    <url>%2Fposts%2F39926.html</url>
    <content type="text"><![CDATA[PROBLEMSET里面神tm搜不到这题，很迷。所以标题就只好注明比赛出处而没法标明题号了。 Description You are an experienced Codeforces user. Today you found out that during your activity on Codeforces you have made y submissions, out of which x have been successful. Thus, your current success rate on Codeforces is equal to x / y. Your favorite rational number in the [0;1] range is p / q. Now you wonder: what is the smallest number of submissions you have to make if you want your success rate to be p / q? Input The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of test cases. Each of the next t lines contains four integers x, y, p and q (0 ≤ x ≤ y ≤ 109; 0 ≤ p ≤ q ≤ 109; y &gt; 0; q &gt; 0). It is guaranteed that p / q is an irreducible fraction. Hacks. For hacks, an additional constraint of t ≤ 5 must be met. Output For each test case, output a single integer equal to the smallest number of submissions you have to make if you want your success rate to be equal to your favorite rational number, or -1 if this is impossible to achieve. Example 1234567891011input43 10 1 27 14 3 820 70 2 75 6 1 1output4100-1 Note In the first example, you have to make 4 successful submissions. Your success rate will be equal to 7 / 14, or 1 / 2. In the second example, you have to make 2 successful and 8 unsuccessful submissions. Your success rate will be equal to 9 / 24, or 3 / 8. In the third example, there is no need to make any new submissions. Your success rate is already equal to 20 / 70, or 2 / 7. In the fourth example, the only unsuccessful submission breaks your hopes of having the success rate equal to 1. Key 给你参加的总场次\(y\)与其中胜利的场次\(x\)，现要求胜率达到\(p/q\)，问还要再比多少场（每一场可胜可负）。 想明白了其实是个巨简单的题目。为了达到目标，比赛的总场次必为\(q\)的倍数（现设倍数为\(k\)），则\(k*q&gt;=y\)；在比了\(k*q\)场次的情况下，必须胜利\(k*p\)次，则\(k*p&gt;=x\)。胜利的场数肯定不大于总场数，则只要找到\(k*p-x&lt;=k*q-y\)的最小k即获得了答案。 综合一下三个条件，找出满足以下条件的k的最小值： 123k&gt;=y/q;k&gt;=x/p;k&gt;=(y-x)/(q-p); 即\(k=max(y/q, x/p, (y-x)/(q-p))\)。其中除法结果若为小数则向上取整。 因此\(O(1)\)时间复杂度即可求出。 至于无法达到的情况，只有\(x/y\)不为0而\(p/q\)为0、或\(x/y\)不为1而\(p/q\)为1两种。一开始判断掉就行。 Code 1234567891011121314151617181920212223242526#include&lt;iostream&gt;using namespace std;typedef long long LL;LL T, x, y, p, q;int main()&#123; cin &gt;&gt; T; while (T--) &#123; cin &gt;&gt; x &gt;&gt; y &gt;&gt; p &gt;&gt; q; if (x*q == p*y) &#123; cout &lt;&lt; "0\n"; continue; &#125; if (p == 0 || p == q) &#123; cout &lt;&lt; "-1\n"; continue; &#125; LL k = (y - x - 1) / (q - p) +1; if (k*p &lt; x) k = (x - 1) / p + 1; if (k*q &lt; y) k = (y - 1) / q + 1; LL res = k*q - y; cout &lt;&lt; res &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 815A - Karen and Game]]></title>
    <url>%2Fposts%2F17492.html</url>
    <content type="text"><![CDATA[千年两小时只写出2题，这次终于把C题写出来了。。。 Description On the way to school, Karen became fixated on the puzzle game on her phone! The game is played as follows. In each level, you have a grid with n rows and m columns. Each cell originally contains the number 0. One move consists of choosing one row or column, and adding 1 to all of the cells in that row or column. To win the level, after all the moves, the number in the cell at the i-th row and j-th column should be equal to gi, j. Karen is stuck on one level, and wants to know a way to beat this level using the minimum number of moves. Please, help her with this task! Input The first line of input contains two integers, n and m (1 ≤ n, m ≤ 100), the number of rows and the number of columns in the grid, respectively. The next n lines each contain m integers. In particular, the j-th integer in the i-th of these rows contains gi, j (0 ≤ gi, j ≤ 500). Output If there is an error and it is actually not possible to beat the level, output a single integer -1. Otherwise, on the first line, output a single integer k, the minimum number of moves necessary to beat the level. The next k lines should each contain one of the following, describing the moves in the order they must be done: row x, (1 ≤ x ≤ n) describing a move of the form &quot;choose the x-th row&quot;. col x, (1 ≤ x ≤ m) describing a move of the form &quot;choose the x-th column&quot;. If there are multiple optimal solutions, output any one of them. Examples 12345678910111213141516171819202122232425262728input3 52 2 2 3 20 0 0 1 01 1 1 2 1output4row 1row 1col 4row 3input3 30 0 00 1 00 0 0output-1input3 31 1 11 1 11 1 1output3row 1row 2row 3 Note In the first test case, Karen has a grid with 3 rows and 5 columns. She can perform the following 4 moves to beat the level: In the second test case, Karen has a grid with 3 rows and 3 columns. It is clear that it is impossible to beat the level; performing any move will create three 1s on the grid, but it is required to only have one 1 in the center. In the third test case, Karen has a grid with 3 rows and 3 columns. She can perform the following 3 moves to beat the level: Note that this is not the only solution; another solution, among others, is col 1, col 2, col 3. Key 有一个有n*m个单元的、每个单元填有数字的网格，每次操作可将某一整行、一整列的单元数值-1，问最少进行多少次操作可以将网格所有单元减到0。 模拟。对每一行/列模拟即可。对于3*5的网格，如果要把每一个单元的数值-1，按行减，要3次，按列减，要5次。所以模拟的时候肯定是优先按行数/列数小的那一个开始减，每次减到该行/列出现0则无法再减，跳转下一行/列。模拟到最后遍历一遍查看有没有个别单元无法减到0，若有则输出-1。 Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int n, m;int arr[123][123];int minr[123], minc[123];int main()&#123; ios::sync_with_stdio(false); memset(minr, 1, sizeof(minr)); memset(minc, 1, sizeof(minc)); cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; int &amp;now = arr[i][j]; cin &gt;&gt; now; if (minr[i] &gt; now) minr[i] = now; if (minc[j] &gt; now) minc[j] = now; &#125; &#125; int res = 0; if (n &lt;= m) &#123; int rminr = 9999999; for (int i = 0; i &lt; n; ++i) &#123; res += minr[i]; if (rminr &gt; minr[i]) rminr = minr[i]; &#125; for (int i = 0; i &lt; m; ++i) &#123; res += (minc[i] -= rminr); &#125; &#125; else &#123; int cminc = 9999999; for (int i = 0; i &lt; m; ++i) &#123; res += minc[i]; if (cminc &gt; minc[i]) cminc = minc[i]; &#125; for (int i = 0; i &lt; n; ++i) &#123; res += (minr[i] -= cminc); &#125; &#125; for (int i = 0; i &lt; n; ++i) &#123; for (int j = 0; j &lt; m; ++j) &#123; if (arr[i][j] - minr[i] - minc[j]) &#123; cout &lt;&lt; "-1\n"; return 0; &#125; &#125; &#125; cout &lt;&lt; res &lt;&lt; '\n'; for (int i = 0; i &lt; n; ++i) &#123; while (minr[i]--) cout &lt;&lt; "row " &lt;&lt; (i + 1) &lt;&lt; '\n'; &#125; for (int i = 0; i &lt; m; ++i) &#123; while (minc[i]--) cout &lt;&lt; "col " &lt;&lt; (i + 1) &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 816B - Karen and Coffee]]></title>
    <url>%2Fposts%2F59704.html</url>
    <content type="text"><![CDATA[Description To stay woke and attentive during classes, Karen needs some coffee! Karen, a coffee aficionado, wants to know the optimal temperature for brewing the perfect cup of coffee. Indeed, she has spent some time reading several recipe books, including the universally acclaimed &quot;The Art of the Covfefe&quot;. She knows n coffee recipes. The i-th recipe suggests that coffee should be brewed between li and ri degrees, inclusive, to achieve the optimal taste. Karen thinks that a temperature is admissible if at least k recipes recommend it. Karen has a rather fickle mind, and so she asks q questions. In each question, given that she only wants to prepare coffee with a temperature between a and b, inclusive, can you tell her how many admissible integer temperatures fall within the range? Input The first line of input contains three integers, n, k (1 ≤ k ≤ n ≤ 200000), and q (1 ≤ q ≤ 200000), the number of recipes, the minimum number of recipes a certain temperature must be recommended by to be admissible, and the number of questions Karen has, respectively. The next n lines describe the recipes. Specifically, the i-th line among these contains two integers li and ri (1 ≤ li ≤ ri ≤ 200000), describing that the i-th recipe suggests that the coffee be brewed between li and ri degrees, inclusive. The next q lines describe the questions. Each of these lines contains a and b, (1 ≤ a ≤ b ≤ 200000), describing that she wants to know the number of admissible integer temperatures between a and b degrees, inclusive. Output For each question, output a single integer on a line by itself, the number of admissible integer temperatures between a and b degrees, inclusive. Examples 123456789101112131415161718192021input3 2 491 9492 9797 9992 9493 9795 9690 100output3304input2 1 11 1200000 20000090 100output0 Note In the first test case, Karen knows 3 recipes. The first one recommends brewing the coffee between 91 and 94 degrees, inclusive. The second one recommends brewing the coffee between 92 and 97 degrees, inclusive. The third one recommends brewing the coffee between 97 and 99 degrees, inclusive. A temperature is admissible if at least 2 recipes recommend it. She asks 4 questions. In her first question, she wants to know the number of admissible integer temperatures between 92 and 94 degrees, inclusive. There are 3: 92, 93 and 94 degrees are all admissible. In her second question, she wants to know the number of admissible integer temperatures between 93 and 97 degrees, inclusive. There are 3: 93, 94 and 97 degrees are all admissible. In her third question, she wants to know the number of admissible integer temperatures between 95 and 96 degrees, inclusive. There are none. In her final question, she wants to know the number of admissible integer temperatures between 90 and 100 degrees, inclusive. There are 4: 92, 93, 94 and 97 degrees are all admissible. In the second test case, Karen knows 2 recipes. The first one, &quot;wikiHow to make Cold Brew Coffee&quot;, recommends brewing the coffee at exactly 1 degree. The second one, &quot;What good is coffee that isn't brewed at at least 36.3306 times the temperature of the surface of the sun?&quot;, recommends brewing the coffee at exactly 200000 degrees. A temperature is admissible if at least 1 recipe recommends it. In her first and only question, she wants to know the number of admissible integer temperatures that are actually reasonable. There are none. Key 输入若干闭区间，闭区间内每个整数点的Value+1。输入若干查询，查询在某个区间内的所有整数点Value&gt;=k的个数。 一开始预处理的时候比较傻。。。由于预处理的原因TLE了两次。开始我用了树状树组，基友们也是有用线段树的、有用差分数组的、前缀和的。超时了两次后最后我也换回了用前缀和（但是又超时了一次。。。预处理部分写的太无脑了。没有想到数据量这么大）。 Code 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int maxn = 200000;int n, k, q;int A[maxn + 233];int main()&#123; ios::sync_with_stdio(false); memset(A, 0, sizeof(A)); cin &gt;&gt; n &gt;&gt; k &gt;&gt; q; int in1, in2; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; in1 &gt;&gt; in2; ++A[in1]; --A[in2 + 1]; &#125; for (int i = 1; i &lt;= maxn; ++i) A[i] += A[i - 1]; for (int i = 1; i &lt;= maxn; ++i) A[i] = A[i - 1] + (A[i] &gt;= k ? 1 : 0); while (q--) &#123; cin &gt;&gt; in1 &gt;&gt; in2; cout &lt;&lt; A[in2] - A[in1 - 1] &lt;&lt; '\n'; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-11UVa10410 6-13UVa215]]></title>
    <url>%2Fposts%2F54931.html</url>
    <content type="text"><![CDATA[最近刷题量大，不高兴写题解了。以后算竟的题目可能只是跳着做做了。 题目：6-11 UVa10410 - Tree Reconstruction 1234567891011121314151617181920212223242526272829303132333435363738394041424344//UVa10410 - Tree Reconstruction//Accepted 0.000s#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;vector&gt;using namespace std;const int maxn = 1000 + 6;int n, bfs[maxn];int main()&#123; while (cin &gt;&gt; n) &#123; int now; for (int i = 0; i &lt; n; ++i) &#123; cin &gt;&gt; now; bfs[now] = i; &#125; stack&lt;int&gt; st; vector&lt;int&gt; vc[maxn]; cin &gt;&gt; now; st.push(now); for (int i = 1; i &lt; n; ++i)&#123; cin &gt;&gt; now; while (!st.empty()) &#123; int top = st.top(); if (bfs[now] &gt; bfs[top]+1 || st.size()==1) &#123; vc[top].push_back(now); st.push(now); break; &#125; else &#123; st.pop(); &#125; &#125; &#125; for (int i = 1; i &lt;= n; ++i) &#123; cout &lt;&lt; i &lt;&lt; ": "; for (const auto&amp; e : vc[i]) cout &lt;&lt; e &lt;&lt; ' '; cout &lt;&lt; '\n'; &#125; &#125; return 0;&#125; 题目：6-13 UVa215 - Spreadsheet Calculator 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//UVa215 - Spreadsheet Calculator//Accepted 0.000s#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;cstring&gt;using namespace std;int N, M;int vl[24][14]; //valuestring xp[24][14]; //exprbool ve[24][14]; //kindbool vis[24][14];int val(int x, int y) &#123; if (ve[x][y]) return vl[x][y]; if (vis[x][y]) return -1; int op = 1; vl[x][y] = 0; vis[x][y] = true; string &amp;now = xp[x][y]; for (int i = 0; i &lt; xp[x][y].size(); ++i) &#123; if (now[i] &gt;= '0'&amp;&amp;now[i] &lt;= '9') &#123; int tmp = 0; while (now[i] &gt;= '0'&amp;&amp;now[i] &lt;= '9') &#123; tmp *= 10; tmp += now[i] - 0x30; ++i; &#125; --i; vl[x][y] += tmp*op; &#125; else if (now[i] &gt;= 'A'&amp;&amp;now[i] &lt;= 'Z') &#123; vl[x][y] += val(now[i] - 'A', now[i + 1] - '0')*op; if (!ve[now[i] - 'A'][now[i + 1] - '0']) return -1; ++i; &#125; else &#123; op = (now[i] == '+' ? 1 : -1); &#125; &#125; ve[x][y] = 1; return vl[x][y];&#125;int main()&#123; //freopen("in.txt", "r", stdin);//---------------------------------- while (cin &gt;&gt; N &gt;&gt; M &amp;&amp; N != 0 &amp;&amp; M != 0) &#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; cin &gt;&gt; xp[i][j]; if (xp[i][j][0] &gt;= 'A'&amp;&amp;xp[i][j][0] &lt;= 'Z') &#123; ve[i][j] = false; &#125; else &#123; ve[i][j] = true; istringstream in(xp[i][j]); in &gt;&gt; vl[i][j]; &#125; &#125; &#125; int cnt = 0; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (ve[i][j]) continue; memset(vis, 0, sizeof(vis)); val(i, j); if (!ve[i][j]) ++cnt; &#125; &#125; if (cnt) &#123; for (int i = 0; i &lt; N; ++i) &#123; for (int j = 0; j &lt; M; ++j) &#123; if (ve[i][j]) continue; cout &lt;&lt; char(i + 'A') &lt;&lt; char(j + '0') &lt;&lt; ": " &lt;&lt; xp[i][j] &lt;&lt; '\n'; &#125; &#125; &#125; else &#123; cout &lt;&lt; ' '; for (int i = 0; i &lt; M; ++i) cout &lt;&lt; setw(6) &lt;&lt; i; cout &lt;&lt; '\n'; for (int i = 0; i &lt; N; ++i) &#123; cout &lt;&lt; char('A' + i); for (int j = 0; j &lt; M; ++j) cout &lt;&lt; setw(6) &lt;&lt; vl[i][j]; cout &lt;&lt; '\n'; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 811C - Vladik and Memorable Trip]]></title>
    <url>%2Fposts%2F25981.html</url>
    <content type="text"><![CDATA[哇咔咔，终于期末考完啦，终于放暑假啦，我终于又有时间学习啦！！(o゜▽゜)o☆ Description Vladik often travels by trains. He remembered some of his trips especially well and I would like to tell you about one of these trips: Vladik is at initial train station, and now n people (including Vladik) want to get on the train. They are already lined up in some order, and for each of them the city code ai is known (the code of the city in which they are going to). Train chief selects some number of disjoint segments of the original sequence of people (covering entire sequence by segments is not necessary). People who are in the same segment will be in the same train carriage. The segments are selected in such way that if at least one person travels to the city x, then all people who are going to city x should be in the same railway carriage. This means that they can’t belong to different segments. Note, that all people who travel to the city x, either go to it and in the same railway carriage, or do not go anywhere at all. Comfort of a train trip with people on segment from position l to position r is equal to XOR of all distinct codes of cities for people on the segment from position l to position r. XOR operation also known as exclusive OR. Total comfort of a train trip is equal to sum of comfort for each segment. Help Vladik to know maximal possible total comfort. Input First line contains single integer n (1 ≤ n ≤ 5000) — number of people. Second line contains n space-separated integers a1, a2, ..., an (0 ≤ ai ≤ 5000), where ai denotes code of the city to which i-th person is going. Output The output should contain a single integer — maximal possible total comfort. Examples 12345678910input64 4 2 5 2 3output14input95 1 3 1 5 2 4 2 5output9 Note In the first test case best partition into segments is: \([4, 4][2, 5, 2] [3]\), answer is calculated as follows: \(4 + (2 xor 5) + 3 = 4 + 7 + 3 = 14\) In the second test case best partition into segments is:$ 5 1 [3] 1 5 [2, 4, 2] 5$, answer calculated as follows: \(3 + (2 xor 4) = 3 + 6 = 9\). Key 给一个n个元素（可含有重名元素）的序列，按照原来的顺序分割出若干段，要求所有重名元素要么全部出现在一个段里，要么全部不在段里。问分割出的所有段的价值和。其中每个段的价值为段内所有不同名元素按照名字的二进制异或。 明显的DP问题，但当时还是没写出来。。。果然一个月没写就生疏了。 当时就觉得这个异或有猫腻。什么意思呢？对于两个二进制数\(x\)和\(y\)，\(x+y \geq x \oplus y\)（就相当于异或比加法少一个进位情况）。也就是说，每个段中不同名的元素越少越好。 先预处理一下，每种元素只需要知道其最左侧与最右侧的元素位置即可。 对于这个序列中的每一个元素：有选中与不选中（或无法选中）两种情况。若试图选中当前元素，则要求出包含此类元素的段的最小区间\([l, r]\)及其价值\(Value\)。若\(r\)大于当前元素位置，则不选中，\(DP_{i} \gets DP_{i - 1}\)；否则\(DP_{i} \gets max(DP_{i - 1}, DP_{l - 1} + Value)\)。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define l(t) s[t][0]#define r(t) s[t][1]using namespace std;const int maxn = 5000 + 10;int n;int a[maxn];int s[maxn][2];int tv[maxn];int dp[maxn];bool vis[maxn];int main()&#123; memset(s, 0, sizeof(s)); memset(tv, 0, sizeof(tv)); cin &gt;&gt; n; for (int i = 1; i &lt;= n; ++i) &#123; cin &gt;&gt; a[i]; if (!l(a[i])) l(a[i]) = i; r(a[i]) = i; &#125; dp[0] = 0; for (int i = 1; i &lt;= n; ++i) &#123; dp[i] = dp[i - 1]; if (r(a[i]) &gt; i) continue; int val = a[i]; int ml = l(a[i]); memset(vis, 0, sizeof(vis)); vis[a[i]] = true; int j; for (j = i; j &gt; ml; --j) &#123; if (vis[a[j]]) continue; vis[a[j]] = true; if (r(a[j]) &gt; i) break; if (l(a[j]) &lt; ml) ml = l(a[j]); val ^= a[j]; &#125; if (j == ml) dp[i] = max(dp[i - 1], val + dp[j - 1]); &#125; cout &lt;&lt; dp[n]; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 758C - Unfair Poll]]></title>
    <url>%2Fposts%2F645.html</url>
    <content type="text"><![CDATA[Description On the Literature lesson Sergei noticed an awful injustice, it seems that some students are asked more often than others. Seating in the class looks like a rectangle, where n rows with m pupils in each. The teacher asks pupils in the following order: at first, she asks all pupils from the first row in the order of their seating, then she continues to ask pupils from the next row. If the teacher asked the last row, then the direction of the poll changes, it means that she asks the previous row. The order of asking the rows looks as follows: the 1-st row, the 2-nd row, ..., the n - 1-st row, the n-th row, the n - 1-st row, ..., the 2-nd row, the 1-st row, the 2-nd row, ... The order of asking of pupils on the same row is always the same: the 1-st pupil, the 2-nd pupil, ..., the m-th pupil. During the lesson the teacher managed to ask exactly k questions from pupils in order described above. Sergei seats on the x-th row, on the y-th place in the row. Sergei decided to prove to the teacher that pupils are asked irregularly, help him count three values: the maximum number of questions a particular pupil is asked, the minimum number of questions a particular pupil is asked, how many times the teacher asked Sergei. If there is only one row in the class, then the teacher always asks children from this row. Input The first and the only line contains five integers n, m, k, x and y (1 ≤ n, m ≤ 100, 1 ≤ k ≤ 1018, 1 ≤ x ≤ n, 1 ≤ y ≤ m). Output Print three integers: the maximum number of questions a particular pupil is asked, the minimum number of questions a particular pupil is asked, how many times the teacher asked Sergei. # Examples 12345678910111213141516input1 3 8 1 1output3 2 3input4 2 9 4 2output2 1 1input5 5 25 4 3output1 1 1input100 100 1000000000000000000 100 100output101010101010101 50505050505051 50505050505051 Note The order of asking pupils in the first test: the pupil from the first row who seats at the first table, it means it is Sergei; the pupil from the first row who seats at the second table; the pupil from the first row who seats at the third table; the pupil from the first row who seats at the first table, it means it is Sergei; the pupil from the first row who seats at the second table; the pupil from the first row who seats at the third table; the pupil from the first row who seats at the first table, it means it is Sergei; the pupil from the first row who seats at the second table; The order of asking pupils in the second test: the pupil from the first row who seats at the first table; the pupil from the first row who seats at the second table; the pupil from the second row who seats at the first table; the pupil from the second row who seats at the second table; the pupil from the third row who seats at the first table; the pupil from the third row who seats at the second table; the pupil from the fourth row who seats at the first table; the pupil from the fourth row who seats at the second table, it means it is Sergei; the pupil from the third row who seats at the first table; Key 如此简单的题目竟然当时没做出来，心态爆炸。死在了边界和自作聪明上。 每个人从0开始编号，即0~m-1，以便于取模运算等。以提问第\(1, 2, 3, ....., n-1, n, n-1, ...4, 3, 2\)排的所有人为一轮，提问次数记为round，计算出除了最后一轮外一共的轮数rounds以及最后一轮被提问的最后一个人的位置。 若n=1或者n=2，单独考虑，此时相当于每一个人在每一轮里只被问了一遍。否则： 当最后一个人在第一排，则最小值为rounds，最大值为max(rounds+1,2*rounds)，讨论Sergei有没有在最后一轮被提问且Sergei是不是第一排或最后一排的； 当最后一个人在第一排与最后一排之间且是第一次被提问，则最小值为rounds，最大值为2*rounds+1，讨论Sergei有没有在最后一轮被提问且Sergei是不是第一排或最后一排的； 当最后一个人在最后一排且不是最后一排最后一个人，则最小值为rounds，最大值为2*rounds+1，一样的还是要讨论Sergei情况； 当最后一个人在最后一排最后一个人时，则最小值为rounds+1，最大值为2*rounds+1，一样的还是要讨论Sergei情况； 当最后一个人在从后向前提问顺序（即第二次被提问）时，则最小值为rounds+1，最大值为2*rounds+2，一样的还是要讨论Sergei情况； 所以可能性还是稍微有点复杂的，尤其是讨论Sergei在不在第一排或最后一排的问题上。我还吃力不讨好地在一两种情况上面把完全不耗时间的(x == 1 || x == n) ? :优化成(x == 1) ? :与(x == n) ? :，结果就优化出问题了。你说我何必呢。。。 最气的是，网上看到的题解都是模拟。。。二维数组一开，美滋滋。。。心态崩了。 Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;LL n, m, k, x, y;LL maxn, minn, midn;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; x &gt;&gt; y; --k; LL round = (n == 1 ? m : (2 * n - 2)*m); LL rounds = k / round; LL last = k % round; if (n &lt; 3) &#123; maxn = rounds + 1; minn = ((last == round - 1) ? rounds + 1 : rounds); midn = ((x - 1)*m + y - 1 &gt; last ? minn : maxn); &#125; else &#123; maxn = rounds * 2; minn = rounds; if (last &lt; m) &#123; maxn = max(rounds * 2, rounds + 1); if ((x - 1)*m + y - 1 &gt; last) midn = ((x == 1 || x == n) ? rounds : rounds * 2); else midn = rounds + 1; &#125; else if (last &lt; m*(n - 1)) &#123; ++maxn; if ((x - 1)*m + y - 1 &gt; last) midn = ((x == n) ? rounds : rounds * 2); else midn = ((x == 1) ? rounds + 1 : rounds * 2 + 1); &#125; else if (last &lt; m*n) &#123; ++maxn; if (last == m*n - 1)++minn; if ((x - 1)*m + y - 1 &gt; last) midn = rounds; else midn = ((x == 1 || x == n) ? rounds + 1 : rounds * 2 + 1); &#125; else &#123; maxn += 2; ++minn; if (n*m + (n - x - 1)*m + y - 1 &gt; last) midn = ((x == 1 || x == n) ? rounds + 1 : rounds * 2 + 1); else midn = ((x == 1 || x == n) ? rounds + 1 : rounds * 2 + 2); &#125; &#125; cout &lt;&lt; maxn &lt;&lt; ' ' &lt;&lt; minn &lt;&lt; ' ' &lt;&lt; midn; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM ICPC 2016北京赛站网络赛 D - Pick Your Players]]></title>
    <url>%2Fposts%2F51300.html</url>
    <content type="text"><![CDATA[Description You are the manager of a small soccer team. After seeing the shameless behavior of your team during the match, you are mad at all of the current players. Therefore, you have made a huge decision: put these players on the substitution bench, and buy the entire starting line-up from other teams. You have received a list of available players from your assistant manager. Each player has three properties: Position, Value, and Cost. The Position of a player is one of the four kinds: Goalkeeper, Defender, Midfielder and Forward. The Value shows the ability of the player (the higher, the better), and the Cost is the money you need to spend to buy him. You are going to pick some players to buy from the list, in order to form the starting line-up. Several rules should be followed: The starting line-up consists of exactly eleven players. There should be exactly one Goalkeeper, at least three but at most five Defenders, at least two but at most five Midfielders, and at least one but at most three Forwards in the starting line-up. There should be exactly one captain in the starting line-up.The captain must be chosen from the eleven players. The total value of the starting line-up is the sum of the Values of picked players plus the Value of the captain. In another word, the Value of the captain is counted twice. The total cost of the starting line-up is the sum of the Costs of picked players, which should not exceed the given cost limitation. Now you have to give a plan to your boss before taking the actual actions. In the plan, you should report three numbers which your boss really interests in: Vt, Ct, N, where Vt is the maximum total value you can get; Ct is the minimum total cost when the total value is Vt; And N is the number of different ways to pick players when the total value is Vt and the total cost is Ct. Since your boss does not care the precise number of N if it is larger than 1,000,000,000, just report N = 1,000,000,000 when that happens. Note that if two or more ways that pick the same eleven players and are only different in captain chosen, they should be regarded as the same. Input There are several test cases in the input. The first line contains an integer T (1 &lt;= T &lt;= 10) -- the number of test cases. For each case: The first line contains an integer M (11 &lt;= M &lt;= 500) -- the number of players on the list. Then follows M lines, each line contains a string P and two integers V and C (0 &lt;= V &lt;= 1000, 0 &lt;= C &lt;= 1000), separated by a single space, describing the properties of a player. P is the position of the player, which is one of the strings “Goalkeeper”, “Defender”, “Midfielder”, and “Forward”; V is the Value of the player and C is the Cost of the player. The last line contains an integer L (0 &lt;= L &lt;= 1000) -- the cost limitation. Output For each test case, output three integers Vt, Ct and N on a single line, separated by a single space. We assure that there is at least one possible way to pick your players. Note In the sample, you should pick all five Defenders, four Midfielders with Value 178, 20, 64 and 109, one Forward with Value 6, and one of two Goalkeepers with Value 57. The Midfielder with Value 178 should be the captain. Sample input 123456789101112131415161718115Defender 23 45Midfielder 178 85Goalkeeper 57 50Goalkeeper 57 50Defender 0 45Forward 6 60Midfielder 20 50Goalkeeper 0 50Midfielder 64 65Midfielder 109 70Forward 211 100Defender 0 40Defender 29 45Midfielder 57 60Defender 52 45600 output 1716 600 2 Key 来自ICPCCamp.Post的题解： &gt;题意：你需要买一个足球队（11个球员），每个球员有位置、价值。花费，有以下限制： 位置分为前锋（1-3人）、中腰（2-5）、后卫（3-5）、守门员（1） 每个人有value，总的value 是每个人的value加起来 ，选一个队长，队长的加两次 每个人有个 cost，总花费不能超过给定值 求：最大的 value，相应的最小的 cost，相应的购买方案数（大于1e9输出1e9） 10组数据，500个候选人，value和cost：V and C (0 &lt;= V &lt;= 1000, 0 &lt;= C &lt;= 1000)，花费上界：1000 题解：考虑dp(i,cost,j,k,r,w)=(value,way)表示考虑前ii个球员，费用和为cost，选了j个前锋kk个中腰r个后卫w个守门员这个状态，价值和是value,方案数是way。然后按照dp字面意思转移就可以了。然后第一维的ii这里是为了看起来方便，其实是不用开的。 为了方便处理队长，把球员们按照价值从大到小排序，挑的第一个人当队长就可以了。 不太清楚从如果按照题解大到小排序的话选队长为什么一定是对的（虽然它的确是这样），所以我选择从小到大排序，至少这样我会做一点。。。这样的话每个当前运动员都要考虑做一次队长，效率是差一点点。不过即便如此还是没做出来。。。。老是WA，甚至开始怀疑hihocoder上的测试数据是错的（这题有事没事debug了1个月了，老是WA，WA到怀疑人生）。 总这贴这里以后不管了。。。 Code（WA） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#define dfor(i,l,r) for(int i=l;i&gt;=r;--i)using namespace std;typedef long long lld;const int maxn = 1000;const int maxl = 1000000000;const int mg = 1, md = 5, mm = 5, mf = 3;int arr[2][6][6][4][maxn][3]; // G, D, M, F , cost, value/num/captain's valuestruct member &#123; char P; int V, C;&#125;lst[maxn + 10];int T, M;lld L;char ipt_tmp[16];bool cmp(const member &amp;arg1, const member &amp;arg2) &#123; if (arg1.V == arg2.V) return arg1.C &lt; arg2.C; return arg1.V &lt; arg2.V;&#125;int main()&#123; std::ios::sync_with_stdio(false); cin &gt;&gt; T; while (T--) &#123; memset(arr, 0, sizeof(arr)); cin &gt;&gt; M; for (int i = 0; i != M; ++i) &#123; member &amp;now = lst[i]; cin &gt;&gt; ipt_tmp &gt;&gt; now.V &gt;&gt; now.C; now.P = *ipt_tmp; &#125; cin &gt;&gt; L; sort(lst, lst + M, cmp); for (int i = 0; i != M; ++i) &#123; const member &amp;nowp = lst[i]; if (nowp.P == 'G') &#123; // exactly one Goalkeeper dfor(g, mg, 1)dfor(d, md, 0)dfor(m, mm, 0)dfor(f, mf, 0) &#123; int(&amp;predp)[maxn][3] = arr[g - 1][d][m][f]; int(&amp;nowdp)[maxn][3] = arr[g][d][m][f]; if (g + d + m + f &gt; 11) continue; dfor(c, L, nowp.C) &#123; int(&amp;nowc)[3] = nowdp[c]; int(&amp;prec)[3] = predp[c - nowp.C]; if (prec[1] == 0) continue; if (nowc[0] + nowc[2] &lt;= prec[0] + nowp.V + nowp.V) &#123; if (nowc[0] + nowc[2] &lt; prec[0] + nowp.V + nowp.V) &#123; nowc[0] = prec[0] + nowp.V; nowc[1] = prec[1]; &#125; else &#123; if ((nowc[1] += prec[1]) &gt; maxl) &#123; nowc[1] = maxl; &#125; &#125; nowc[2] = nowp.V; &#125; &#125; &#125; if (nowp.V + nowp.V &gt;= arr[1][0][0][0][nowp.C][0] + arr[1][0][0][0][nowp.C][2] &amp;&amp; nowp.C &lt; L) &#123; if (nowp.V + nowp.V &gt; arr[1][0][0][0][nowp.C][0] + arr[1][0][0][0][nowp.C][2]) &#123; arr[1][0][0][0][nowp.C][0] = nowp.V; arr[1][0][0][0][nowp.C][1] = 1; arr[1][0][0][0][nowp.C][2] = nowp.V; &#125; else &#123; ++arr[1][0][0][0][nowp.C][1]; &#125; &#125; &#125; else if (nowp.P == 'D') &#123; // at least 3 but at most 5 Defenders dfor(d, md, 1)dfor(g, mg, 0)dfor(m, mm, 0)dfor(f, mf, 0) &#123; int(&amp;predp)[maxn][3] = arr[g][d - 1][m][f]; int(&amp;nowdp)[maxn][3] = arr[g][d][m][f]; if (g + d + m + f &gt; 11) continue; dfor(c, L, nowp.C) &#123; int(&amp;nowc)[3] = nowdp[c]; int(&amp;prec)[3] = predp[c - nowp.C]; if (prec[1] == 0) continue; if (nowc[0] + nowc[2] &lt;= prec[0] + nowp.V + nowp.V) &#123; if (nowc[0] + nowc[2] &lt; prec[0] + nowp.V + nowp.V) &#123; nowc[0] = prec[0] + nowp.V; nowc[1] = prec[1]; &#125; else &#123; if ((nowc[1] += prec[1]) &gt; maxl) &#123; nowc[1] = maxl; &#125; &#125; nowc[2] = nowp.V; &#125; &#125; &#125; if (nowp.V + nowp.V &gt;= arr[0][1][0][0][nowp.C][0] + arr[0][1][0][0][nowp.C][2] &amp;&amp; nowp.C &lt; L) &#123; if (nowp.V + nowp.V &gt; arr[0][1][0][0][nowp.C][0] + arr[0][1][0][0][nowp.C][2]) &#123; arr[0][1][0][0][nowp.C][0] = nowp.V; arr[0][1][0][0][nowp.C][1] = 1; arr[0][1][0][0][nowp.C][2] = nowp.V; &#125; else &#123; ++arr[0][1][0][0][nowp.C][1]; &#125; &#125; &#125; else if (nowp.P == 'M') &#123; // at least 2 but at most 5 Midfielders dfor(m, mm, 1)dfor(g, mg, 0)dfor(d, md, 0)dfor(f, mf, 0) &#123; int(&amp;predp)[maxn][3] = arr[g][d][m - 1][f]; int(&amp;nowdp)[maxn][3] = arr[g][d][m][f]; if (g + d + m + f &gt; 11) continue; dfor(c, L, nowp.C) &#123; int(&amp;nowc)[3] = nowdp[c]; int(&amp;prec)[3] = predp[c - nowp.C]; if (prec[1] == 0) continue; if (nowc[0] + nowc[2] &lt;= prec[0] + nowp.V + nowp.V) &#123; if (nowc[0] + nowc[2] &lt; prec[0] + nowp.V + nowp.V) &#123; nowc[0] = prec[0] + nowp.V; nowc[1] = prec[1]; &#125; else &#123; if ((nowc[1] += prec[1]) &gt; maxl) &#123; nowc[1] = maxl; &#125; &#125; nowc[2] = nowp.V; &#125; &#125; &#125; if (nowp.V + nowp.V &gt;= arr[0][0][1][0][nowp.C][0] + arr[0][0][1][0][nowp.C][2] &amp;&amp; nowp.C &lt; L) &#123; if (nowp.V + nowp.V &gt; arr[0][0][1][0][nowp.C][0] + arr[0][0][1][0][nowp.C][2]) &#123; arr[0][0][1][0][nowp.C][0] = nowp.V; arr[0][0][1][0][nowp.C][1] = 1; arr[0][0][1][0][nowp.C][2] = nowp.V; &#125; else &#123; ++arr[0][0][1][0][nowp.C][1]; &#125; &#125; &#125; else &#123; // at least 1 but at most 3 Forwards dfor(f, mf, 1)dfor(g, mg, 0)dfor(d, md, 0)dfor(m, mm, 0) &#123; int(&amp;predp)[maxn][3] = arr[g][d][m][f - 1]; int(&amp;nowdp)[maxn][3] = arr[g][d][m][f]; if (g + d + m + f &gt; 11) continue; dfor(c, L, nowp.C) &#123; int(&amp;nowc)[3] = nowdp[c]; int(&amp;prec)[3] = predp[c - nowp.C]; if (prec[1] == 0) continue; if (nowc[0] + nowc[2] &lt;= prec[0] + nowp.V + nowp.V) &#123; if (nowc[0] + nowc[2] &lt; prec[0] + nowp.V + nowp.V) &#123; nowc[0] = prec[0] + nowp.V; nowc[1] = prec[1]; &#125; else &#123; if ((nowc[1] += prec[1]) &gt; maxl) &#123; nowc[1] = maxl; &#125; &#125; nowc[2] = nowp.V; &#125; &#125; &#125; if (nowp.V + nowp.V &gt;= arr[0][0][0][1][nowp.C][0] + arr[0][0][0][1][nowp.C][2] &amp;&amp; nowp.C &lt; L) &#123; if (nowp.V + nowp.V &gt; arr[0][0][0][1][nowp.C][0] + arr[0][0][0][1][nowp.C][2]) &#123; arr[0][0][0][1][nowp.C][0] = nowp.V; arr[0][0][0][1][nowp.C][1] = 1; arr[0][0][0][1][nowp.C][2] = nowp.V; &#125; else &#123; ++arr[0][0][0][1][nowp.C][1]; &#125; &#125; &#125; &#125; // DP finished int max_value = -1, min_cost = maxn, sum_num = 0; dfor(g, mg, 1)dfor(d, md, 3)dfor(m, mm, 2)dfor(f, mf, 1) &#123; if (g + d + m + f != 11) continue; dfor(c, L, 0) &#123; int(&amp;now)[3] = arr[g][d][m][f][c]; //if (now[0]) &#123; // cerr &lt;&lt; " val: " &lt;&lt; now[0] + now[2] &lt;&lt; "\tnum: " &lt;&lt; now[1] &lt;&lt; "\tcost: " &lt;&lt; c &lt;&lt; '\t'; // cerr &lt;&lt; "g: " &lt;&lt; g &lt;&lt; " d: " &lt;&lt; d &lt;&lt; " m: " &lt;&lt; m &lt;&lt; " f: " &lt;&lt; f &lt;&lt; endl; //&#125; if (now[0] + now[2] &gt; max_value) &#123; max_value = now[0] + now[2]; min_cost = c; sum_num = now[1]; &#125; else if (now[0] + now[2] == max_value) &#123; if (min_cost &gt; c) &#123; min_cost = c; sum_num = now[1]; &#125; else if (min_cost == c) &#123; sum_num += now[1]; &#125; &#125; &#125; &#125; cout &lt;&lt; max_value &lt;&lt; ' ' &lt;&lt; min_cost &lt;&lt; ' ' &lt;&lt; sum_num &lt;&lt; " \n"[T]; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 794C - Naming Company]]></title>
    <url>%2Fposts%2F15668.html</url>
    <content type="text"><![CDATA[http://codeforces.com/contest/794/problem/C Description Oleg the client and Igor the analyst are good friends. However, sometimes they argue over little things. Recently, they started a new company, but they are having trouble finding a name for the company. To settle this problem, they've decided to play a game. The company name will consist of n letters. Oleg and Igor each have a set of n letters (which might contain multiple copies of the same letter, the sets can be different). Initially, the company name is denoted by n question marks. Oleg and Igor takes turns to play the game, Oleg moves first. In each turn, a player can choose one of the letters c in his set and replace any of the question marks with c. Then, a copy of the letter c is removed from his set. The game ends when all the question marks has been replaced by some letter. For example, suppose Oleg has the set of letters {i, o, i} and Igor has the set of letters {i, m, o}. One possible game is as follows : Initially, the company name is ???. Oleg replaces the second question mark with 'i'. The company name becomes ?i?. The set of letters Oleg have now is {i, o}. Igor replaces the third question mark with 'o'. The company name becomes ?io. The set of letters Igor have now is {i, m}. Finally, Oleg replaces the first question mark with 'o'. The company name becomes oio. The set of letters Oleg have now is {i}. In the end, the company name is oio. Oleg wants the company name to be as lexicographically small as possible while Igor wants the company name to be as lexicographically large as possible. What will be the company name if Oleg and Igor always play optimally? A string \(s = s_1s_2...s_m\) is called lexicographically smaller than a string \(t = t_1t_2...t_m\) (where \(s ≠ t\)) if \(si &lt; ti\) where \(i\) is the smallest index such that \(s_i ≠ t_i\). (so \(s_j = t_j\) for all \(j &lt; i\)) Input The first line of input contains a string \(s\) of length \(n\) (\(1 ≤ n ≤ 3·10^5\)). All characters of the string are lowercase English letters. This string denotes the set of letters Oleg has initially. The second line of input contains a string \(t\) of length \(n\). All characters of the string are lowercase English letters. This string denotes the set of letters Igor has initially. Output The output should contain a string of \(n\) lowercase English letters, denoting the company name if Oleg and Igor plays optimally. Examples 1234567891011121314151617181920inputtinkoffzscoderoutputfzfsirkinputxxxxxxxxxxxxoutputxxxxxxinputioiimooutputioi Note One way to play optimally in the first sample is as follows : Initially, the company name is ???????. Oleg replaces the first question mark with 'f'. The company name becomes f??????. Igor replaces the second question mark with 'z'. The company name becomes fz?????. Oleg replaces the third question mark with 'f'. The company name becomes fzf????. Igor replaces the fourth question mark with 's'. The company name becomes fzfs???. Oleg replaces the fifth question mark with 'i'. The company name becomes fzfsi??. Igor replaces the sixth question mark with 'r'. The company name becomes fzfsir?. Oleg replaces the seventh question mark with 'k'. The company name becomes fzfsirk. For the second sample, no matter how they play, the company name will always be xxxxxx. Announcement Problem C. Naming Company \(*****\) The two players know the letters in both sets. Key 题意：甲乙两人各持有一个长度均为n的字符串，轮着向一个新的长也为n的字符串里放字符，甲先行。甲每一步都试图让字符串按字典序最小化，乙每一步都试图让字符串按字典序最大化。问最后这新字符串是什么。 思路：做题做到一半时出题人推送了一个Announcement（如上面所示）：甲乙均知道对面的情况。这是个很重要的提示。 显然的是，先排个序，甲从小到大，乙从大到小。然后两个字符串的后一半肯定是用不上了，砍掉。最后甲字符串长度\((len + 1) / 2\)，乙字符串长度\((len) / 2\)。 甲乙试图让自己走的每一步最优，那就是贪心无误了。 1.当\(甲最小的字符&lt;乙最大的字符\)时，两者均靠左放置最小/大字符。 2.当\(甲最小的字符&gt;=乙最大的字符\)时，两者均靠右放置最大/小字符。 如何找当前最优情况想了很久，一开始想的情况很复杂，如何换个角度思考问题很不容易啊。要注意的是第2种情况的等于号，一开始我放在第1种情况上了（“&lt;=”），这是不对的，找了好久最后才发现竟然错在了一个小小的等于号。“=”号一删，瞬间AC。 Code 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 3e5 + 10;char s1[maxn], s2[maxn], ans[maxn];int len;bool cmp1(const char &amp;a, const char &amp;b) &#123; return a &lt; b;&#125;bool cmp2(const char &amp;a, const char &amp;b) &#123; return a &gt; b;&#125;int main()&#123; ios::sync_with_stdio(false); cin &gt;&gt; s1 &gt;&gt; s2; len = strlen(s1); sort(s1, s1 + len, cmp1); sort(s2, s2 + len, cmp2); int i = 0; char *pl[2] = &#123; s1, s2 &#125;; for (; (i &lt; len) &amp;&amp; (*pl[0] &lt; *pl[1]); ++i) &#123; ans[i] = *(pl[i &amp; 1]++); &#125; int j = len - 1; char *pr[2] = &#123; s1 + (len + 1) / 2 - 1, s2 + (len) / 2 - 1 &#125;; for (; i &lt; len; ++i, --j) &#123; ans[j] = *(pr[i &amp; 1]--); &#125; ans[len] = '\0'; cout &lt;&lt; ans; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++控制台扫雷]]></title>
    <url>%2Fposts%2F52546.html</url>
    <content type="text"><![CDATA[其实是大一还不会GUI时闲着无聊写的。都是硬编码，也不支持自定义棋盘大小，现在看看这代码惨不忍睹。下载地址：http://download.csdn.net/download/xienaoban/9835259 #实现 输入P x y 模拟插下小旗，输入I x y 模拟点下去，输入O x y 模拟探测，输入R重玩。 原理嘛就是开局生成8个雷，并将所有点周围的雷计算好填入棋盘。当输入Ixy点下去时若该点为0，则显示该点并DFS递归遍历周围所有点并显示；若为非零，则直接显示它；若为雷则输了。 唯一与别人不同的特性是，输入本人的名字首字母xjf（必须小写）可以作弊(￣▽￣)，就是显示棋盘上所有的雷~ #截图 这里写图片描述 这里写图片描述 这里写图片描述 #代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;ctime&gt;using namespace std;int o(int i)//防止超出数组范围&#123; if (i &lt; 0) return 10; else return i;&#125;void xianshi(char p[][11])//显示棋盘&#123; system("cls"); cout &lt;&lt; "-------------------------------------------------------------------------------\n" &lt;&lt; "| 0 1 2 3 4 5 6 7 8 9 |\n"; for (int i = 0;i &lt; 9;i++) &#123; cout &lt;&lt; "| " &lt;&lt; i; for (int j = 0;j &lt; 9;j++) cout &lt;&lt; ' ' &lt;&lt; p[i][j] &lt;&lt; " |"; cout &lt;&lt; ' ' &lt;&lt; p[i][9] &lt;&lt; ' ' &lt;&lt; i &lt;&lt; " |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n"; &#125; cout &lt;&lt; "| 9"; for (int j = 0;j &lt; 9;j++) cout &lt;&lt; ' ' &lt;&lt; p[9][j] &lt;&lt; " |"; cout &lt;&lt; ' ' &lt;&lt; p[9][9] &lt;&lt; " 9 |\n" &lt;&lt; "| 0 1 2 3 4 5 6 7 8 9 |\n" &lt;&lt; "| |\n" &lt;&lt; "-------------------------------------------------------------------------------\n";&#125;int panduan(char p[][11], char cx, char cy, int &amp;x, int &amp;y, char &amp;lei)&#123; switch (cx) &#123; case '0': x = 0;break; case '1': x = 1;break; case '2': x = 2;break; case '3': x = 3;break; case '4': x = 4;break; case '5': x = 5;break; case '6': x = 6;break; case '7': x = 7;break; case '8': x = 8;break; case '9': x = 9;break; default: cout &lt;&lt; "错误：数据不合法。\n";return 0; &#125; switch (cy) &#123; case '0': y = 0;break; case '1': y = 1;break; case '2': y = 2;break; case '3': y = 3;break; case '4': y = 4;break; case '5': y = 5;break; case '6': y = 6;break; case '7': y = 7;break; case '8': y = 8;break; case '9': y = 9;break; default: cout &lt;&lt; "错误：数据不合法。\n";return 0; &#125; if (lei == 'o' || lei == 'O') return 1; else if (p[y][x] != ' '&amp;&amp;p[y][x] != 'P') &#123; cout &lt;&lt; "错误：数据不合法。\n";return 0; &#125; return 1;&#125;void kaiju(int a[11][11])&#123; int tx, ty; for (int i = 1;i &lt;= 10;i++) &#123; tx = rand() % 10, ty = rand() % 10; while (a[ty][tx] != 0) &#123; tx = rand() % 10; ty = rand() % 10; &#125; a[ty][tx] = 9; &#125; for (int j = 0;j &lt; 10;j++) for (int i = 0;i &lt; 10;i++) &#123; if (a[j][i] == 9) continue; if (a[o(j - 1)][o(i - 1)] == 9) a[j][i]++; if (a[o(j - 1)][o(i)] == 9) a[j][i]++; if (a[o(j - 1)][o(i + 1)] == 9) a[j][i]++; if (a[o(j)][o(i - 1)] == 9) a[j][i]++; if (a[o(j)][o(i + 1)] == 9) a[j][i]++; if (a[o(j + 1)][o(i - 1)] == 9) a[j][i]++; if (a[o(j + 1)][o(i)] == 9) a[j][i]++; if (a[o(j + 1)][o(i + 1)] == 9) a[j][i]++; &#125;&#125;void kong(int pp[][11], char p[][11], int x, int y)&#123; if (p[y][x] == ' ' &amp;&amp; x != 10 &amp;&amp; y != 10 &amp;&amp; p[y][x] != 'P') &#123; if (pp[y][x] == 0) &#123; p[y][x] = '0'; kong(pp, p, o(x - 1), o(y - 1)); kong(pp, p, x, o(y - 1)); kong(pp, p, x + 1, o(y - 1)); kong(pp, p, o(x - 1), y); kong(pp, p, x + 1, y); kong(pp, p, o(x - 1), y + 1); kong(pp, p, x, y + 1); kong(pp, p, o(x + 1), o(y + 1)); &#125; else p[y][x] = (char)(48 + pp[y][x]); &#125;&#125;void zhongjian(int pp[][11], char p[][11], int x, int y)&#123; if (p[y][x] != ' ' &amp;&amp; (pp[o(y - 1)][o(x - 1)] != 9 || (p[o(y - 1)][o(x - 1)] == 'P'&amp;&amp;pp[o(y - 1)][o(x - 1)] == 9)) &amp;&amp; (pp[o(y - 1)][x] != 9 || (p[o(y - 1)][x] == 'P'&amp;&amp;pp[o(y - 1)][x] == 9)) &amp;&amp; (pp[o(y - 1)][x + 1] != 9 || (p[o(y - 1)][x + 1] == 'P'&amp;&amp;pp[o(y - 1)][x + 1] == 9)) &amp;&amp; (pp[y][o(x - 1)] != 9 || (p[y][o(x - 1)] == 'P'&amp;&amp;pp[y][o(x - 1)] == 9)) &amp;&amp; (pp[y][x + 1] != 9 || (p[y][x + 1] == 'P'&amp;&amp;pp[y][x + 1] == 9)) &amp;&amp; (pp[y + 1][o(x - 1)] != 9 || (p[y + 1][o(x - 1)] == 'P'&amp;&amp;pp[y + 1][o(x - 1)] == 9)) &amp;&amp; (pp[y + 1][x] != 9 || (p[y + 1][x] == 'P'&amp;&amp;pp[y + 1][x] == 9)) &amp;&amp; (pp[y + 1][x + 1] != 9 || (p[y + 1][x + 1] == 'P'&amp;&amp;pp[y + 1][x + 1] != 9))) &#123; if (p[o(y - 1)][o(x - 1)] == ' ') kong(pp, p, o(x - 1), o(y - 1)); if (p[o(y - 1)][x] == ' ') kong(pp, p, x, o(y - 1)); if (p[o(y - 1)][x + 1] == ' ') kong(pp, p, x+1, o(y - 1)); if (p[y][o(x - 1)] == ' ') kong(pp, p, o(x-1), y); if (p[y][x + 1] == ' ') kong(pp, p,x+1, y); if (p[y + 1][o(x - 1)] == ' ') kong(pp, p, o(x - 1), y+1); if (p[y + 1][x] == ' ') kong(pp, p, x, y + 1); if (p[y + 1][x + 1] == ' ') kong(pp, p, x + 1, y + 1); &#125;&#125;int main()&#123; system("mode con cols=80 lines=33"); system("cls"); cout &lt;&lt; "-------------------------------------------------------------------------------\n" &lt;&lt; "| 0 1 2 3 4 5 6 7 8 9 |\n" &lt;&lt; "| 0 | | | | | | | | | 0 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 1 | | | | | | | | | 1 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 2 | | | | | | | | | 2 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 3 | | | | | | | | | 3 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 4 | | | | | | | | | 4 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 5 | | | | | | | | | 5 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 6 | | | | | | | | | 6 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 7 | | | | | | | | | 7 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 8 | | | | | | | | | 8 |\n" &lt;&lt; "| ---+---+---+---+---+---+---+---+---+--- |\n" &lt;&lt; "| 9 | | | | | | | | | 9 |\n" &lt;&lt; "| 0 1 2 3 4 5 6 7 8 9 |\n" &lt;&lt; "| |\n" &lt;&lt; "-------------------------------------------------------------------------------\n" &lt;&lt; "输入P x y 模拟插下小旗\n输入I x y 模拟点下去\n输入O x y 模拟探测。\n"; char cx = '0', cy = '0'; int x = 0, y = 0;//玩家下的子 char lei = 0; int jieju = 0;//1:玩家赢 2:玩家输 char p[11][11];//显示的 int pp[11][11] = &#123; 0 &#125;;//表示的 srand((unsigned)time(0)); for (int i = 0;i &lt; 11;i++) for (int j = 0;j &lt; 11;j++) p[i][j] = ' '; kaiju(pp); while (!jieju) &#123; while (1) &#123; cout &lt;&lt; "Player&gt; "; cin &gt;&gt; lei; if (lei == 'R' || lei == 'r') &#123; cout &lt;&lt; "重新开局？再次输入R 确定，输入其他继续当前游戏。"; cin &gt;&gt; lei; if (lei == 'R' || lei == 'r') main(); &#125; cin &gt;&gt; cx &gt;&gt; cy; if (lei == 'x'&amp;&amp;cx == 'j'&amp;&amp;cy == 'f') &#123; int tpp[11][11]; char tp[11][11]; for (int i = 0;i &lt; 11;i++) for (int j = 0;j &lt; 11;j++) tpp[j][i] = pp[j][i]; for (int i = 0;i &lt; 11;i++) for (int j = 0;j &lt; 11;j++) tp[i][j] = ' '; for (int i = 0;i &lt; 10;i++) for (int j = 0;j &lt; 10;j++) if (tpp[j][i] == 9) tp[j][i] = '*'; xianshi(tp); &#125; if (panduan(p, cx, cy, x, y, lei)) break; &#125; if (lei != 'P' &amp;&amp; lei != 'p') &#123; if (lei != 'o' &amp;&amp; lei != 'O') &#123; if (pp[y][x] == 9) &#123; p[y][x] = '*'; xianshi(p); jieju = 2; &#125; else if (pp[y][x] != 0 &amp;&amp; pp[y][x] != 9) &#123; p[y][x] = (char)(pp[y][x] + 48); xianshi(p); &#125; else &#123; kong(pp, p, x, y); xianshi(p); &#125; &#125; else &#123; zhongjian(pp, p, x, y); xianshi(p); &#125; &#125; else &#123; if (p[y][x] == ' ') p[y][x] = 'P'; else p[y][x] = ' '; xianshi(p); &#125; int temp = 0; for (int i = 0;i &lt; 10;i++) for (int j = 0;j &lt; 10;j++) if (p[i][j] == ' ' || p[i][j] == 'P') temp++; if (temp == 10) jieju = 1; &#125; if (jieju == 1) cout &lt;&lt; "You win!\n"; else cout &lt;&lt; "You fail!\n"; cout &lt;&lt; "输入R再玩一局；输入其他结束。\n"; char r; cin &gt;&gt; r; if (r == 'R' || r == 'r') main(); return 0;&#125;]]></content>
      <tags>
        <tag>造轮子</tag>
        <tag>扫雷</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题动态演示]]></title>
    <url>%2Fposts%2F4561.html</url>
    <content type="text"><![CDATA[学校组织的计算机技能大赛，题目解八皇后并做程序演示，顺便就贴博客上来。 八皇后问题 简述：8*8的棋盘，有八个皇后，每个皇后不能在同一行同一列同一斜线上，问有多少种可能的摆法。答案是92，这大家都知道。 #解法与优化 首先肯定是遍历嘛，关键是要剪枝。 ##1.暴力枚举 8个子所有点遍历一遍，8个嵌套for，一共\(C_{64}^{8}\)种情况。曰曰 ##2.回溯法 由于每个皇后不能在一行，那八个皇后就在八个不同行上面嘛，对于每个皇后/每一行，采用回溯法先第一行放一个，在第二行剩下7个位置中找第二个皇后可能的位置，以此类推，一共\(8^8 = 16777216\)种情况。 ##3.全排列 由于每个皇后不同行不同列，那么在每个皇后占一行的基础上，每个皇后在0-7个列只能占一个，就相当于一个全排列，要考虑\(A_8^8 = 8! = 40320\)种情况，较上述两个方法已经快了很多了。网上也都是回溯和全排列的算法。但是事实上还能再剪枝。 ##4.全排列再剪枝 对于全排列，依然可以剪枝。例如下图情况： 它的下一个排列是： 但是我们很明显的看到，第一、第二个皇后已经不满足条件了，后面的皇后无需再看了。因此我们直接跳到第1、2个皇后满足条件的排列： 最终，我们只需遍历3576种情况（根据实践得到的数据），这在全排列的基础上又优化了十倍多。这对八皇后适用，对n皇后都适用。 #程序实现 ##概况 使用C#编写，平台是win10，环境是.Net Framework 4.6.1。 下载地址：http://download.csdn.net/download/xienaoban/9835240 ##特性 按“重置”即重置进度； 按“下一个”查找下一个符合条件的解并展示； 按“直接得出结果”不显示动画直接输出结果； 勾选“显示所有动画情况”演示所有遍历情况，勾选后再次点击“下一个”或“直接得出结果”演示所有遍历的情况； 遍历到当前方案时的遍历次数统计与可行方案统计显示在下方； 演示窗口自适应，修改窗口尺寸时始终保证棋盘最大化地显示在窗口中间； 演示画布采用双缓冲，防止演示动画时的窗口动画闪屏。 ##代码 八皇后类EnumQueens.cs（实现查找下一排列、重置排列等）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687using System;using System.Collections.Generic;using System.Drawing;using System.Linq;using System.Text;using System.Threading.Tasks;namespace EightQueen&#123; class EnumQueens &#123; private int[] Board; public EnumQueens() &#123; Board = new int[8]; Reset(); &#125; public void Reset() &#123; for (int i = 0; i &lt; 8; ++i) &#123; Board[i] = i; &#125; &#125; public bool Next() &#123; for (int i = Board.Length - 1; i &gt; 0; --i) &#123; if (Board[i] &gt; Board[i - 1]) &#123; int val = Board[i - 1]; int j = Board.Length - 1; for (; j &gt;= i; --j) &#123; if (Board[j] &gt; val) break; &#125; SwapBoard(i - 1, j); int l = i; int r = Board.Length - 1; while (l &lt; r) &#123; SwapBoard(l, r); l++; r--; &#125; return true; &#125; &#125; Reset(); return false; &#125; public Point Check() &#123; Point ans = new Point(); for (int i = 0; i &lt; Board.Length; ++i) &#123; for (int j = i + 1; j &lt; Board.Length; ++j) &#123; if (Math.Abs(i - j) == Math.Abs(Board[i] - Board[j])) &#123; ans.X = i;ans.Y = j; return ans; &#125; &#125; &#125; ans.X = -1; ans.Y = -1; return ans; &#125; public int Get(int i) &#123; return Board[i]; &#125; private void SwapBoard(int i, int j) &#123; int t = Board[i]; Board[i] = Board[j]; Board[j] = t; &#125; &#125;&#125; 含棋盘的演示窗口：MainForm.cs： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.Linq;using System.Runtime.InteropServices;using System.Text;using System.Threading;using System.Threading.Tasks;using System.Windows.Forms;namespace EightQueen&#123; public partial class MainForm : Form &#123; private int FrameLength = 30; private int Fwidth, Fheight, Fleft, Fright, Ftop, Fbottom, Flength, Fdiameter; private float Dif; [DllImport("user32 ")] private static extern IntPtr FindWindow(string lpClassName, string lpWindowName); [DllImport("user32 ")] private static extern IntPtr SetParent(IntPtr hWndChild, IntPtr hWndNewParent); public MainForm() &#123; InitializeComponent(); Dif = 0.8f; Width = 400; Height = 600; PannelForm pForm = new PannelForm(); pForm.Show(); &#125; private void MainForm_SizeChanged(object sender, EventArgs e) &#123; if (Program.Board.Get(0) == 0 &amp;&amp; Program.Board.Get(1) == 1) PaintQueens(Color.Orange); else PaintQueens(Color.LightGreen); &#125; private void MainForm_Paint(object sender, PaintEventArgs e) &#123; if (Program.Board.Get(0) == 0 &amp;&amp; Program.Board.Get(1) == 1) PaintQueens(Color.Orange); else PaintQueens(Color.LightGreen); &#125; public void PaintQueens(Color c) &#123; Bitmap bmp = new Bitmap(Width, Height); Graphics grp = Graphics.FromImage(bmp); grp.Clear(Color.Azure); Pen pen; CalFrame(); pen = new Pen(Brushes.DeepSkyBlue, Flength / 160); for (int i = 1; i &lt; 8; ++i) &#123; grp.DrawLine(pen, new Point(Fleft + i * Fdiameter, Ftop), new Point(Fleft + i * Fdiameter, Fbottom)); grp.DrawLine(pen, new Point(Fleft, Ftop + i * Fdiameter), new Point(Fright, Ftop + i * Fdiameter)); &#125; pen = new Pen(Brushes.DodgerBlue, Flength / 100); grp.DrawLine(pen, new Point(Fleft, Ftop), new Point(Fright, Ftop)); grp.DrawLine(pen, new Point(Fright, Ftop), new Point(Fright, Fbottom)); grp.DrawLine(pen, new Point(Fleft, Fbottom), new Point(Fright, Fbottom)); grp.DrawLine(pen, new Point(Fleft, Ftop), new Point(Fleft, Fbottom)); SolidBrush brush = new SolidBrush(c); Rectangle rect; int dif = (int)((1.0f - Dif) * Fdiameter/2); for (int i = 0; i &lt; 8; ++i) &#123; rect = new Rectangle(Fleft + Program.Board.Get(i) * Fdiameter + dif, Ftop + i * Fdiameter + dif, Fdiameter - 2 * dif, Fdiameter - 2 * dif); grp.FillEllipse(brush, rect); &#125; this.CreateGraphics().DrawImage(bmp, 0, 0); &#125; private void CalFrame() &#123; int width = this.Width - 17; int height = this.Height - 40; Fwidth = width - FrameLength * 2; Fheight = height - FrameLength * 2; Flength = (Math.Min(Fwidth, Fheight) / 8) * 8; Fleft = (width - Flength) / 2; Fright = Fleft + Flength; Ftop = (height - Flength) / 2; Fbottom = Ftop + Flength; Fdiameter = Flength / 8; &#125; &#125;&#125; 控制面板窗口PannelForm.cs： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307using System;using System.Collections.Generic;using System.Drawing;using System.Linq;using System.Text;using System.Threading;using System.Threading.Tasks;using System.Windows.Forms;namespace EightQueen&#123; public partial class PannelForm : Form &#123; private Button button1; private Button button2; private Label label1; private Label label2; private Label label3; private Label label4; public int Ergodic, Solution; private Button button3; private Button button4; private Button button5; private CheckBox checkBox1; public PannelForm() &#123; InitializeComponent(); &#125; private void InitializeComponent() &#123; this.button1 = new System.Windows.Forms.Button(); this.button2 = new System.Windows.Forms.Button(); this.label1 = new System.Windows.Forms.Label(); this.label2 = new System.Windows.Forms.Label(); this.label3 = new System.Windows.Forms.Label(); this.label4 = new System.Windows.Forms.Label(); this.button3 = new System.Windows.Forms.Button(); this.button4 = new System.Windows.Forms.Button(); this.checkBox1 = new System.Windows.Forms.CheckBox(); this.button5 = new System.Windows.Forms.Button(); this.SuspendLayout(); // // button1 // this.button1.FlatStyle = System.Windows.Forms.FlatStyle.Flat; this.button1.Font = new System.Drawing.Font("微软雅黑", 15F); this.button1.ForeColor = System.Drawing.SystemColors.HotTrack; this.button1.Location = new System.Drawing.Point(12, 12); this.button1.Name = "button1"; this.button1.Size = new System.Drawing.Size(268, 51); this.button1.TabIndex = 0; this.button1.Text = "重置"; this.button1.TextAlign = System.Drawing.ContentAlignment.MiddleLeft; this.button1.UseVisualStyleBackColor = true; this.button1.Click += new System.EventHandler(this.button1_Click); // // button2 // this.button2.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None; this.button2.FlatStyle = System.Windows.Forms.FlatStyle.Flat; this.button2.Font = new System.Drawing.Font("微软雅黑", 15F); this.button2.ForeColor = System.Drawing.SystemColors.HotTrack; this.button2.Location = new System.Drawing.Point(12, 69); this.button2.Name = "button2"; this.button2.Size = new System.Drawing.Size(268, 51); this.button2.TabIndex = 1; this.button2.Text = "下一个"; this.button2.TextAlign = System.Drawing.ContentAlignment.MiddleLeft; this.button2.UseVisualStyleBackColor = true; this.button2.Click += new System.EventHandler(this.button2_Click); // // label1 // this.label1.AutoSize = true; this.label1.Font = new System.Drawing.Font("微软雅黑", 15F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.label1.ForeColor = System.Drawing.SystemColors.HotTrack; this.label1.Location = new System.Drawing.Point(17, 231); this.label1.Name = "label1"; this.label1.Size = new System.Drawing.Size(132, 27); this.label1.TabIndex = 2; this.label1.Text = "遍历次数统计"; this.label1.Click += new System.EventHandler(this.label1_Click); // // label2 // this.label2.AutoSize = true; this.label2.Font = new System.Drawing.Font("华文彩云", 60F); this.label2.ForeColor = System.Drawing.SystemColors.HotTrack; this.label2.Location = new System.Drawing.Point(23, 258); this.label2.Name = "label2"; this.label2.Size = new System.Drawing.Size(80, 83); this.label2.TabIndex = 3; this.label2.Text = "0"; this.label2.Click += new System.EventHandler(this.label2_Click); // // label3 // this.label3.AutoSize = true; this.label3.Font = new System.Drawing.Font("微软雅黑", 15F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.label3.ForeColor = System.Drawing.SystemColors.HotTrack; this.label3.Location = new System.Drawing.Point(17, 377); this.label3.Name = "label3"; this.label3.Size = new System.Drawing.Size(132, 27); this.label3.TabIndex = 4; this.label3.Text = "可行方案统计"; // // label4 // this.label4.AutoSize = true; this.label4.Font = new System.Drawing.Font("华文彩云", 71.99999F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.label4.ForeColor = System.Drawing.SystemColors.HotTrack; this.label4.Location = new System.Drawing.Point(23, 404); this.label4.Name = "label4"; this.label4.Size = new System.Drawing.Size(97, 100); this.label4.TabIndex = 5; this.label4.Text = "0"; this.label4.Click += new System.EventHandler(this.label4_Click); // // button3 // this.button3.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None; this.button3.FlatStyle = System.Windows.Forms.FlatStyle.Flat; this.button3.Font = new System.Drawing.Font("微软雅黑", 15F); this.button3.ForeColor = System.Drawing.SystemColors.HotTrack; this.button3.Location = new System.Drawing.Point(12, 227); this.button3.Name = "button3"; this.button3.Size = new System.Drawing.Size(268, 140); this.button3.TabIndex = 6; this.button3.TextAlign = System.Drawing.ContentAlignment.MiddleLeft; this.button3.UseVisualStyleBackColor = true; // // button4 // this.button4.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None; this.button4.FlatStyle = System.Windows.Forms.FlatStyle.Flat; this.button4.Font = new System.Drawing.Font("微软雅黑", 15F); this.button4.ForeColor = System.Drawing.SystemColors.HotTrack; this.button4.Location = new System.Drawing.Point(12, 373); this.button4.Name = "button4"; this.button4.Size = new System.Drawing.Size(268, 140); this.button4.TabIndex = 7; this.button4.TextAlign = System.Drawing.ContentAlignment.MiddleLeft; this.button4.UseVisualStyleBackColor = true; // // checkBox1 // this.checkBox1.Font = new System.Drawing.Font("微软雅黑", 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.checkBox1.ForeColor = System.Drawing.SystemColors.HotTrack; this.checkBox1.Location = new System.Drawing.Point(17, 194); this.checkBox1.Name = "checkBox1"; this.checkBox1.Size = new System.Drawing.Size(123, 21); this.checkBox1.TabIndex = 0; this.checkBox1.Text = "显示所有遍历情况"; this.checkBox1.UseVisualStyleBackColor = true; this.checkBox1.CheckedChanged += new System.EventHandler(this.checkBox1_CheckedChanged); // // button5 // this.button5.BackgroundImageLayout = System.Windows.Forms.ImageLayout.None; this.button5.FlatStyle = System.Windows.Forms.FlatStyle.Flat; this.button5.Font = new System.Drawing.Font("微软雅黑", 15F); this.button5.ForeColor = System.Drawing.SystemColors.HotTrack; this.button5.Location = new System.Drawing.Point(12, 126); this.button5.Name = "button5"; this.button5.Size = new System.Drawing.Size(268, 51); this.button5.TabIndex = 8; this.button5.Text = "直接得出结果"; this.button5.TextAlign = System.Drawing.ContentAlignment.MiddleLeft; this.button5.UseVisualStyleBackColor = true; this.button5.Click += new System.EventHandler(this.button5_Click); // // PannelForm // this.BackColor = System.Drawing.Color.Azure; this.ClientSize = new System.Drawing.Size(292, 535); this.Controls.Add(this.button5); this.Controls.Add(this.checkBox1); this.Controls.Add(this.label4); this.Controls.Add(this.label3); this.Controls.Add(this.label2); this.Controls.Add(this.label1); this.Controls.Add(this.button2); this.Controls.Add(this.button1); this.Controls.Add(this.button3); this.Controls.Add(this.button4); this.DoubleBuffered = true; this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle; this.Name = "PannelForm"; this.Text = "控制面板"; this.Load += new System.EventHandler(this.PannelForm_Load); this.ResumeLayout(false); this.PerformLayout(); &#125; private void button2_Click(object sender, EventArgs e) &#123; if (!Next()) &#123; label4.Text = (Solution).ToString(); label2.Text = (Ergodic).ToString(); MessageBox.Show("所有情况已遍历！", "Duang！！！"); Reset(); &#125; else &#123; label4.Text = (Solution).ToString(); label2.Text = (Ergodic).ToString(); Program.mForm.PaintQueens(Color.LightGreen); &#125; &#125; private void button5_Click(object sender, EventArgs e) &#123; while (Next()) &#123; if (checkBox1.Checked) &#123; label4.Text = (Solution).ToString(); label2.Text = (Ergodic).ToString(); Program.mForm.PaintQueens(Color.LightGreen); &#125; &#125; label4.Text = (Solution).ToString(); label2.Text = (Ergodic).ToString(); Program.mForm.PaintQueens(Color.LightGreen); MessageBox.Show("所有情况已遍历！", "Duang！！！"); Reset(); &#125; private void button1_Click(object sender, EventArgs e) &#123; Reset(); &#125; private void label1_Click(object sender, EventArgs e) &#123; &#125; private void PannelForm_Load(object sender, EventArgs e) &#123; &#125; public bool Next() &#123; while (Program.Board.Next()) &#123; ++Ergodic; Point index = Program.Board.Check(); if (index.X != -1) &#123; Point val = new Point(); val.X = Program.Board.Get(index.X); val.Y = Program.Board.Get(index.Y); bool flg = true; while (flg = Program.Board.Next()) &#123; if (Program.Board.Get(index.X) != val.X|| Program.Board.Get(index.Y) != val.Y) &#123; break; &#125; &#125; if (!flg) break; if(checkBox1.Checked) Program.mForm.PaintQueens(Color.Orange); &#125; if (index.X != -1) &#123; index = Program.Board.Check(); &#125; if (index.X == -1) &#123; ++Solution; return true; &#125; &#125; return false; &#125; private void label4_Click(object sender, EventArgs e) &#123; &#125; private void label2_Click(object sender, EventArgs e) &#123; &#125; private void checkBox1_CheckedChanged(object sender, EventArgs e) &#123; &#125; public void Reset() &#123; label2.Text = (Ergodic = 0).ToString(); label4.Text = (Solution = 0).ToString(); Program.Board.Reset(); Program.mForm.PaintQueens(Color.Orange); &#125; &#125;&#125; 程序入口Program.cs： 123456789101112131415161718192021222324252627using System;using System.Collections.Generic;using System.Linq;using System.Threading.Tasks;using System.Windows.Forms;namespace EightQueen&#123; static class Program &#123; /// &lt;summary&gt; /// 应用程序的主入口点。 /// &lt;/summary&gt; static public EnumQueens Board; static public MainForm mForm; [STAThread] static void Main() &#123; Board = new EnumQueens(); Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run(mForm = new MainForm()); &#125; &#125;&#125; 其他系统自动产生的文件代码不贴了。]]></content>
      <tags>
        <tag>造轮子</tag>
        <tag>八皇后</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google Code Jam 2017 - Round1 C Problem A. Ample Syrup]]></title>
    <url>%2Fposts%2F16776.html</url>
    <content type="text"><![CDATA[https://code.google.com/codejam/contest/3274486/dashboard #Problem The kitchen at the Infinite House of Pancakes has just received an order for a stack of K pancakes! The chef currently has N pancakes available, where N ≥ K. Each pancake is a cylinder, and different pancakes may have different radii and heights. As the sous-chef, you must choose K out of the N available pancakes, discard the others, and arrange those K pancakes in a stack on a plate as follows. First, take the pancake that has the largest radius, and lay it on the plate on one of its circular faces. (If multiple pancakes have the same radius, you can use any of them.) Then, take the remaining pancake with the next largest radius and lay it on top of that pancake, and so on, until all K pancakes are in the stack and the centers of the circular faces are aligned in a line perpendicular to the plate, as illustrated by this example: A stack of pancakes with varying radii and thicknesses, obeying the rules in the statement. You know that there is only one thing your diners love as much as they love pancakes: syrup! It is best to maximize the total amount of exposed pancake surface area in the stack, since more exposed pancake surface area means more places to pour on delicious syrup. Any part of a pancake that is not touching part of another pancake or the plate is considered to be exposed. If you choose the K pancakes optimally, what is the largest total exposed pancake surface area you can achieve? #Input The first line of the input gives the number of test cases, T. T test cases follow. Each begins with one line with two integers N and K: the total number of available pancakes, and the size of the stack that the diner has ordered. Then, N more lines follow. Each contains two integers Ri and Hi: the radius and height of the i-th pancake, in millimeters. #Output For each test case, output one line containing Case #x: y, where x is the test case number (starting from 1) and y is the maximum possible total exposed pancake surface area, in millimeters squared. y will be considered correct if it is within an absolute or relative error of 10-6 of the correct answer. See the FAQ for an explanation of what that means, and what formats of real numbers we accept. #Limits 1 ≤ T ≤ 100. 1 ≤ K ≤ N. 1 ≤ Ri ≤ 106, for all i. 1 ≤ Hi ≤ 106, for all i. Small dataset 1 ≤ N ≤ 10. Large dataset 1 ≤ N ≤ 1000. #Sample ##Input 1234567891011121314151642 1100 20200 102 2100 20200 103 2100 10100 10100 104 29 37 110 18 4 ##Output 1234Case #1: 138230.076757951Case #2: 150796.447372310Case #3: 43982.297150257Case #4: 625.176938064 In Sample Case #1, the &quot;stack&quot; consists only of one pancake. A stack of just the first pancake would have an exposed area of π × R02 + 2 × π * R0 × H0 = 14000π mm2. A stack of just the second pancake would have an exposed area of 44000π mm2. So it is better to use the second pancake. In Sample Case #2, we can use both of the same pancakes from case #1. The first pancake contributes its top area and its side, for a total of 14000π mm2. The second pancake contributes some of its top area (the part not covered by the first pancake) and its side, for a total of 34000π mm2. The combined exposed surface area is 48000π mm2. In Sample Case #3, all of the pancakes have radius 100 and height 10. If we stack two of these together, we effectively have a single new cylinder of radius 100 and height 20. The exposed surface area is 14000π mm2. In Sample Case #4, the optimal stack uses the pancakes with radii of 8 and 9. #Key 可以用DP做。对DP还是不太熟练，一开始没排序，于是考虑的情况就多一些，总有小规模案例不正确，偏小。后来排个序考虑起来就方便多了。时间复杂度\(O(n^2)\)。难倒是不难，之前没Debug出来才是最气的。时间复杂度\(O(n^2)\)。 其实贪心就可以了，同学贪心做的但是时间复杂度也要\(O(n^2)\)，就是少很多赋值。 #Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;typedef long long lld;const int maxn = 1000 + 10;const long double pi = 3.1415926535897932;int T, N, K;struct RH &#123; lld R, H, A; &#125; arr[maxn];lld dp[maxn];bool cmp(RH &amp;a, RH &amp;b) &#123; if (a.R == b.R) return a.H &gt; b.H; return a.R &gt; b.R;&#125;int main()&#123; //freopen("A-small-practice.in", "r", stdin); //freopen("A-small-practice.out", "w", stdout); ios::sync_with_stdio(false); cin &gt;&gt; T; for (int now_case = 1; now_case &lt;= T; ++now_case) &#123; cin &gt;&gt; N &gt;&gt; K; for (int i = 0; i &lt; N; ++i) &#123; cin &gt;&gt; arr[i].R &gt;&gt; arr[i].H; arr[i].A = arr[i].R * arr[i].H * 2; arr[i].R *= arr[i].R; &#125; sort(arr, arr + N, cmp); memset(dp, 0, sizeof(dp)); for (int i = 0; i &lt; N; ++i) &#123; for (int j = K; j &gt; 1; --j) &#123; if (dp[j - 1] == 0) continue; lld tmp = dp[j - 1] + arr[i].A; if (dp[j] &lt; tmp) dp[j] = tmp; &#125; lld tmp = arr[i].A + arr[i].R; if (dp[1] &lt; tmp) dp[1] = tmp; &#125; cout &lt;&lt; "Case #" &lt;&lt; now_case &lt;&lt; ": " &lt;&lt; fixed &lt;&lt; setprecision(9) &lt;&lt; ((long double)dp[K] * pi) &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ACM笔记 - 利用FFT求卷积(求多项式乘法)]]></title>
    <url>%2Fposts%2F32822.html</url>
    <content type="text"><![CDATA[卷积 给定向量：\(a=(a_0,a_1,...,a_{n-1})\)，\(b=(b_0,b_1,...,b_{n-1})\) 向量和：\(a+b=(a_0+b_0,a_1+b_1,...,a_{n-1}+b_{n-1})\) 数量积（内积、点积）：\(a·b=a_0b_0+a_1b_1+...+a_{n-1}b_{n-1}\) 卷积：\(a \otimes b=(c_0,c_1,...,c_{2n-2})\)，其中\(c_k=\sum_{i+j=k}(a_ib_j)\) 例如：\(c_{n-1}=a_0b_{n-1}+a_1b_{n-2}+...+a_{n-2}b_1+a_{n-1}b_0\) 卷积的最典型的应用就是多项式乘法（多项式乘法就是求卷积）。以下就用多项式乘法来描述、举例卷积与DFT。 关于多项式 对于多项式\(A(x)\)，系数为\(a_i\),设最高非零系数为\(a_k\)，则其次数就是\(k\)，记作\(degree(A)=k\)。任何大于\(k\)的整数都是\(A(x)\)的次数界。 多项式的系数表达方式：\(A(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}=\sum^{n-1}_{i=0} a_jx^j\)（次数界为\(n\)）。 则多项式的系数向量即为\(a=(a_0,a_1,...,a_{n-1})\)。 多项式的点值表达方式：\(\{(x_0,y_0),(x_1,y_1),...,(x_{n-1},y_{n-1})\}\)，其中\(x_k\)各不相同，\(y_k=A(x_k)\)。 离散傅里叶变换（DFT） 离散傅里叶变换（Discrete Fourier Transform，DFT）。在信号处理很重要的一个东西，这里物理意义以及其他应用暂不予理睬。在多项式中，DFT就是系数表式转换成点值表示的过程。 快速傅里叶变换（FFT） 快速傅里叶变换（Fast Fourier Transformation，FFT）：快速计算DFT的算法，能够在\(O(n\log n)\)的时间里完成DFT。FFT只是快速的求DFT的方法罢了，不是一个新的概念。 在ACM-ICPC竞赛中, FFT算法常被用来为多项式乘法加速。FFT与其逆变换IFFT类似，稍微加几行代码。 求FFT要用到复数。一个简单的模板： 1234567891011121314struct Complex // 复数&#123; double r, i; Complex(double _r = 0, double _i = 0) :r(_r), i(_i) &#123;&#125; Complex operator +(const Complex &amp;b) &#123; return Complex(r + b.r, i + b.i); &#125; Complex operator -(const Complex &amp;b) &#123; return Complex(r - b.r, i - b.i); &#125; Complex operator *(const Complex &amp;b) &#123; return Complex(r*b.r - i*b.i, r*b.i + i*b.r); &#125;&#125;; 递归实现FFT模板：来源 123456789101112131415161718192021222324252627Complex* RecursiveFFT(Complex a[], int n)//n表示向量a的维数&#123; if(n == 1) return a; Complex wn = Complex(cos(2*PI/n), sin(2*PI/n)); Complex w = Complex(1, 0); Complex* a0 = new Complex[n &gt;&gt; 1]; Complex* a1 = new Complex[n &gt;&gt; 1]; for(int i = 0; i &lt; n; i++) if(i &amp; 1) a1[(i - 1) &gt;&gt; 1] = a[i]; else a0[i &gt;&gt; 1] = a[i]; Complex *y0, *y1; y0 = RecursiveFFT(a0, n &gt;&gt; 1); y1 = RecursiveFFT(a1, n &gt;&gt; 1); Complex* y = new Complex[n]; for(int k = 0; k &lt; (n &gt;&gt; 1); k++) &#123; y[k] = y0[k] + w*y1[k]; y[k + (n &gt;&gt; 1)] = y0[k] - w*y1[k]; w = w*wn; &#125; delete a0; delete a1; delete y0; delete y1; return y;&#125; 非递归实现。模板：（来源忘了） 1234567891011121314151617181920212223242526272829303132333435363738void change(Complex y[], int len) // 二进制平摊反转置换 O(logn) &#123; int i, j, k; for (i = 1, j = len / 2;i &lt; len - 1;i++) &#123; if (i &lt; j)swap(y[i], y[j]); k = len / 2; while (j &gt;= k) &#123; j -= k; k /= 2; &#125; if (j &lt; k)j += k; &#125;&#125;void fft(Complex y[], int len, int on) //FFT:on=1; IFFT:on=-1&#123; change(y, len); for (int h = 2;h &lt;= len;h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); for (int j = 0;j &lt; len;j += h) &#123; Complex w(1, 0); for (int k = j;k &lt; j + h / 2;k++) &#123; Complex u = y[k]; Complex t = w*y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w*wn; &#125; &#125; &#125; if (on == -1) for (int i = 0;i &lt; len;i++) y[i].r /= len;&#125; 利用FFT求卷积 普通的计算多项式乘法的计算，时间复杂度\(O(n^2)\)。而FFT先将多项式点值表示（\(O(n\log n)\)），在\(O(n)\)下完成对点值的乘法，再以\(O(n\log n)\)完成IFFT，重新得到系数表示。 步骤一（补0） 在两个多项式前面补0，得到两个2n次多项式，设系数向量分别为\(v_1\)和\(v_2\)。 步骤二（求值） 使用FFT计算\(f_1=DFT(v_1)\)和\(f_2=DFT(v_2)\)。则\(f_1\)与\(f_2\)为两个多项式在\(2n\)次单位根处的取值（即点值表示）。 步骤三（乘法） 把\(f_1\)与\(f_2\)每一维对应相乘，得到\(f\)，代表对应输入多项式乘积的点值表示。 步骤四（插值） 使用IFFT计算\(v=IDFT(f)\)，其中\(v\)就是乘积的系数向量。 综上 \(a \otimes b=IDFT_{2n}(DFT_{2n}(a)·DFT_{2n}(b))\)，即：\(a \otimes b=DFT^{-1}_{2n}(DFT_{2n}(a)·DFT_{2n}(b))\) \(A(x1)\otimes B(x2)\)： 123456fft(x1, len, 1);fft(x2, len, 1);for (int i = 0;i &lt; len;i++) &#123; x[i] = x1[i] * x2[i];&#125;fft(x, len, -1); #例题 ##1.2016 acm香港网络赛 A题 A+B Problem 网上的代码（当时没保留出处。。。） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;string.h&gt;#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;map&gt;#include &lt;set&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;utility&gt;#include &lt;vector&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#define LL long long#define N 200005#define INF 0x3ffffffusing namespace std;const double PI = acos(-1.0);struct Complex // 复数&#123; double r, i; Complex(double _r = 0, double _i = 0) :r(_r), i(_i) &#123;&#125; Complex operator +(const Complex &amp;b) &#123; return Complex(r + b.r, i + b.i); &#125; Complex operator -(const Complex &amp;b) &#123; return Complex(r - b.r, i - b.i); &#125; Complex operator *(const Complex &amp;b) &#123; return Complex(r*b.r - i*b.i, r*b.i + i*b.r); &#125;&#125;;void change(Complex y[], int len) // 二进制平摊反转置换 O(logn) &#123; int i, j, k; for (i = 1, j = len / 2;i &lt; len - 1;i++) &#123; if (i &lt; j)swap(y[i], y[j]); k = len / 2; while (j &gt;= k) &#123; j -= k; k /= 2; &#125; if (j &lt; k)j += k; &#125;&#125;void fft(Complex y[], int len, int on) //DFT和FFT&#123; change(y, len); for (int h = 2;h &lt;= len;h &lt;&lt;= 1) &#123; Complex wn(cos(-on * 2 * PI / h), sin(-on * 2 * PI / h)); for (int j = 0;j &lt; len;j += h) &#123; Complex w(1, 0); for (int k = j;k &lt; j + h / 2;k++) &#123; Complex u = y[k]; Complex t = w*y[k + h / 2]; y[k] = u + t; y[k + h / 2] = u - t; w = w*wn; &#125; &#125; &#125; if (on == -1) for (int i = 0;i &lt; len;i++) y[i].r /= len;&#125;const int M = 50000; // a数组所有元素+M，使a[i]&gt;=0const int MAXN = 800040;Complex x1[MAXN];int a[MAXN / 4]; //原数组long long num[MAXN]; //利用FFT得到的数组long long tt[MAXN]; //统计数组每个元素出现个数int main()&#123; int n = 0; // n表示除了0之外数组元素个数 int tot; scanf("%d", &amp;tot); memset(num, 0, sizeof(num)); memset(tt, 0, sizeof(tt)); int cnt0 = 0; //cnt0 统计0的个数 int aa; for (int i = 0;i &lt; tot;i++) &#123; scanf("%d", &amp;aa); if (aa == 0) &#123; cnt0++;continue; &#125; //先把0全删掉，最后特殊考虑0 else a[n] = aa; num[a[n] + M]++; tt[a[n] + M]++; n++; &#125; sort(a, a + n); int len1 = a[n - 1] + M + 1; int len = 1; while (len &lt; 2 * len1) len &lt;&lt;= 1; for (int i = 0;i &lt; len1;i++) &#123; x1[i] = Complex(num[i], 0); &#125; for (int i = len1;i &lt; len;i++) &#123; x1[i] = Complex(0, 0); &#125; fft(x1, len, 1); for (int i = 0;i &lt; len;i++) &#123; x1[i] = x1[i] * x1[i]; &#125; fft(x1, len, -1); for (int i = 0;i &lt; len;i++) &#123; num[i] = (long long)(x1[i].r + 0.5); &#125; len = 2 * (a[n - 1] + M); for (int i = 0;i &lt; n;i++) //删掉ai+ai的情况 num[a[i] + a[i] + 2 * M]--; /* for(int i = 0;i &lt; len;i++)&#123; if(num[i]) cout&lt;&lt;i-2*M&lt;&lt;' '&lt;&lt;num[i]&lt;&lt;endl; &#125; */ long long ret = 0; int l = a[n - 1] + M; for (int i = 0;i &lt;= l; i++) //ai,aj,ak都不为0的情况 &#123; if (tt[i]) ret += (long long)(num[i + M] * tt[i]); &#125; ret += (long long)(num[2 * M] * cnt0); // ai+aj=0的情况 if (cnt0 != 0) &#123; if (cnt0 &gt;= 3) &#123; //ai,aj,ak都为0的情况 long long tmp = 1; tmp *= (long long)(cnt0); tmp *= (long long)(cnt0 - 1); tmp *= (long long)(cnt0 - 2); ret += tmp; &#125; for (int i = 0;i &lt;= l; i++) &#123; if (tt[i] &gt;= 2) &#123; // x+0=x的情况 long long tmp = (long long)cnt0; tmp *= (long long)(tt[i]); tmp *= (long long)(tt[i] - 1); ret += tmp * 2; &#125; &#125; &#125; printf("%lld\n", ret); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>FFT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 786A - Berzerk]]></title>
    <url>%2Fposts%2F31985.html</url>
    <content type="text"><![CDATA[http://codeforces.com/problemset/problem/786/A #Description Rick and Morty are playing their own version of Berzerk (which has nothing in common with the famous Berzerk game). This game needs a huge space, so they play it with a computer. In this game there are n objects numbered from 1 to n arranged in a circle (in clockwise order). Object number 1 is a black hole and the others are planets. There's a monster in one of the planet. Rick and Morty don't know on which one yet, only that he's not initially in the black hole, but Unity will inform them before the game starts. But for now, they want to be prepared for every possible scenario. Each one of them has a set of numbers between 1 and n - 1 (inclusive). Rick's set is s1 with k1 elements and Morty's is s2 with k2 elements. One of them goes first and the player changes alternatively. In each player's turn, he should choose an arbitrary number like x from his set and the monster will move to his x-th next object from its current position (clockwise). If after his move the monster gets to the black hole he wins. Your task is that for each of monster's initial positions and who plays first determine if the starter wins, loses, or the game will stuck in an infinite loop. In case when player can lose or make game infinity, it more profitable to choose infinity game. #Input The first line of input contains a single integer n (2 ≤ n ≤ 7000) — number of objects in game. The second line contains integer k1 followed by k1 distinct integers s1, 1, s1, 2, ..., s1, k1 — Rick's set. The third line contains integer k2 followed by k2 distinct integers s2, 1, s2, 2, ..., s2, k2 — Morty's set 1 ≤ ki ≤ n - 1 and 1 ≤ si, 1, si, 2, ..., si, ki ≤ n - 1 for 1 ≤ i ≤ 2. #Output In the first line print n - 1 words separated by spaces where i-th word is &quot;Win&quot; (without quotations) if in the scenario that Rick plays first and monster is initially in object number i + 1 he wins, &quot;Lose&quot; if he loses and &quot;Loop&quot; if the game will never end. Similarly, in the second line print n - 1 words separated by spaces where i-th word is &quot;Win&quot; (without quotations) if in the scenario that Morty plays first and monster is initially in object number i + 1 he wins, &quot;Lose&quot; if he loses and &quot;Loop&quot; if the game will never end. #Examples 1234567891011121314input52 3 23 1 2 3outputLose Win Win LoopLoop Win Win Wininput84 6 2 3 42 3 6outputWin Win Win Win Win Win WinLose Win Lose Lose Win Lose Lose #Key 题意：一个有n个结点的环，第一个结点上是黑洞，其他为行星。现在有一个怪物可能在任意的行星上。甲乙两人可以顺时针驱赶怪物。甲每次可驱赶\(s1_1, s1_2,s1_3...\)个格子，共k1个可能。乙每次可驱赶\(s2_1, s2_2,s2_3...\)个格子，共k2种可能。谁把怪物刚好驱逐到黑洞里就赢。现在求：当怪物在第i个行星，甲（或乙）第一个驱赶时，甲（或乙）一定赢、一定输还是平局？ 思路：DFS+动态规划。（这里只考虑甲开局的情况，乙一样求）从黑洞开始反向逆推，即分别倒退\(s1_1, s1_2,s1_3...\)个格子，只要从这些点驱逐，甲是必赢的；换句话说，乙如果把怪物驱逐到了这些点，乙就输了，所以当乙能驱赶的点都是必输点时，当前点也是乙的必输点。 那么对于当前点：若能够将怪物驱逐到对手的必输点，该点必赢，对当前点DFS；若能够将怪物驱逐到对手的必赢点，为当前点计数，当当前点到所有可驱逐的点都会导致失败时，当前点即为必输点。 使用sch数组保存点是否访问过，即DP的记忆化搜索的思想。 #Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 7008int n, k[2], s[2][N];int win[2][N], sch[2][N], cnt[2][N];void init(int who) &#123; memset(win[who], 0, sizeof(int)*n); memset(sch[who], 0, sizeof(int)*n); memset(cnt[who], 0, sizeof(int)*n);&#125;void dp(int now, int who) &#123; sch[!who][now] = 1; // 能够允许dp递归下来的now都是已经确定输和赢的 /* for (int i = 0;i != n;++i) &#123; printf("win&#123;%d %d&#125; sch&#123;%d %d&#125; cnt&#123;%d %d&#125;\n", win[0][i], win[1][i], sch[0][i], sch[1][i], cnt[0][i], cnt[1][i]); &#125; puts("-----"); */ for (int i = 0;i != k[who];++i) &#123; int pre = (now - s[who][i] + n) % n; // who让怪物从pre跳到now if (!pre) continue; // 不可能 if (sch[who][pre]) continue; // 记忆搜索 if (!win[!who][now]) &#123; // 若从pre到now对面必输. (输的条件是sch[who][i]==1且win[who][i]==0) win[who][pre] = 1; // 这一步一定赢 dp(pre, !who); &#125; else if (win[!who][now]) &#123; // 若从pre到now对面必赢 if (++cnt[who][pre] == k[who]) &#123; // 当这一步怎么走都会导致对面赢 dp(pre, !who); &#125; &#125; &#125;&#125;int main()&#123; scanf("%d", &amp;n); for (int who = 0;who != 2;++who) &#123; scanf("%d", k + who); for (int i = 0;i != k[who];++i) scanf("%d", s[who] + i); &#125; init(0), init(1); dp(0, 0),dp(0, 1); for (int who = 0;who != 2;++who) &#123; for (int i = 1;i != n;++i) &#123; if (win[who][i]) printf("Win"); else if (sch[who][i]) printf("Lose"); else printf("Loop"); printf("%c", " \n"[i == n - 1]); &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM笔记 - 排序小技巧]]></title>
    <url>%2Fposts%2F3607.html</url>
    <content type="text"><![CDATA[#Description 一个数组，要求先对前n个数字排序（以方便后续操作）；又要求对前n+i个数字排序；又要求对前n+j ... 前n+k个数字排序（i、j、k的大小远小于n，且i、j、k间没有大小关系）。总之就是对一个不定的范围内数据要进行频繁的按大小顺序调用，但是这个范围边界变化不大，很多数据重叠，这样每次都对此次区间内数据排序，频繁排序的话很费时间。 例如一个数组\(\{1,3,6,5,2,4,1,9,0\}\)，一共9个数字，下标08。要求： 每次取一个区间，计算区间内\((最大值-最小值)^2+(次大值-次小值)^2+(次次大值-次次小值)^2+...\)的值。很容易想到对区间排个序，即可方便获得最大、次大值等。 对15排序：\(\{2,3,4,5,6\}\) 对16排序：\(\{1,2,3,4,5,6\}\) 对25排序：\(\{2,4,5,6\}\) 可以看出2、5、6始终在范围内，但每次都要针对所选区间重新排序，很麻烦。 既然大部分数据一直出现在范围内，现在就希望能够一次排序，应对所有情况。 #Key 继续使用上述的例子：\(Array = \{1,3,6,5,2,4,1,9,0\}\) 开个新数组作其索引：\(Index = \{0,1,2,3,4,5,6,7,8\}\) 令索引数组按照\(Array\)的大小关系排序，得\(Index = \{8,0,6,4,1,5,3,2,7\}\) 对于区间[1, 5]：从左向右找出第一个在[1, 5]的下标即为最小值：8不符合、0不符合、6不符合，4符合，那么最小值就是\(Array[4] = 2\)，次大值就是\(Array[1] = 3\) ... 即每次只需检测排序后当前位的数字的下标是否在该区间内即可。 #Sample 题目：https://hihocoder.com/problemset/problem/1384 一道贪心的题，期间需要对下标i到j、i到j+k之间的数字分别排序。是别人家的代码（他的原文链接，虽然我也不知道他是不是转别人的），就是在这学到的技巧。注意观察judge函数与judge2函数的差异，judge2函数即实现了上述排序思想。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include &lt;iostream&gt; #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;algorithm&gt; #include &lt;cmath&gt; using namespace std; typedef long long int ll; ll m,n,k; ll a[500050]; ll b[500050]; int cnt=0; inline bool cmp(int x,int y) &#123; return a[x]&lt;a[y]; &#125; bool judge(int l,int r) &#123; int pos=0; while(l+pos&lt;=r)b[pos]=a[l+pos],pos++; sort(b,b+pos); pos--; int mid=(pos-1)/2; ll res=0; for(int i=0; i&lt;=mid&amp;&amp;i&lt;m; i++) &#123; res+=(b[i]-b[pos-i])*(b[i]-b[pos-i]); if(res&gt;k) return false; &#125; return res&lt;=k; &#125; void init(int l,int r) &#123; cnt=0; for(int i=l; i&lt;=r; i++)b[cnt++]=i; sort(b,b+cnt,cmp); &#125; bool judge2(int r) &#123; int i,j,kk; ll res=0; for(i=0,j=cnt-1,kk=m; kk; i++,j--,kk--) &#123; while(i&lt;j&amp;&amp;b[i]&gt;r)i++; while(i&lt;j&amp;&amp;b[j]&gt;r)j--; if(i&gt;=j)break; res+=(a[b[i]]-a[b[j]])*(a[b[i]]-a[b[j]]); if(res&gt;k)break; &#125; return res&lt;=k; &#125; int main() &#123; int T; scanf("%d",&amp;T); while(T--) &#123; scanf("%lld%lld%lld",&amp;n,&amp;m,&amp;k); for(int i=0; i&lt;n; i++) scanf("%lld",&amp;a[i]); int ans=0; int l=0; while(l&lt;n) &#123; int kk=1; while(kk+l&lt;n&amp;&amp;judge(l,l+kk)) kk*=2; int first=l+kk/2,last=l+kk-1&lt;n?l+kk-1:n-1; init(l,last); int mid; int pos=l; while(first&lt;=last) &#123; if(judge2(mid=(first+last)/2)) &#123; first=mid+1; pos=mid; &#125; else last=mid-1; &#125; l=pos+1; ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>排序</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 746G - New Roads]]></title>
    <url>%2Fposts%2F51189.html</url>
    <content type="text"><![CDATA[#Description There are n cities in Berland, each of them has a unique id — an integer from 1 to n, the capital is the one with id 1. Now there is a serious problem in Berland with roads — there are no roads. That is why there was a decision to build n - 1 roads so that there will be exactly one simple path between each pair of cities. In the construction plan t integers a1, a2, ..., at were stated, where t equals to the distance from the capital to the most distant city, concerning new roads. ai equals the number of cities which should be at the distance i from the capital. The distance between two cities is the number of roads one has to pass on the way from one city to another. Also, it was decided that among all the cities except the capital there should be exactly k cities with exactly one road going from each of them. Such cities are dead-ends and can't be economically attractive. In calculation of these cities the capital is not taken into consideration regardless of the number of roads from it. Your task is to offer a plan of road's construction which satisfies all the described conditions or to inform that it is impossible. #Input The first line contains three positive numbers n, t and k (2 ≤ n ≤ 2·105, 1 ≤ t, k &lt; n) — the distance to the most distant city from the capital and the number of cities which should be dead-ends (the capital in this number is not taken into consideration). The second line contains a sequence of t integers a1, a2, ..., at (1 ≤ ai &lt; n), the i-th number is the number of cities which should be at the distance i from the capital. It is guaranteed that the sum of all the values ai equals n - 1. #Output If it is impossible to built roads which satisfy all conditions, print -1. Otherwise, in the first line print one integer n — the number of cities in Berland. In the each of the next n - 1 line print two integers — the ids of cities that are connected by a road. Each road should be printed exactly once. You can print the roads and the cities connected by a road in any order. If there are multiple answers, print any of them. Remember that the capital has id 1. #Examples 123456789101112131415161718192021222324252627282930313233343536373839input7 3 32 3 1output71 32 12 62 47 43 5input14 5 64 4 2 2 1output143 11 411 61 210 136 1010 1214 128 45 13 72 65 9input3 1 12output-1 #Key 题意：给一棵一共有\(n\)个结点（包括根节点）的树，一共有\(t+1\)层。除第一层只有一个根节点外，给出了其他每层的节点数。已知有\(k\)个结点没有子节点，要求用\(n-1\)个树枝连接所有结点，给出一种可能的连法。 可能的连法（可能）有很多，只要输出随便其中一个即可。 思路：先遍历一遍所有层，求出可行的最大最小的maxk、mink。如果题目给的k不在此范围内，则说明不能组成符合要求的树。这是唯二输出“-1”的情况。 求能产生的最少的无儿子结点： 求能产生的最多的无儿子结点： 令\(needk=k-mink\)，则除去一定有的无儿子结点，还有needk个无儿子结点需要手动产生。 然后遍历每一层，自己做出needk个无儿子结点即可。无需建立树，边遍历边输出。 第一次写出了最后一题，开心的一匹(ง •̀▿•́)ง。虽然写了就知道并不难。。。 #Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;int n, t, k;int arr[200010];int main()&#123; scanf("%d%d%d", &amp;n, &amp;t, &amp;k); arr[0] = 1; for (int i = 1;i &lt;= t;++i) &#123; scanf("%d", arr + i); &#125; arr[t + 1] = 0; int mink = 0; int maxk = 0; for (int i = 0;i &lt;= t;++i) &#123; maxk += arr[i] - 1; if (arr[i] &gt; arr[i + 1]) mink += arr[i] - arr[i + 1]; &#125; ++maxk; if (mink &gt; k || maxk &lt; k) &#123; printf("-1"); return 0; &#125; printf("%d\n", n); int needk = k - mink; // dead-ends that needed to created by myself int nown = 1; for (int i = 0;i != t;++i) &#123; int nextn = nown + arr[i]; if (!needk) &#123; if (arr[i + 1] &gt;= arr[i]) &#123; int err = arr[i + 1] - arr[i] + 1; int rem = arr[i] - 1; for (int j = 0;j != err;++j) &#123; printf("%d %d\n", nown, nextn++); &#125; ++nown; for (int j = 0;j != rem;++j) &#123; printf("%d %d\n", nown++, nextn++); &#125; &#125; else &#123; // arr[i + 1] &lt; arr[i] for (int j = 0;j != arr[i + 1];++j) &#123; printf("%d %d\n", nown++, nextn++); &#125; nown += arr[i] - arr[i + 1]; &#125; &#125; else &#123; if (arr[i + 1] &gt;= arr[i]) &#123; int nextnown = nextn; int nextnextn = nextn + arr[i + 1]; int err = arr[i + 1] - arr[i] + 1; for (int j = 0;j != err;++j) &#123; printf("%d %d\n", nown, nextn++); &#125; while (nextn != nextnextn) &#123; if (!needk) break; --needk; printf("%d %d\n", nown, nextn++); &#125; ++nown; while (nextn != nextnextn) &#123; printf("%d %d\n", nown++, nextn++); &#125; nown = nextnown; &#125; else &#123; // arr[i + 1] &lt; arr[i] int nextnown = nextn; int nextnextn = nextn + arr[i + 1]; printf("%d %d\n", nown, nextn++); while (nextn != nextnextn) &#123; if (!needk) break; --needk; printf("%d %d\n", nown, nextn++); &#125; ++nown; while (nextn != nextnextn) &#123; printf("%d %d\n", nown++, nextn++); &#125; nown = nextnown; &#125; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM笔记 - 组合数]]></title>
    <url>%2Fposts%2F36480.html</url>
    <content type="text"><![CDATA[#一、高中数学公式复习 \(C_n^m = \frac{n!}{m!(n-m)!}\) \(C_n^m = C_n^{n-m} = C^{m}_{n-1} + C^{m-1}_{n-1}\) \(C_n^0+C_n^1+C_n^2+...+C_n^n = \sum_{i=0}^{n}{C_n^i} = 2^n\) \(C_n^0+C_n^2+C_n^4+... = C_n^1+C_n^3+C_n^5+... = 2^{n-1}\) \(C_n^m+C_{n+1}^m+C_{n+2}^m+...+C_{n+m}^m = \sum_{i=0}^{m}C_{n+i}^{m} = C_{n+m+1}^{m+1}\) \(k C_n^k = nC_{n-1}^{k-1}\)， \(\frac{C_n^k}{k+1} = \frac{C_{n+1}^{k+1}}{n+1}\) （好吧这个没学过但是既然看到了就一并抄过来了） #二、快速求组合数取模C(n, m)%p 当n和p大小不同时方法有不同。 ##1. n很小，p随意，p不需要为素数 ###1) 原理 使用杨辉三角：\(C^{m}_{n}\%p = (C^{m-1}_{n-1}+C^{m}_{n-1})\%p\) 组合数C(n, m)其实就是杨辉三角第n行第m列的值（下标从0开始算的话）。每一行的各个值都是迭代上一行的结果。那么用二维数组打个表即可，for里套个for。 ###2) 我的模板 12345678910111213141516typedef long long lld;const int maxn = 1000+10;lld C_arr[maxn+10][maxn+10];void C_init(int n, int pr) &#123; for (int i = 0; i &lt;= n; i++) &#123; C_arr[i][0] = C_arr[i][i] = 1; for (int j = 1; j &lt; i; j++) C_arr[i][j] = (C_arr[i - 1][j - 1] + C_arr[i - 1][j]) % pr; &#125;&#125;lld C(int n, int m) &#123; return C_arr[n][m];&#125; ##2. n相对小（方便打表），p可以很大，p要求为素数 ###1) 原理 仅使用费马小定理： 若p是质数，且a,p互质，那么 a的(p-1)次方除以p的余数恒等于1， 即a^(p-1) ≡ 1 （mod p），所以a^(p-2) ≡ 1/a (mod p)。所以a的逆元为a^(p-2)。于是将\(\frac{n!}{m!(n-m)!}\) 中的除法全变成了乘法： 得到公式：\(C^{m}_{n}\%p = ((n!)\%p*[(n-m)!]^{p-2}\%p*(m!)^{p-2}\%p)\%p\) ###2) 我的模板 123456789101112131415lld pow_mod(lld a, lld b, const int &amp;pr)&#123; lld ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % pr; b &gt;&gt;= 1; a = a * a % pr; &#125; return ans;&#125;lld C(int n, int m)&#123; return fac(n) % p * pow_mod(fac(n - m), p - 2, p) * pow_mod(fac(m), p - 2, p);&#125; 可以看到这里最麻烦的是求阶乘fac(n)，如果n不大的话打表是极好的。n较大的话使用以下公式递归求得： \(n! = \frac{n!}{(\frac{n}{2})!\frac{n}{2})!}*[(\frac{n}{2})!]^2 = C^{n/2}_n*[(\frac{n}{2})!]^2\) 具体以后再写一篇求阶乘。 1234567891011lld C_small(lld n, lld m, const int &amp;pr)&#123; lld ans = 1; for (int i = 1; i &lt;= m; i++) &#123; lld a = (n - m + i) % pr; lld b = i % pr; ans = ans * (a * pow_mod(b, pr - 2, pr) % pr) % pr; //Fermat Theory &#125; return ans;&#125; 这是不打表的版本（其实就是没打表而已，没什么区别）。 ##3. n很大时要求p较小（p&lt;10^5），p要求为素数 ###1) 原理 使用Lucas定理：\(C^{m}_{n}\%p =(C^{m\%p}_{n\%p}C^{m/p}_{n/p})\%p\) 为什么要求p挺小，由公式就可以看出，p太大了的话\(C^{m\%p}_{n\%p}\)也依然很大。Lucas定理用到了费马小定理，要求p为素数。对于每个\(C^{m/p}_{n/p}\)，递归调用Lucas定理。可以看见n被p取模后很容易就变小了，所以要求p较小。 定理证明：网上看到的大神的博客 ###2) 我的模板 123456789101112131415161718192021222324252627282930typedef long long lld;lld pow_mod(lld a, lld b, const int &amp;pr)&#123; lld ans = 1; while (b) &#123; if (b &amp; 1) ans = ans * a % pr; b &gt;&gt;= 1; a = a * a % pr; &#125; return ans;&#125;lld C_small(lld n, lld m, const int &amp;pr)&#123; lld ans = 1; for (int i = 1; i &lt;= m; i++) &#123; lld a = (n - m + i) % pr; lld b = i % pr; ans = ans * (a * pow_mod(b, pr - 2, pr) % pr) % pr; //Fermat Theory &#125; return ans;&#125;lld C(lld n, lld m, const int &amp;pr) // Lucas's theorem&#123; if (m == 0 || m == n) return 1; return C_small(n % pr, m % pr, pr) * C(n / pr, m / pr, pr) % pr;&#125; C_small就是用求逆元求解，像法二一样做打表也是极好的。 如果n不大，p很大，用一下Lucas定理后也就相当于执行了法二，所以以后直接用Lucas即可。 #三、Vandermonde恒等式 范德蒙（Vandermonde）恒等式： \[C^{k}_{n+m} = \sum^{k}_{i=0}C^{i}_{n}C^{k-i}_{m}\] 其中k肯定得小于等于min(n,m)。 理解：从n个黑球、m个白球里找k个球有多少方式。 当\(k=min(n,m)\)时，这里假设\(m&lt;n\)，那就是\(k=m\)时，可以变个形： \[C^{k}_{n+m} = \sum^{k}_{i=0}C^{i}_{n}C^{m-k+i}_{m} = \sum^{m}_{i=0}C^{i}_{n}C^{i}_{m}\] 那意义就是n个黑球和m白个球中各找0个、1个、2个……m个对应颜色的球，一共有多少方法。 例题链接：Codeforces 785D - Anton and School - 2]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>组合数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces 785D - Anton and School - 2]]></title>
    <url>%2Fposts%2F64.html</url>
    <content type="text"><![CDATA[#Description As you probably know, Anton goes to school. One of the school subjects that Anton studies is Bracketology. On the Bracketology lessons students usually learn different sequences that consist of round brackets (characters &quot;(&quot; and &quot;)&quot; (without quotes)). On the last lesson Anton learned about the regular simple bracket sequences (RSBS). A bracket sequence s of length n is an RSBS if the following conditions are met: It is not empty (that is n ≠ 0). The length of the sequence is even. First charactes of the sequence are equal to &quot;(&quot;. Last charactes of the sequence are equal to &quot;)&quot;. For example, the sequence &quot;((()))&quot; is an RSBS but the sequences &quot;((())&quot; and &quot;(()())&quot; are not RSBS. Elena Ivanovna, Anton's teacher, gave him the following task as a homework. Given a bracket sequence s. Find the number of its distinct subsequences such that they are RSBS. Note that a subsequence of s is a string that can be obtained from s by deleting some of its elements. Two subsequences are considered distinct if distinct sets of positions are deleted. Because the answer can be very big and Anton's teacher doesn't like big numbers, she asks Anton to find the answer modulo 109 + 7. Anton thought of this task for a very long time, but he still doesn't know how to solve it. Help Anton to solve this task and write a program that finds the answer for it! #Input The only line of the input contains a string s — the bracket sequence given in Anton's homework. The string consists only of characters &quot;(&quot; and &quot;)&quot; (without quotes). It's guaranteed that the string is not empty and its length doesn't exceed 200 000. #Output Output one number — the answer for the task modulo 109 + 7. #Examples 1234567891011121314input)(()()output6input()()()output7input)))output0 #Note In the first sample the following subsequences are possible: If we delete characters at the positions 1 and 5 (numbering starts with one), we will get the subsequence &quot;(())&quot;. If we delete characters at the positions 1, 2, 3 and 4, we will get the subsequence &quot;()&quot;. If we delete characters at the positions 1, 2, 4 and 5, we will get the subsequence &quot;()&quot;. If we delete characters at the positions 1, 2, 5 and 6, we will get the subsequence &quot;()&quot;. If we delete characters at the positions 1, 3, 4 and 5, we will get the subsequence &quot;()&quot;. If we delete characters at the positions 1, 3, 5 and 6, we will get the subsequence &quot;()&quot;. The rest of the subsequnces are not RSBS. So we got 6 distinct subsequences that are RSBS, so the answer is 6. #Key 题意：给一大串前后括号组成的字符串，长度为n，从中任取若干括号、按原顺序排列，要求取出的括号前一半都是“(”，后一半都是&quot;)&quot;，问有多少种组合（即组成如((((()))))）。如)(()() （没个括号分别编号1~6），有2 4、2 6、3 4、3 6、5 6、2 3 4 6 6种。 事后看了题解才AC。很容易想到的是，读取时只存储每一个后括号之前一共有多少个前括号，例如)(()()，有三个后括号，只需存储0 2 3即可（对该数组命名为sum，并假设一共m个后括号）。然后遍历这个sum数组：对于第i个后括号，左侧有sum[i]个前括号，右侧有m-i个后括号（方便起见令ai=sum[i]，bi=m-i），以当前后括号为第一个符合符合“((((()))))”的后括号，则当前后括号左侧的后括号都不可能满足，当前后括号右侧的前括号也不满足。则“以当前后括号为第一个符合的后括号”一共有 \[ C^{1}_{a_i}*C^{0}_{b_i} + C^{2}_{a_i}*C^{1}_{b_i} + C^{3}_{a_i}*C^{2}_{b_i} + ... + C^{min(a_i,b_i+1)}_{a_i}*C^{min(a_i,b_i+1)-1}_{b_i} = \sum_{i=1}^{min(a_i,b_i+1)} C_{a_i}^{i}*C_{b_i}^{i-1} = \sum_{i=1}^{min(a_i,b_i+1)} C_{a_i}^{a_i-i}*C_{b_i}^{i-1} = \sum_{i=0}^{min(a_i-1,b_i)} C_{a_i}^{a_i-i-1}*C_{b_i}^{i} \] 注意a指的是当前后括号左侧的前括号个数，b为当前的后括号右侧后括号个数，故b不包括当前后括号。 最后根据范德蒙恒等式推倒： 若\(min(a_i-1,b_i) = a_i-1\)： \[ \sum_{i=0}^{min(a_i-1,b_i)} C_{a_i}^{a_i-i-1}*C_{b_i}^{i} = \sum_{i=0}^{a_i-1} C_{a_i}^{a_i-i-1}*C_{b_i}^{i} = C_{a_i+b_i}^{a_i-1} \] 若\(min(a_i,b_i+1) = b_i+1\)： \[ \sum_{i=1}^{min(a_i,b_i+1)} C_{a_i}^{i}*C_{b_i}^{i-1} = \sum_{i=1}^{b_i+1} C_{a_i}^{i}*C_{b_i}^{b_i+1-i} = C_{a_i+b_i}^{b_i+1} \] 合起来还是\(C_{a_i+b_i}^{min(a_i,b_i)}\) 那么最终要做的就是把m个组合数求和。因而求组合数也是个难点。这里直接盗用了上面链接的大神的模板。自己写了个求组合数的博客。这里还是预先打表了，这样快很多。 #Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#define MX 200005using namespace std;typedef long long LL;const int p = 1e9 + 7;int sum[MX] = &#123; 0 &#125;; // store the sum of all the '(' before the last ')'LL ans = 0;LL fac[200005], fac_exp[200005];LL ModExp(LL a, LL b, LL p)&#123; LL ans = 1; while (b) &#123; if (b &amp; 1) ans = ans*a%p; a = a*a%p; b &gt;&gt;= 1; &#125; return ans;&#125;LL C(int n, int m)&#123; return fac[n] % p * fac_exp[n - m] % p * fac_exp[m] % p;&#125;int main()&#123; fac[0] = fac_exp[0] = 1; for (int i = 1;i &lt;= 200000;i++) &#123; fac[i] = (fac[i - 1] * i) % p; fac_exp[i] = ModExp(fac[i], p - 2, p); &#125; //freopen("in.txt", "r", stdin); string s; getline(cin, s); int num_left = 0, num_right = 0; for (char c : s) &#123; if (c == '(') ++num_left; else &#123; sum[num_right + 1] = sum[num_right] + num_left; ++num_right; num_left = 0; &#125; &#125; for (int i = 1;i &lt;= num_right;++i) &#123; int right = num_right - i + 1; int left = sum[i]; ans += C(right - 1 + left, right); &#125; cout &lt;&lt; (int)(ans%p); return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Machine Learning Week3 - 正则化(Regularization)]]></title>
    <url>%2Fposts%2F13990.html</url>
    <content type="text"><![CDATA[欠拟合（Underfitting）与过拟合（Overfitting） 上面两张图分别是回归问题和分类问题的欠拟合和过度拟合的例子。可以看到，如果使用直线（两组图的第一张）来拟合训，并不能很好地适应我们的训练集，这就叫欠拟合（Underfitting），但是如果x的次数太高（两组图的第三张），拟合虽然很好，但是预测能力反而变差了，这就是过拟合（Overfitting）。 对于欠拟合，我们可以适当增加特征，比如加入x的多次方。通常这很少发生，发生的多的都是过拟合。那么如何处理过度拟合呢？ 1. 丢弃一些不能帮助我们正确预测的特征。可以是手工选择保留哪些特征，或者使用一些模型选择的算法来帮忙（例如 PCA）。 2. 正则化。 保留所有的特征，但是减少参数的大小(magnitude)。 加入正则化的代价函数 假设上面的线性回归过拟合例子使用使用的模型是： 我们可以看出这些高次项（3次方、4次方）导致了过拟合，高次项参数大了，从图像来看就是会变得非常曲折，高次项参数小了图像就会较为平整。所以这里我们要做的就是一定程度上减小高次项参数，削弱高次项的影响力。我们的做法是修改代价函数，给theta3、theta4一些惩罚，使得最终选出来的theta3、theta4比较小： J(theta)= 通过这样的代价函数选择出的theta3 和theta4 对预测结果的影响就比之前要小许多，因为theta3、4一试图变大，代价就会变大很多，那么在使用梯度下降最小化J(theta)时，theta3、4就会变得比较小。 假如我们有非常多的特征，我们并不知道其中哪些特征我们要惩罚，我们将对所有的特征进行惩罚，并且让代价函数最优化的软件来选择这些惩罚的程度。这样的结果是得到了一个较为简单的能防止过拟合问题的假设: 其中 lambda 又称为正则化参数（Regularization Parameter）。 根据惯例,我们不对theta0进 行惩罚。否则得到的图像比较靠近x轴，那整个模型就偏离数据了。 经过正则化处理的模型与原模型的可能对比如下图所示: 这里的lambda的选择也是较为关键的一点，如上图，theta太小甚至为0，那可能导致过拟合，而lambda太大，图像就会得到一条类似与平行于x轴的直线。 正则化后的线性回归、逻辑回归模型 正则化线性回归 重新将新的代价函数带入梯度下降算法，经过求导、化简后，得到的梯度下降如下： 对于j=1,2,...,n，thetaj的更新式子可以化简为： 可以看到（不看theta0），算法的变化就在于theta每次减少了一个额外的alpha*lambda/m。 同样的，可以在正规方程使用正则化： 正则化逻辑回归 同样带入化简，得： 发现得到的式子和线性回归一样，当然，两者的区别之前已经分析过，h(x)不同。]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Machine Learning Week3 - 逻辑回归(Logistic Regression)]]></title>
    <url>%2Fposts%2F33431.html</url>
    <content type="text"><![CDATA[逻辑回归算法是分类算法，虽然这个算法的名字中出现了“回归”，但逻辑回归算法实际上是一种分类算法，我们将它作为分类算法使用。。 分类问题：对于每个样本，判断它属于N个类中的那个类或哪几个类。通常我们判定一个样本，若我们预测它的确属于这个类的可能性大于50%，则认为它属于这个类。当然具体选择50%还是70%还是其他要看具体情况，这里先默认50%。 线性回归的局限性在分类问题的例子中变得不可靠：这是一个用来预测肿瘤是否呈阴性的模型，当一个肿瘤的尺寸大于一个数，我们就认为这个肿瘤呈阴性。我们现在新增了一个数据，结果导致整个模型的参数变化很大。如下图，在新加入最右侧数据后，50%的分水岭右移了不止一点点。而根据常识这个数据本应对我们的预测没有什么影响。 对此类问题引入新模型： 对于g(z)=1/(1+e^(-z))这个模型，对国内读过高中的学生都能看懂都想得出它的函数图像，当z&gt;0时g大于0.5，z&lt;0时g小于0.5，z=0时g=0.5。我们以此判定样本属于一个类的几率。现在上图这个模型就是g(theta.T X)（“.T”代表转置矩阵），即我们需要找到参数区分出50%这一边界。 对于下图的数据，我们只需使用一条直线分出0.5的交界处即可。 而对于下面的数据，我们觉得得使用曲线来适应才能分割y=0与y=1的区域。h(x)如图所示，最终得到一个类似圆形的形状。 对于更复杂的形状，我们可以使用更为复杂的模型。 不过以上的分类问题只有两个类（叫做二元分类问题），只需回答一个数据属于A还是B即可。后面还有复杂些的多类别分类，后面会讲，先仅仅分析叫做二元分类。 1.二元分类问题的代价函数 对于线性回归模型,我们定义的代价函数是所有模型误差的平方和。理论上来说,我们 也可以对逻辑回归模型沿用这个定义,但是问题在于,当我们将h(x) 带入到线性回归模型适用的代价函数中时,我们得到的代价函数将是一个非凸函数(non-convex function)。 这意味着我们的代价函数有许多局部最小值,这将影响梯度下降算法寻找全局最小值（是的即将讲的新模型能够确保找到全局最小值，因为它是凸函数(convex)，只有一个极小值，那就是最小值。具体下面讲）。 于是重新定义逻辑回归的代价函数： 其中 简化上式得： Cost带入J最终得到的代价函数： h(x)与 Cost(h(x),y)之间的关系如下图所示： 这样构建的Cost(h θ (x),y)函数的特点是:当实际的y=1且 h也为1时误差为0，当y=1但h不为1时误差随着h的变小而变大；当实际的y=0且h也为0时代价为0，当y=0但h不为0时误差随着h的变大而变大。 2.对二元分类问题使用梯度下降 知道了代价函数然后像对线性回归一样使用梯度下降算法： 求导后得到： （原视频少了1/m！我用红色补上了。） 于是乎我们惊奇的发现，这个式子的样子和之前用在线性回归的一样！而他们的J(θ)显然是不一样的。那么,线性回归和逻辑回归是同一个算法吗？ 显然不是，要知道，我们是对x求导，而不是对h(x)求导，而两者的h(x)完全不同，所以求导的过程中要展开h(x)对x进行求导，所以结果其实是完全不同的。只不过这两个求导结果刚好可以重新用h(x)包装起来表示。所以逻辑函数的梯度下降，跟线性回归的梯度下降实际上是两个完全不同的东西。 特征缩放 与线性回归一样的是，别忘记特征缩放。这很重要，特征缩放后可以更快地到达最优解，并防止反复的震荡。具体不再展开讲了。 梯度下降必能找到该代价函数的全局最小值 In this video, we will define the cost function for a single train example. The topic of convexity analysis is now beyond the scope of this course, but it is possible to show that with a particular choice of cost function, this will give a convex optimization problem. Overall cost function j of theta will be convex and local optima free. 在这个视频中，我们定义了单训练样本的代价函数,凸性分析的内容是超出这门课的范围的，但是可以证明我们所选的代价值函数会给我们一个凸优化问题。代价函数 J(θ)会是一个凸函数，并且没有局部最优值。 吴恩达老师的视频这里说了这个新的代价函数是凸函数，所以使用梯度下降一定能达到全局最小值。证明我也暂时不管它了。 3.多类别分类（Multiclass Classification） 上面讲了二元分类问题的计算方法，但是如果问题有很多个类，要你预测样本属于这么多类里的哪一个，要怎么做呢？通常我们使用“一对余”方法。 “一对余”方法：将“n类别问题”转换成“n个二元分类问题”。 比如现在有3个类ABC要划分，我们对每个类单独进行分析。比如对于类B，把所有数据划分成两类，属于B的（正样本）和不属于B的（负样本），我们不需要知道它是属于A还是C的，只需知道它不是B即可。于是对于每个类都变成了一个二元问题，一共3个二元问题。我们要做的就是训练这三个分类器。当预测一个新数据的分类时，我们选择3个h(x)里值最高的那个。 4.最小化代价函数的其他算法 一些梯度下降算法之外的选择：除了梯度下降算法以外，还有一些常被用来令代价函数最小的算法，这些算法更加复杂和优越，而且通常不需要人工选择学习率，通常比梯度下降算法要更加快速。这些算法有：共轭梯度(Conjugate Gradient)，局部优化法(Broyden fletchergoldfarb shann,BFGS，或叫变尺度法)和有限内存局部优化法(L-BFGS，或叫限制变尺度法)。虽然我暂时不打算看，但Mark一下。]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Logistic Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Machine Learning Week1,2 - 线性回归(Linear Regression)]]></title>
    <url>%2Fposts%2F42401.html</url>
    <content type="text"><![CDATA[线性回归属于回归问题。对于回归问题，解决流程为： 给定数据集中每个样本及其正确答案，选择一个模型函数h（hypothesis，假设），并为h找到适应数据的（未必是全局）最优解，即找出最优解下的h的参数。这里给定的数据集取名叫训练集（Training Set）。不能所有数据都拿来训练，要留一部分验证模型好不好使，这点以后说。先列举几个几个典型的模型： 最基本的单变量线性回归： 形如h(x)=theta0+theta1*x1 多变量线性回归： 形如h(x)=theta0+theta1x1+theta2x2+theta3*x3 多项式回归（Polynomial Regression）： 形如h(x)=theta0+theta1x1+theta2(x2^2)+theta3*(x33) 或者h(x)=ttheta0+theta1x1+theta2sqr(x2) 但是我们可以令x2=x22，x3=x3^3，于是又将其转化为了线性回归模型。虽然不能说多项式回归问题属于线性回归问题，但是一般我们就是这么做的。 所以最终通用表达式就是： 不用在意图片h(x)中间夹的theta字符，只是一个习惯而已，不写theta也可以的。还有我不知道怎么在博客里输入theta那些字符，凑合着看。 1.代价函数（Cost Function） 计算建立的模型对真实数据的误差，叫建模误差（Modeling Error）。误差越低，模型对数据拟合度越高。例如给出： m：训练集的样本个数 n：训练集的特征个数（通常每行数据为一个x(0)=1与n个x(i) (i from 1 to n)构成，所以一般都会将x最左侧加一列“1”，变成n+1个特征） x：训练集（可含有任意多个特征，二维矩阵，行数m，列数n+1，即x0=1与原训练集结合） y：训练集对应的正确答案（m维向量，也就是长度为m的一维数组） h(x)：我们确定的模型对应的函数（返回m维向量） theta：h的初始参数（常为随机生成。n+1维向量） 得代价函数J(theta)： （图中等号左侧的theta0,theta1...thetan以后直接用向量theta表示。） 有了代价函数，我们的目的就是找到一组参数theta使得代价最小，稍有常识的人就能知道，这个函数肯定是有最小值的，不会出现负无穷下面两个标题就是讲了最小化J(theta)的两个方法。 2.正规方程（Normal Equation） 吴恩达老师这个是放在最后讲的，但是对于中国学生，我觉得其实这个先讲反而更好。 正规方程是针对某些线性回归问题的方案，例如对于我们熟知的 要把上面的代价方程找出theta最小值，本质上就是二次函数嘛。我们直接求导计算导数为0处即为最小值。求解theta轻轻松松一步到位。同样对于多参数的线性回归，只要求偏导即可获得每个theta值到达全局最优解。。 那么现在在矩阵中，假设我们的训练集矩阵为X，“正确答案”为y，则theta可以如上面所说的各自求偏导数直接求出。但是直接这样做非常耗时，因此数学家由此推导出了更好的方法： 这个公式本质就是从上面求导这一方法推导出来的。推导过程：https://zhuanlan.zhihu.com/p/22474562 当然很显然的是，如果矩阵不可逆就不能用这个方案了（出现这个情况的原因可能是1.各个特征不独立、有关联，比如出现了重量和质量两个特征（至少在同一个地方两者完全成比例）；2.特征数量大于所给训练集样本个数）。 3.（批量）梯度下降算法（(Batch) Gradient Descent） 上述方法简单易使用但是局限高，而梯度下降算法使用更广泛更通用。当然这个算法放到现在也有人说它过时了，但还是很有必要学习个。 先定下一组预设参数，通常可以是随机生成的，不断微调h的参数直到达到代价J的局部最小值（Local Minimum）。因此此算法并不一定能找到全局最小值（Global Minimum）。根据初始theta选择的不同可能找到不同局部最小值、导致不同结果。下图很形象的表现了这一点。 具体实现：我们循环以下算法直到到达局部最小值。 alpha是学习率(Learning Rate)，其大小决定了每次循环中theta改变的大小，决定了梯度下降步子迈多大。寻找alpha很关键。alpha小了，每次循环步子也迈的小，要很多步才能到达最低点，速度慢。alpha太大了，可能一下就迈过头了，越过了最低点，并不断一次次越过来越过去就是下不来，太大了甚至可能导致循环无法收敛、甚至发散。 可以看出，随着算法越来越接近局部最小值，J’越小，下降速度越慢，因此alpha只需是个定值，无需在靠近最小值时一起减小alpha。 注意（FBI Warning），每个theta i必须是同步变换，即不能修改了theta1为新计算得的值后再计算要修改的theta2，这样计算出的theta2是基于是修改后的theta1而得到的。因此要计算出全部新theta后统一赋值。 该梯度下降算法有时也被称为批量梯度下降。“批量”指的是在梯度下降的每一步中,我们都用到了所有的训练样本。 线性回归上运用梯度下降 按照梯度下降要求求得代价方程J的导数J’（为了方便书写记J的导数为J’），而对于线性回归模型的J方程上面已经给出，所以将J求导带入，得到： 将求导部分求出来，即： 其中 特征缩放（Feature Scaling） 以房价为例子，现在假设房子价格只受房屋的尺寸（对应theta1）和房间的数量（theta2）影响，房子尺寸的值为 0-2000 平方英尺，而房间数量的值是 0-5，以两个参数为横纵坐标绘图，可以看出图像很扁，梯度下降算法需要非常多次迭代才能收敛。 具体为什么会导致迭代很多次，老师的解释是根据图来的，虽然很直观但是根本原因他没说清楚，现在分析下来我认为原因在于，梯度下降时，alpha对于每个参数都是一样的（现在假定alpha为1），则根据最终得到的算法（“Repeat”里面那行），alpha、1/m、h(xi)-y(i)都是一样的，不一样的只有xj(i)（上标下标不会打，凑合着看），那么对于房屋尺寸，尺寸都上千了，数值很大，则theta1的变化也很大，因此对于theta1，alpha太大了，看那张草图，已经导致了越过最小值的情况。而对于theta2呢，房间一共不会超过5，因此对于theta2，alpha太小了，每次就靠近最小值一点点。 这时候我们就需要特征缩放，把所有参数缩放到-1～1的范围，让alpha适应每个参数，每个参数每次的变化都相当。 具体实施就是令 其中u是平均值，s是标准差。把每个数据都如上修改范围，相当于预处理，这样可以对后面线性回归有帮助。而对于多项式回归模型，在运行梯度下降算法前,特征缩放就显得更有必要了。 其实我个人觉得给每个参数分配一个alpha也是可行的一种方案，不过仔细想想，这样的确实麻烦了点，因为找出合适的alpha不是那么容易的事情。 学习率alpha的选择 上面说到了，alpha太大，步子大了容易扯到蛋，可能导致越过最小值甚至无法收敛；alpha小了又显得娘炮，太慢了。 通常可以考虑尝试这些学习率：α=0.01,0.03,0.1,0.3,1,3,10，多试一试找出比较好的。 局部最优解还是全局最优解 之前也明确说了，梯度下降不一定能获得全局最优解，但是网上那么多教程、博客还是写的很混乱，或者说非常不严谨，都说“到达全局最小值”；包括在吴恩达老师的视频里，也不是描述的很清爽。搞得我很懵。所以问题是，梯度下降用来求最优解，哪些问题可以求得全局最优？哪些问题可能获得局部最优解？ 如果函数图像只有一个凹坑，像吴大大视频里的例子全都是一个峰的，那梯度下降最终求得的肯定是全局最优解，应该说获得的局部最优解就是全局最优解。然而对于有多个凹坑的问题，梯度下降获得的局部最优解很有可能的最终结果不是全局最优。对于线性回归问题这也是一样的，网上看到有人说线性回归问题只有一个全局最小值没有局部最小值，感觉这不对，我记得吴恩达老师有说过线性回归也可以有极小值存在的。先mark，等我验证后更新。 但是正规方程呢？当有多个极小值时他一定会返回最小值吗？这点我也不清楚，但是按照周志华老师的机器学习的书上说，当特征数量大于所给训练集样本个数时使用正规方程，会得到多个解，而具体返回哪个解就看算法的选择了。 4.正规方程、梯度下降的选择、比较 梯度下降 正规方程 需要选择学习率 α 不需要 需要多次迭代 一次运算得出 当特征数量 n 大时也能较好适用 需要计算(X.T X)^-1。如果特征数量 n 较大则运算代价大,因为矩阵逆的计算时间复杂度为 O(n 3 ),通常来说当 n 小于 10000 时还是可以接受的 适用于各种类型的模型 只适用于线性模型,不适合逻辑回归模型等其他模型 总结一下,只要特征变量的数目并不大,标准方程是一个很好的计算参数 θ 的替代方法。具体地说,只要特征变量数量小于一万,我通常使用标准方程法,而不使用梯度下降法。 随着我们要讲的学习算法越来越复杂,例如,当我们讲到分类算法,像逻辑回归算法,我们会看到, 实际上对于那些算法,并不能使用标准方程法。对于那些更复杂的学习算法,我们将不得不仍然使用梯度下降法。因此,梯度下降法是一个非常有用的算法,可以用在有大量特征变量的线性回归问题。或者我们以后在课程中,会讲到的一些其他的算法,因为标准方程法不适合或者不能用在它们上。但对于这个特定的线性回归模型,标准方程法是一个比梯度下降法更快的替代算法。所以,根据具体的问题,以及你的特征变量的数量,这两种算法都是值得学习的。 补充： 5.随机梯度下降算法（Stochastic Gradient Descent） 普通的梯度下降算法更新一次theta需要载入所有样本，也就是说一次更新的计算量为m*n^2（m为样本数量，n为参数数量）。这样如果m 非常大，我们需要把所有样本都载入，才能更新一次参数theta，更新一次theta的时间太久了。 而随机梯度下降算法是每次只取一个样本，马上就更新theta。 也就是说，每次更新theta的计算量为n^2，当m很大的时候，随机梯度下降迭代一次的速度要远高于梯度下降。 当然有弊有利，利就是更新速度很快，弊就是梯度下降的方向不稳。虽然大致方向上还是向着最低点的，但是一路上都在来回移动。要知道毕竟一套参数不能完全满足所有样本，而每个样本都试图将参数向自己方向靠。（说起来这样不应该很可能没法收敛吗？最后会不会一直在最优解附近游荡。）]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
        <tag>Linear Regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Coursera Machine Learning Week0 - 目录大纲]]></title>
    <url>%2Fposts%2F58377.html</url>
    <content type="text"><![CDATA[目录会根据我的学习进度而更新，给自己列一个大纲以系统地看待整个学习过程。 #学习资料来源 学习的是Coursera上吴恩达（Andrew Ng）老师的机器学习视频（课程传送门，最近在“最强大脑”上看到他了好激动啊，原来他去做百度大脑了呀），笔记根据此系列视频整理。笔记顺序不一定与原教程一样，希望加入些自己的思考。 同时使用了网上找到的黄海广博士的对于吴大大视频教程的笔记（传送门）。因为我一开始看视频没做笔记，现在忘得差不多啦，现在打算写个笔记，重新去看视频再整理太麻烦，网上竟然找到这一神器，视频内容全都用中文写在里面了，棒！（不过还是不太好意思发邮件给他自我介绍。。。先暂时做伸手党吧。。。） #机器学习分类 ##1.监督学习（Supervised Learning） 给定数据集，数据集的每个样本均有提供“正确答案”，根据这些样本进行预测。例子： 垃圾邮件分类：根据已知的垃圾邮件特征判断新邮件是否垃圾； 判定肿瘤是否恶性：根据已知恶性、良性特征判断病人肿瘤情况。 ###1)回归问题（Regression） 给定数据集中每个样本的正确答案，运用到机器学习中，推出一个连续的输出。 如线性回归（Linear Regression）。 ###2)分类问题（Classification） 给定数据集中每个样本的正确答案，运用到机器学习中，推出一组离散的结果。 如逻辑回归（Logistic Regression）。 注意：逻辑回归算法是分类算法,我们将它作为分类算法使用。有时候可能因为这个算法的名字中出现了“回归”使你感到困惑，但逻辑回归算法实际上是一种分类算法。 ##2.无监督学习（Unsupervised Learning） 只给定数据集，每个样本没有标签、没有提前告知的“正确答案”，要求在数据中自动找出某种结构。例子： 新闻分类：自动将同一主题的新闻分类； DNA检测：判断每个个体是否有一个特定基因。 辨识人声：从一段音频分出每个人的音轨。 （待更新）]]></content>
      <categories>
        <category>Machine Learning</category>
        <category>Coursera Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>Coursera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SciPy、Matplotlib基础操作]]></title>
    <url>%2Fposts%2F29569.html</url>
    <content type="text"><![CDATA[NumPy、SciPy、Matplotlib，Python下机器学习三大利器。上一篇讲了NumPy基础操作，这节讲讲SciPy和Matplotlib。目前接触到的东西不多，以后再遇到些比较常用的再更新。 scipy是基于numpy的扩充，所以安装时要先安装numpy再安装scipy。scipy的命名空间包含numpy，所以只需import scipy即可，numpy不用import。（所以以下有些东西可能是numpy里的我没分清楚，反正一并写了吧。） 12import scipy as spimport matplotlib.pyplot as plt 首先从文件导入数据，使用genfromtxt函数。文件是《Python语言构建机器学习系统（第二版）》里提供的数据：web_traffic.tsv。读取后把x与y分开。而且里面有几个nan数据，得事先踢掉： 12345data = sp.genfromtxt("web_traffic.tsv",delimiter="\t")x = data[:,0]y = data[:,1]x = x[~sp.isnan(y)]y = y[~sp.isnan(y)] 然后我们想可视化这些数据，以图表给出，那就用到matplotlib了： 12345678plt.scatter(x, y, s=6) # 在图标上产生散点，s代表绘制的点的粗细plt.title("Web traffic") # 标题plt.xlabel("Time") # x轴标签plt.ylabel("Hits/hour") # y轴标签plt.xticks([w*7*24 for w in range(10)], ["week %i" % w for w in range(10)]) # 更改x轴的默认刻度显示，以一星期为一个刻度，range中数字10表示x刻度最多显示到第10周plt.autoscale(tight=True)plt.grid(True,linestyle='-',color='0.75') 最后plt.show()以显示窗口。 这里写图片描述 然后我们用二次函数作为模型，并使得函数最好的适应数据。 1fp,residuals,rank,sv,rcond = sp.polyfit(x,y,2,full=True) polyfit函数直接帮我们找到了这个使得方差最小的直线的参数，参数存在f1p里面。里面那个参数2就代表产生二次函数，3代笔3次函数，50就是50次函数。我们print fp，得到： 1[ 1.05322215e-02 -5.26545650e+00 1.97476082e+03] full=True使得这个函数返回更多的东西，返回一些额外的后台信息，比如误差（error），就存在那个residuals里： 1[ 1.79983508e+08] poly1d将参数转换成可识别的函数格式，可以把它当做普通python的函数用。注意是poly“1”d，是1不是l。不知道有没有poly2d。 1f = sp.poly1d(fp) linspace函数产生一次函数从x=0到x=x[-1]区间内的函数的值，作为一维矩阵存储。1000那个数字代表产生几个值，数字越大产生的值越多。当然对于一次函数，值为2其实就够了。 1fx = sp.linspace(0,x[-1],1000) 值为1000时： 值为5时： 就只计算了5个值，明显弧度不行了。 然后以下plot函数就是把得到的二次函数放到figure上的。legend产生左上角那个d=2标示。 12plt.plot(fx,f(fx),linewidth=2)plt.legend(["d=%i" % f.order],loc="upper left") 同理可得其他次数的最佳适应的函数。以下写了个小小的成品，计算了一次、二次、五十三次函数： 12345678910111213141516171819202122232425262728293031323334353637import scipy as spimport matplotlib.pyplot as pltdata = sp.genfromtxt("web_traffic.tsv",delimiter="\t")x = data[:,0]y = data[:,1]x = x[~sp.isnan(y)]y = y[~sp.isnan(y)]plt.scatter(x, y, s=6)plt.title("Web traffic")plt.xlabel("Time")plt.ylabel("Hits/hour")plt.xticks([w*7*24 for w in range(10)], ["week %i" % w for w in range(10)])plt.autoscale(tight=True)plt.grid(True,linestyle='-',color='0.75')f1p,residuals,rank,sv,rcond = sp.polyfit(x,y,1,full=True)f1 = sp.poly1d(f1p)f1x = sp.linspace(0,x[-1],1000)plt.plot(f1x,f1(f1x),linewidth=2)plt.legend(["d=%i" % f1.order],loc="upper left")f2p = sp.polyfit(x,y,2)f2 = sp.poly1d(f2p)f2x = sp.linspace(0,x[-1],1000)plt.plot(f2x,f2(f2x),linewidth=2)plt.legend(["d=%i" % f2.order],loc="upper left")f3p = sp.polyfit(x,y,53)f3 = sp.poly1d(f3p)f3x = sp.linspace(0,x[-1],1000)plt.plot(f3x,f3(f3x),linewidth=2)plt.legend(["d=%i" % f3.order],loc="upper left")plt.show() 这里写图片描述]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Scipy</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NumPy基础操作]]></title>
    <url>%2Fposts%2F42661.html</url>
    <content type="text"><![CDATA[学机器学习做点小笔记，都是Python的NumPy库的基本小操作，图书馆借的书看到的，怕自己还了书后忘了，就记下来。 一般习惯导入numpy时使用 import numpy as np ，不要直接import，会有命名空间冲突。比如numpy的array和python自带的array。 numpy下有两个可以做矩阵的东西，一个叫matrix，一个叫array。matrix指定是二维矩阵，array任意维度，所以matrix是array的分支，但是这个matrix和matlab的矩阵很像，操作也很像： 123456789101112131415161718&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a=np.mat('4 3; 2 1') # 使用字符串来初始化&gt;&gt;&gt; b=np.mat('1 2; 3 4')&gt;&gt;&gt; amatrix([[4, 3], [2, 1]])&gt;&gt;&gt; bmatrix([[1, 2], [3, 4]])&gt;&gt;&gt; a+b # 对应位置相加matrix([[5, 5], [5, 5]])&gt;&gt;&gt; a*b # 矩阵乘法，与matlab相同matrix([[13, 20], [ 5, 8]])&gt;&gt;&gt; np.multiply(a,b) # 对应位置乘法，相当于matlab的点乘 “.*”matrix([[4, 6], [6, 4]]) 而重点讲讲np.array。 #np.array操作 ###首先是初始化与属性查看 123456789101112&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.arange(10) # 从零生成到10-1的一维矩阵array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])&gt;&gt;&gt; a=np.array([0,1,2,3,4,5]) # 因为支持多维，所以用数组来初始化&gt;&gt;&gt; aarray([0, 1, 2, 3, 4, 5])&gt;&gt;&gt; a.ndim # 查看维度1&gt;&gt;&gt; a.shape # 查看矩阵形状尺寸(6,)&gt;&gt;&gt; a.dtype # 查看类型dtype('int32') ###reshape改变矩阵形状，可以改变维度，但是reshape后的数据还是共享原来那一份数据 1234567891011121314151617&gt;&gt;&gt; b=a.reshape(3,2)&gt;&gt;&gt; barray([[0, 1], [2, 3], [4, 5]])&gt;&gt;&gt; b.ndim2&gt;&gt;&gt; b.shape(3, 2)&gt;&gt;&gt; b[1][0]=77&gt;&gt;&gt; barray([[ 0, 1], [77, 3], [ 4, 5]])&gt;&gt;&gt; aarray([ 0, 1, 77, 3, 4, 5]) # 可见b和a其实用的同一个数据 ###因而要产生的新矩阵不再关联，要使用copy()： 123456789101112&gt;&gt;&gt; c=a.reshape(3,2).copy()&gt;&gt;&gt; carray([[ 0, 1], [77, 3], [ 4, 5]])&gt;&gt;&gt; c[0][0]=233&gt;&gt;&gt; aarray([ 0, 1, 77, 3, 4, 5])&gt;&gt;&gt; carray([[233, 1], [ 77, 3], [ 4, 5]]) ###array的运算： 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; d=np.array([1,2,3,4,5]) # 一维矩阵运算&gt;&gt;&gt; d.T # 转置矩阵array([1, 2, 3, 4, 5])&gt;&gt;&gt; d*2 # 每个数据乘以2array([ 2, 4, 6, 8, 10])&gt;&gt;&gt; d**2 # 每个数据二次方array([ 1, 4, 9, 16, 25])&gt;&gt;&gt; d*d # 按位置乘，与“d**2”等效，和mat正好相反array([ 1, 4, 9, 16, 25])&gt;&gt;&gt; d.dot(d) # 矩阵乘法，和mat相反55&gt;&gt;&gt; x=np.array([[1,2],[3,4],[5,6]]) # 二维矩阵运算&gt;&gt;&gt; y=np.array([[6,5,4],[3,2,1]])&gt;&gt;&gt; xarray([[1, 2], [3, 4], [5, 6]])&gt;&gt;&gt; yarray([[6, 5, 4], [3, 2, 1]])&gt;&gt;&gt; x.dot(y) # 二维矩阵矩阵乘法array([[12, 9, 6], [30, 23, 16], [48, 37, 26]])&gt;&gt;&gt; x= x.reshape(2,3)&gt;&gt;&gt; xarray([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; x*y # 按位置乘，要求两个矩阵shape相同array([[ 6, 10, 12], [12, 10, 6]])&gt;&gt;&gt; x.T # 二维矩阵的转置矩阵array([[1, 4], [2, 5], [3, 6]])&gt;&gt;&gt; x.mean() # 求平均值3.5 ###关于下标的运算：（这些挺有意思的） 123456789101112&gt;&gt;&gt; a=np.array([5,4,3,233,9])&gt;&gt;&gt; a[np.array([2,4,3])] # 列出对应下标的数值array([ 3, 9, 233])&gt;&gt;&gt; a&gt;4array([ True, False, False, True, True], dtype=bool)&gt;&gt;&gt; a[a&gt;4]array([ 5, 233, 9])&gt;&gt;&gt; a[a&gt;8]=8&gt;&gt;&gt; aarray([5, 4, 3, 8, 8])&gt;&gt;&gt; a.clip(4,5) # 限定所有数据范围array([5, 4, 4, 5, 5]) ###还有一个关于nan的 12345678910&gt;&gt;&gt; a=np.array([1,2,0,3,4])&gt;&gt;&gt; aarray([1, 2, 0, 3, 4])&gt;&gt;&gt; b=np.array([1,2,np.NAN,3,4])&gt;&gt;&gt; barray([ 1., 2., nan, 3., 4.]) # 和a不同，虽然只改了一个nan，b每个数据后面有个“.”，说明变成float型了，说明nan其实是个float&gt;&gt;&gt; np.isnan(b)array([False, False, True, False, False], dtype=bool)&gt;&gt;&gt; b[~np.isnan(b)]array([ 1., 2., 3., 4.]) #与系统自带array的差异 ###array的乘法 1234&gt;&gt;&gt; [1,2,3,4,5]*2[1, 2, 3, 4, 5, 1, 2, 3, 4, 5]&gt;&gt;&gt; [1,2,3,4,5]**2(报错) ###运行时间 对array和np.array进行按元素平方并求和的运算，运算3000次统计时间。 123456&gt;&gt;&gt; timeit.timeit('sum(x*x for x in range(1000))',number=3000)0.31559807779291305&gt;&gt;&gt; timeit.timeit('sum(na*na)', setup='import numpy as np; na=np.arange(1000)',number=3000)0.37785958035067324&gt;&gt;&gt; timeit.timeit('na.dot(na)', setup='import numpy as np; na=np.arange(1000)',number=3000)0.0069067372806728144 惊奇的发现系统级的array求和比np.array还快，说明np.array单个数据的访问还是比array较慢。但是用了矩阵乘法后，虽然效果一样，但这个速度就飞起来了。]]></content>
      <tags>
        <tag>Python</tag>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-9UVa127 - Accordian Patience]]></title>
    <url>%2Fposts%2F61171.html</url>
    <content type="text"><![CDATA[题意：52张牌排一行，一旦出现任何一张牌与它左边的第一张或第三张“匹配”，即花色或点数相同，则须立即将其移动到那张牌上面，将其覆盖。能执行以上移动的只有压在最上面的牌。直到最后没有牌能向左移动。 注意细则：如果同时有多张牌都可以移动，你应该采取的策略是移动最左边可移动的牌。当一张牌既可以移动到左边第一张，又可以移动到左边第三张时，应移动到左边第三张上面。 代码：（Accepted，0.100s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101//UVa127 - "Accordian" Patience//Accepted 0.100s//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;cstdio&gt;#define NUM 52#define BIAS 1using namespace std;struct card &#123; char a, b; bool operator ==(card&amp; that) &#123; return a == that.a || b == that.b; &#125;&#125;;struct stack &#123; card st[NUM + 2], *p; void ini() &#123; p = st + 1; &#125; card&amp; pop() &#123; if (p != st) return *(p--); return *p; &#125; card&amp; top() &#123; return *p; &#125; void push(card&amp; c) &#123; *++p = c; &#125; int size() &#123; return p - st; &#125; bool empty() &#123; return p == st; &#125;&#125;cards[NUM + 3];struct list &#123; stack *ls[NUM + 2]; list() &#123; for (int i(0);i &lt; NUM + 1;++i) ls[i] = cards + i; ls[NUM + 1] = nullptr; &#125; void erease(int n) &#123; while (ls[n] != nullptr) &#123; ls[n] = ls[n + 1]; ++n; &#125; &#125; stack&amp; operator [](int i) &#123; if (i &gt;= 0) return *ls[i]; return *ls[0]; &#125;&#125;;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif cards[0].st[1].a = cards[0].st[1].b = 'X'; // 第0个stack的top里储存一个没用的card，使得没有一张卡片与之相等，以方便以后处理前两张左边没牌的牌； while ((cards[1].st[1].a = getchar()) != '#') &#123; cards[1].st[1].b = getchar(); getchar(); for (int i(0);i &lt; NUM + 3;++i) cards[i].ini(); // 每个stack里将都只有一张卡片，这个ini就是把top的指针指向1 for (int i(2);i &lt; NUM + 1;++i) &#123; // 数据全部直接作为top读取到stack里面 cards[i].top().a = getchar(); cards[i].top().b = getchar(); getchar(); &#125; list pile; //处理部分，直接模拟，懒得另写函数了 int num; for (num = 2;&amp;pile[num];) &#123; // num从2开始，毕竟第一个数据怎么样也移动不了（接下来num再跳回1就懒得管他了） if (pile[num].top() == pile[num - 3].top()) &#123; pile[num - 3].push(pile[num].pop()); if (pile[num].empty()) pile.erease(num); num -= 3; &#125; else if (pile[num].top() == pile[num - 1].top()) &#123; pile[num - 1].push(pile[num].pop()); if (pile[num].empty()) pile.erease(num); --num; &#125; else ++num; &#125; printf("%d pile", num - 1); if (num != 2) printf("s"); printf(" remaining:"); for (int i(1);i &lt; num;++i) printf(" %d", pile[i].size()); puts(""); &#125; return 0;&#125; 分析：差不多又是一遍过，而且只用了0.1s，竟然挤进了UVa本题Ranking的前20，虽然题目确实很简单就是了，还是开心的不行。 我的思路是安放52个栈，直接进行模拟操作。从第二张牌开始（毕竟第一张牌不可能向左移动）往下判断，直到到达末尾。 具体流程是，若当前牌可以左移，移之，并且下一个进行判断的牌还是它（因为左侧的都是已经完成的不可能再有可移动的牌了，所以无需重新从最左侧开始检索）；反之此牌没法动了，则判断下一张牌。 感觉这不能叫遍历，毕竟期间会向左移动牌，应该算是迭代吧。 要注意的是输出格式！如下图所示， 6 piles remaining: 40 8 1 1 1 1 1 pile remaining: 52 pile/piles的单复数问题。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-8UVa806 - Spatial Structures]]></title>
    <url>%2Fposts%2F58091.html</url>
    <content type="text"><![CDATA[题意：黑白图像的路径表示法 代码：（Accepted，0.120s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//UVa806 - Spatial Structures//Accepted 0.120s//#define _XIENAOBAN_#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cmath&gt;using namespace std;int N, T(0);bool Img[66][66];vector&lt;string&gt; Sqns;const unsigned C5_10(const string&amp; five) &#123;//五进制转十进制 unsigned ans(0), i(1); for (auto p(five.rbegin());p != five.rend();++p, i *= 5) ans += (*p - 48) * i; return ans;&#125;const string C10_5(unsigned ten) &#123;//十进制转五进制(倒序) string ans; do ans += char(ten % 5 + 48); while (ten /= 5); return ans;&#125;bool DFS(int x, int y, string f) &#123; int len = N / (int)pow(2, f.length()) / 2; if (!len) &#123; if (Img[x][y]) &#123; Sqns.push_back(f); //cerr &lt;&lt; "Debug: Sqns(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ") " &lt;&lt; f &lt;&lt; endl;//Debug &#125; return Img[x][y]; &#125; bool NW(DFS(x, y, '1' + f)); bool NE(DFS(x, y + len, '2' + f)); bool SW(DFS(x + len, y, '3' + f)); bool SE(DFS(x + len, y + len, '4' + f)); bool flag(NW&amp;&amp;NE&amp;&amp;SW&amp;&amp;SE); if (flag) &#123; Sqns.pop_back(), Sqns.pop_back(), Sqns.pop_back(), Sqns.pop_back(); Sqns.push_back(f); &#125; return flag;&#125;void Initialize() &#123; Sqns.clear(); for (int i(0);i &lt; N;++i) for (int j(0);j &lt;= N;++j) Img[i][j] = false;&#125;void SolvePlus() &#123; Initialize(); //Input char n; for (int i(0);i &lt; N;++i) for (int j(0);j &lt; N;++j) cin &gt;&gt; n, Img[i][j] = n - 48; //Solve DFS(0, 0, ""); //Output if (Sqns.size()) &#123; sort(Sqns.begin(), Sqns.end(), [](string&amp; a, string&amp; b)-&gt;bool &#123; if (a.length() != b.length()) return a.length() &lt; b.length(); return a &lt; b; &#125;); auto p(Sqns.begin()); int cnt(0); while (p != Sqns.end()) &#123; if (cnt == 12) cnt = 0, cout &lt;&lt; '\n'; if (cnt++) cout &lt;&lt; ' ' &lt;&lt; C5_10(*p); else cout &lt;&lt; C5_10(*p); ++p; &#125; cout &lt;&lt; '\n'; &#125; cout &lt;&lt; "Total number of black nodes = " &lt;&lt; Sqns.size() &lt;&lt; '\n';&#125;void SolveMinus() &#123; N = -N; Initialize(); //Input unsigned n; while (cin &gt;&gt; n &amp;&amp; n != -1) Sqns.push_back(C10_5(n)); //Solve if (Sqns.empty()); else if (Sqns[0] == "0") &#123; for (int i(0);i &lt; N;++i) for (int j(0);j &lt; N;++j) Img[i][j] = true; &#125; else &#123; for (const auto&amp; t : Sqns) &#123; //cerr &lt;&lt;"Debug1: "&lt;&lt; t &lt;&lt; endl;// int x(0), y(0), len(N); for (const auto&amp; c : t) &#123; len /= 2; switch (c) &#123; case '1': break; case '2': y += len;break; case '3': x += len;break; case '4': x += len;y += len;break; default:break; &#125; &#125; //cerr &lt;&lt; "Debug2: ("&lt;&lt;x &lt;&lt; ", " &lt;&lt; y &lt;&lt;") "&lt;&lt;len&lt;&lt; endl;// for (int i(0);i &lt; len;++i) for (int j(0);j &lt; len;++j) Img[x + i][y + j] = true; &#125; &#125; //Output for (int i(0);i &lt; N;++i) &#123; for (int j(0);j &lt; N;++j) cout &lt;&lt; (Img[i][j] ? '*' : '.'); cout &lt;&lt; '\n'; &#125;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif std::ios::sync_with_stdio(false); while (cin &gt;&gt; N &amp;&amp; N) &#123; if (T) cout &lt;&lt; '\n'; cout &lt;&lt; "Image " &lt;&lt; ++T &lt;&lt; '\n'; if (N &gt; 0) SolvePlus(); else SolveMinus(); &#125; return 0;&#125; 分析：用的DFS来递归来着，题目倒是不难，直接跟着题意霸王硬上弓就行。但是大神们用10、20ms，我用了120ms。。。刚刚网上看了看好像思路也差不多。啊不管了，其实好久之前写的了，只是忘记发博客里了，我也有点忘了我怎么写的（记得当时写的时候有点昏昏沉沉）。 唉感觉自己越来越懒了，分析也不高兴写了。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux入门之路 - 05.Eclipse的Python开发环境搭建与Numpy、Scipy库安装]]></title>
    <url>%2Fposts%2F42706.html</url>
    <content type="text"><![CDATA[#一、Python环境 直接终端查询下python安装没：python --version 1Python 2.7.12 Ubuntu竟然已经装了Python2.7，那就好说了。不然自己装和装jdk差不多。本来想着要不要再装个3.4的，但是发现2.7也很常用，那就偷个懒了。 #二、安装PyDev ##1.在线安装 Elipse可以在线安装，又方便还方便而且方便。从http://pydev.org/updates 可以获得在线安装地址。在Help菜单中，选择Install New Software，点击Add，如图输入： 得到如下图内容，只选择PyDev for Eclipse即可（听说装多了反而有问题） 然后Next，发现进度条不动了。。。是的它访问不到。。。唉活在 土啬 里真累。怎么办呢？Ubuntu的全局代理总是不行，好在Eclipse自带网络设置，那就曲线救国一下。 ##2.Eclipse网络设置 在Window菜单中选择最后一个Preference，选择General - Network Connections，面板中的Active Provider选择Manual并配置SOCKS地址与端口。 然后重新在线安装就行啦！下载速度快的不行！ ##3.开启Cython加速 随便写个hello world，可以运行但是提示一个warning： 12warning: Debugger speedups using cython not found. Run '"/usr/bin/python" "/home/xienaoban/.eclipse/org.eclipse.platform_4.7.0_1966938284_linux_gtk_x86_64/plugins/org.python.pydev_5.5.0.201701191708/pysrc/setup_cython.py" build_ext --inplace' to build.pydev debugger: starting (pid: 8716) 就根据他给你的要求，打开终端输入 1"/usr/bin/python" "/home/xienaoban/.eclipse/org.eclipse.platform_4.7.0_1966938284_linux_gtk_x86_64/plugins/org.python.pydev_5.5.0.201701191708/pysrc/setup_cython.py" build_ext --inplace 即可。然后再运行warning就没了。 #三、安装Numpy、Scipy库 Numpy官网 Scipy官网 f发现库文件全都是whl格式的，需要使用python的pip进行安装。 pip的使用格式为：pip install xxx.whl 。尽量使用sudo吧，不然访问不了/usr会安装失败。 我下载了一个numpy，安装时提示 1numpy-1.12.0-cp27-cp27m-manylinux1_x86_64.whl is not a supported wheel on this platform. 说明下错了版本。那么我怎么知道你支持哪个版本呢？打开python，写如下程序段： 12import pipprint(pip.pep425tags.get_supported()) 然后执行，我的结果如下： 1[('cp27', 'cp27mu', 'manylinux1_x86_64'), ('cp27', 'cp27mu', 'linux_x86_64'), ('cp27', 'none', 'manylinux1_x86_64'), ('cp27', 'none', 'linux_x86_64'), ('py2', 'none', 'manylinux1_x86_64'), ('py2', 'none', 'linux_x86_64'), ('cp27', 'none', 'any'), ('cp2', 'none', 'any'), ('py27', 'none', 'any'), ('py2', 'none', 'any'), ('py26', 'none', 'any'), ('py25', 'none', 'any'), ('py24', 'none', 'any'), ('py23', 'none', 'any'), ('py22', 'none', 'any'), ('py21', 'none', 'any'), ('py20', 'none', 'any')] 于是就知道应该下载哪个版本了。 安装成功：]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Eclipse</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux入门之路 - 04.Eclipse安装]]></title>
    <url>%2Fposts%2F54802.html</url>
    <content type="text"><![CDATA[首先，要安装ecliose自然是先要有Java环境。在上一篇已经安装好了，不再赘述。 #一、下载# Eclipse官网 下载下来的文件“：eclipse-inst-linux64.tar.gz 。 #二、安装# 这次和上次不同，jdk解压即用，而双击打开此压缩包，发现里面有eclipse-inst 文件，说明自带安装程序，那就像windows下装软件一样好办了，把整个包解压缩出来随便放个目录，并且终端cd到该目录。执行sudo ./eclipse-inst 打开安装文件，发现了熟悉的界面： ##1）不好的安装方法一与其症状## 使用sudo运行它，很大条的该选安装目录选安装目录，该点I agree点I agree，该点下一步点下一步。 然后安装完最后一个页面，这个installer提醒你说我们启动一次看看成功没？你说吼哇吼哇，launch按一下，耶真的打开了，好轻松！于是满意地关掉了。然后过两天再想打开它，直接用ubuntu自带的“文件”定位到它的目录并双击eclipse，报错说定位不到相关的什么什么。然后我就执行/usr/local/bin/ide/eclipse/eclipse （这是我的安装目录），终端显示说什么大意就是说/etc下的一个文件打不开。我就知道哦权限不够，sudo一下。但是这样的话每次都要sudo明显烦人。而且这导致我在后面创建软件快捷方式时也总是“程序什么什么出现错误”，八成也是没权限导致的。不(bu)能(hui)做快捷方式、每次都要终端sudo输密码打开，太烦了。 ##2）不好的安装方法二与其症状## 既然它会在etc目录下生成东西，那我安装时不给他sudo呢？结果发现安装目录只能被限定在/home里面了。不不不，这不好，强迫症一定要分门别类。 ##3）正确的安装方法## 看到installer右上角的汉堡菜单没，点击它，把BUNDLE POOLS关掉。这个BUNDLE POOLS是共享插件用的，还能使eclipse启动变快什么什么的，但是它要权限啊，我这linux也就我一人使，关了。 然后该怎么做怎么做。 #三、创建快捷方式# Linux下创建个快捷方式都那么烦...其实步骤本身很简单，会了之后也感觉没啥，但是自己一开始做的时候失败了多少次。Ubuntu安装的软件都能在Dash里面看到，但是Eclipse没有注册自己（就像它在Win下也是个绿色软件一样），所以要自己添加快捷方式到Dash，（直接在桌面上创建个快捷方式也可以，但这样在Dash里将找不到，其实你在哪里创建快捷方式也无所谓啦）。定位到存放Dash应用快捷方式的位置并创建Eclipse快捷方式并打开编辑它： 1sudo gedit /usr/share/applications/Eclipse.desktop 输入以下内容： 12345678910[Desktop Entry]Encoding=UTF-8Name=EclipseComment=Eclipse IDEExec=/usr/local/bin/ide/eclipse/eclipseIcon=/usr/local/bin/ide/eclipse/icon.xpmTerminal=falseStartupNotify=trueType=ApplicationCategories=Application;Development; （网上乱七八糟的教程害死人啊。。。第一次做快捷方式，粘贴的别人代码，他[Desktop Entry] 两个单词中间没有加空格！导致系统一直识别不了为真正的快捷方式） 其他不用改，就改Exec和Icon路径即可。里面什么内容也不难看懂。不出意外此时你就能在Dash里面搜索到它了。然后把它拖到任务栏就好。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Eclipse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux入门之路 - 03.Java环境搭建]]></title>
    <url>%2Fposts%2F58851.html</url>
    <content type="text"><![CDATA[其实ubuntu是自带一个叫openJDK的东西的，是谷歌看Oracle不爽而搞的。不过呢。。。总感觉不太习惯，况且我既然都来Linux了，总是想折腾一把的。 首先先检查下有没有安装java。终端输入java -version，若出现以下字段则说明未安装。 1234567The program ‘java’ can be found in the following packages:* default-jre* gcj-4.6-jre-headless* openjdk-6-jre-headless* gcj-4.5-jre-headless* openjdk-7-jre-headlessTry: sudo apt-get install #一、下载# Java SE Development Kit 8 官网 选择对应系统的jdk下载。会发现有rpm和tar.gz两种格式。ubuntu不支持rpm所以下载tar.gz版本。（要安装rpm的包，则要先用alien把rpm转换成deb，这里我用的tar.gz，就讲这个）。 比如我下载在了默认的Downloads文件夹，即/home/xienaoban/Downloads/目录。名字叫jdk-8u121-linux-x64.tar.gz。 #二、解压# tar是个打包格式，gz即gzip是种压缩格式。那要安装它就要先解压。先用文件（Files）双击打开这个包看看，没有找到什么setup、install字样的文件，说明是解压即用的那种类型。（如果有install什么的文件就更方便了，就像win下面安装软件的exe一样，或者也可能是个sh脚本） 首先想一个安装路径，路径随意，自己喜欢就好。我选择了/usr/local/lib/java/路径。 系统本身没有java文件夹，所以要先创建个。首先打开终端： 1sudo mkdir /usr/local/lib/java 以创建java文件夹（若你选择的路径无需创建则跳过该步骤）； 1cd ~/Downloads/ 定位到jdk下载的目录。“～”相当于“/home/xienaoban”； 1sudo tar -zxvf eclipse-inst-linux64.tar.gz -C /usr/local/lib/java 意思是使用管理员权限，使用tar命令的zxvf操作将jdk安装包解压到安装路径。-zxvf中，-z是配合解压.GZ的 ，-x是解开一个包文件，-v显示详细信息，-f是必须的，表示使用归档文件，合并起来意思也很明显了。-C dir参数的作用在于改变工作目录，即改变了解压的路径。 于是就解压好了。可以用ls -l /usr/local/lib/java 查看目录下是否有jdk1.8.0_121目录。（ls：list，列出目录内的文件夹与子目录，-l：显示详细信息），没错的话会找到以下这条（当然时间什么的信息会不同）： 1drwxr-xr-x 8 uucp 143 4096 12月 13 08:50 jdk1.8.0_121 #三、配置环境变量# ##1.修改bashrc或profile文件## 方法有两个，一个是编辑~/.bashrc文件，一个是编辑/etc/profile文件。两者效果一样！网上针对两者的教程都有，任选其一即可！所以一开始搞得我一脸懵逼。我选择了编辑profile文件。 sudo gedit /etc/profile ， 用gedit打开profile文件并编辑（用其他文本编辑器如vim也随意），在文末添加如下代码： 1234export JAVA_HOME=/usr/local/lib/java/jdk1.8.0_121export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$JAVA_HOME/bin:$PATH 当然，路径如果和我的不一样的话改成自己的安装路径。其实只要改JAVA_HOME就行。网上看到有人四个变量全用的绝对路径，这不好，尽量不要用硬编码，改起来也麻烦。注意CLASSPATH后面是“.:”，我没有写错。 ##2.设置默认JDK 版本## 然后再执行以下五句update-alternatives以设置系统默认JDK 版本（记得修改自己的目录）： 1234567# java和javac必须配置sudo update-alternatives --install /usr/bin/java java /usr/local/lib/java/jdk1.8.0_121/bin/java 300 sudo update-alternatives --install /usr/bin/javac javac /usr/local/lib/java/jdk1.8.0_121/bin/javac 300# 以下可以不配置sudo update-alternatives --install /usr/bin/jar jar /usr/local/lib/java/jdk1.8.0_121/bin/jar 300 sudo update-alternatives --install /usr/bin/javah javah /usr/local/lib/java/jdk1.8.0_121/bin/javah 300 sudo update-alternatives --install /usr/bin/javap javap /usr/local/lib/java/jdk1.8.0_121/bin/javap 300 其中：每个指令最后的参数300代表着优先级，我看也有教程选择50的。还有java和javac是必须配置的，后面的几条，看到别人的说法是“如果你无聊,也可以把javah等等也给配置上”。。。所以你会发现不同的教程update-alternatives的数量还不一样。这里一并说明下。 参考链接 ##3.更新config## 最后再执行sudo update-alternatives --config java 与sudo update-alternatives --config javac更新config，当然如果是第一次安装会提示 12There is only one alternative in link group java (providing /usr/bin/java): /usr/local/lib/java/jdk1.8.0_121/bin/javaNothing to configure. 那就不用管了，否则选择你要的版本。 ##4.配置系统环境变量（可不做）## 看到有教程还要“配置系统环境变量”，即在/etc/environment 文件的 末尾添加 1234PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:$JAVA_HOME/bin"export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport JAVA_HOME=/usr/java/jdkexport JRE_HOME=$&#123;JAVA_HOME&#125;/jre 但是也有很多教程没有做这一项，我也没做。查了一下区别就是这个步骤是针对整个系统的，而更改profile是针对所有用户的（看上去不一样但实际结果上没啥区别）。所以这个步骤不执行也没有问题。 etc/profile: 此文件为系统的每个用户设置环境信息。当用户登录时，该文件被执行一次，并从 /etc/profile.d 目录的配置文件中搜集shell 的设置。一般用于设置所有用户使用的全局变量。 /etc/bashrc: 当 bash shell 被打开时，该文件被读取。也就是说，每次新打开一个终端 shell，该文件就会被读取。 ~/.bash_profile 或 ~/.profile: 只对单个用户生效，当用户登录时该文件仅执行一次。用户可使用该文件添加自己使用的 shell 变量信息。另外在不同的LINUX操作系统下，这个文件可能是不同的，可能是 ~/.bash_profile， ~/.bash_login 或 ~/.profile 其中的一种或几种，如果存在几种的话，那么执行的顺序便是：~/.bash_profile、 ~/.bash_login、 ~/.profile。比如 Ubuntu 系统一般是 ~/.profile 文件。 ~/.bashrc: 只对单个用户生效，当登录以及每次打开新的 shell 时，该文件被读取。 此外，修改 /etc/environment 这个文件也能实现环境变量的设置。/etc/environment 设置的也是全局变量，从文件本身的作用上来说， /etc/environment 设置的是整个系统的环境，而/etc/profile是设置所有用户的环境。有几点需注意： 系统先读取 etc/profile 再读取 /etc/environment（还是反过来？） /etc/environment 中不能包含命令，即直接通过 VAR=&quot;...&quot; 的方式设置，不使用 export 。 使用 source /etc/environment 可以使变量设置在当前窗口立即生效，需注销/重启之后，才能对每个新终端窗口都生效。 参考链接 #四、安装完成# 输入java -version 可以查看java有没有安装成功。若成功，会跳出以下文字： 123java version "1.8.0_121"Java(TM) SE Runtime Environment (build 1.8.0_121-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux入门之路 - 02.Shadowsocks-Qt5配置]]></title>
    <url>%2Fposts%2F41853.html</url>
    <content type="text"><![CDATA[作为一个学习中的程序员，查wiki等，科学上网肯定是刚需。况且没有它很多东西都下不下来。我在windows环境下使用的是shadowsocks，那么在linux下也使用它。 #一、SS版本# SS版本众多，而且自从你懂得之后又衍生出SSR。SS全平台各个版本 - Github ，SSR各平台版本 - Github 。 #二、安装# 这里我使用的是Qt5版本（Github链接）。毕竟是从win过渡过来的，一开始还是倾向GUI。 安装方法也异常简单，简单到我一开始不相信。（官方github上有安装文档。幸运的是，github可以直接访问）。三行代码即可解决，无需自己从github下载客户端。 首先打开终端（Ctrl+Alt+T） 然后分步运行以下三行命令。 123sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5 注：sudo的意思是获得管理员权限，会要求你输入密码，即你的ubuntu登录密码。 它的提示如下面所示：[sudo] password for xienaoban: 需要注意的是在终端输入密码不会有任何显示，包括'*'都不会显示，新手要注意。 然后就安装完成了。从你的dash（左上角相当于win开始键的东西）上能找到他，拖到任务栏上创个快捷方式就好啦。打开后如下图（File菜单里有个import from gui-config.json，把你的文件导入就行了。比别的版本的ss好的是，它能导入多个服务器，而别的版本的ss的config文件貌似只能添加一个）： #三、配置全局代理（失败）# Linux上与win不同，得自己从ss代理的接口转发出去。不像win那样一步到位，也不支持PAC。。。 根据网上各大教程，都是说打开系统设置，选择网络（Network）- 网络代理（Network proxy）。接下来有两种方法。 [法一] （实现全局代理）选择手动，sock5里如下填写： [法二] （实现PAC代理）选择自动，下载个pac文件（怎么合成或下载自己查吧）把你下载的文件的路径填进去。文件格式如图片（file:后面三个‘/’） 然而我失败了，怎么设置浏览器都不能访问（明明步骤一样，好气呀）。所以我放弃了。求大神告知。（听说是qt版本有问题？） #四、配置浏览器代理# 虽然全局不行，但浏览器自顾自的代理还是可以的。 Firefox：下载FoxyProxy插件，然后根据插件的教程来（浏览器自带的代理设置没效果不知道为什么，求告知）最后设置如图： Chrome：下载SwitchyOmega插件。根据以下教程来（插件下载地址都在里面） http://www.ihacksoft.com/chrome-switchyomega.html 。这个插件教程很详细，我就不写了。 要注意的是Rule List Config部分下载gfwlist.txt可能会失败，因为此时你还不能上某些网。所以做此步骤时先切换到刚做好的ss全局代理。 #五、配置终端代理# 挂代理的东西不少，我使用的是Polipo，和shadowsocks的socks5搭配比较不错。 Polipo安装： 1sudo apt-get install polipo 打开配置文件： 1sudo vim /etc/polipo/config 修改配置文件： 123456789# This file only needs to list configuration variables that deviate# from the default values. See /usr/share/doc/polipo/examples/config.sample# and "polipo -v" for variables you can tweak and further information.logSyslog = truelogFile = /var/log/polipo/polipo.logsocksParentProxy = "localhost:1080"socksProxyType = socks5logLevel=4 然后重启polipo： 12sudo service polipo stopsudo service polipo start Polipo默认的代理地址是 http_proxy=http://localhost:8123 那么每次对于希望 番羽 土啬 的指令，只需在前面加一句http_proxy=http://localhost:8123 即可。当然每次输入这么一长串这比较麻烦，可以打开～/.bashrc，在最后面添加一句 1alias fanqiang="http_proxy=http://localhost:8123" 这样以后只需在需要 番羽 土啬 的指令前面加一句fanqiang即可了。 先来测试下有没有成功，输入： 1fanqiang curl ip.gs 得到： 1当前 IP：104.238.149.195 来自：日本东京都东京 choopa.com 如果不想每条指令都输入fanqiang，可以 1export http_proxy=http://localhost:8123 #六、开机启动# 参考的这个http://www.afox.cc/archives/83 英文系统在dash里面搜索“start”，中文搜索“启动”，或者在终端里输入gnome-session-properties，总之就是打开这个 打开后界面如下图。 选择添加，如下填入即可。一个字都不需要改。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
        <tag>Shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的Linux入门之路 - 01.Ubuntu安装]]></title>
    <url>%2Fposts%2F41653.html</url>
    <content type="text"><![CDATA[最近学机器学习，感觉matlab/octave用的人不多，想改用python。于是开始学python，辛辛苦苦学会了自己装环境和装第三方库，结果发现scipy库竟然没有win版本！于是想着那我得装个linux了。于是乎...我本来只是想学学机器学习的。。。（教练：你怎么什么都想学）那么说干就干，顺便写个笔记，也不指望别人看到，也是以防以后我再需要安装linux时忘了自己曾经的步骤。 #一、Linux版本选择与下载# 因为是入门么，首先想到的自然是ubuntu。然后查了查，定下来就ubuntu比较适合我这种从windows过渡过去的。版本就默认他的最新就好，我目前最新版本是16.04。那么虽然选择ubuntu，还是不要选择其旗下的优麒麟吧。。。这个版本预装了些本地化软件，然而并没有什么用。（听说是win98一样打GUI，以及预装360?!360爸爸都管到linux啦） Ubuntu官网： http://www.ubuntu.org.cn/global #二、双系统选择# 我选择的安装模式是传统的legacy+mbr格式。打算linux和win10并存。我的win10是uefi+gpt安装在ssd里，而这里的linux选择legacy+mbr装在hdd里。而且我的BIOS不支持csm。两种启动引导方式完全不同，所以不会出现重装win导致引导丢失什么的，我这种方式甚至说不上是双系统。因此每次要启动对应系统时，要进linux就把bios的boot方式改为legacy，要进win10就选uefi。 以前试着装win7+win10双系统，网上教程看了一大堆，各种uefi、lagacy、mbr、gpt、csm什么什么术语的看得发晕，各种添加引导什么什么的乱的很。最后我想，legacy和uefi作为两种完全不同的引导方式，因该是互不影响的，而且win10我肯定是要fast boot的不肯回legacy（win8、win10的3秒神速开机就靠uefi下的fast boot支持），而win7那会还不支持uefi只能legacy，想转换uefi还麻烦，还会涉及双系统启动的那个界面。那我刚好一个win10装uefi，一个win7装legacy，通过BIOS 切换系统不就好了吗。于是作死亲测可用！于是这里装linux就把原来win7删了，反正ubuntu对uefi支持也不好。其实个人感觉这种双系统方式还更快，不用经过双系统选择界面，也没有双系统导致的引导问题。网上很多人对重装win导致linux引导丢失很烦恼，而我这样随便重装，从底层上互不影响。 #三、制作U盘启动# 官网就提供U盘启动制作器，很方便地把下载的ubuntu的iso刻入U盘。 U盘启动制作器地址：https://www.pendrivelinux.com/universal-usb-installer-easy-as-1-2-3/ 注意：U盘得是fat32格式的，NTFS打不开Linux启动盘（至少我的不能用NTFS）。用了NTFS虽然也显示的了那个启动界面（如下图）， 但是不管Run Ubuntu from this USB还是Install Ubuntu...，都会显示 Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(2,0)而报错。（网上人家都是在unknown-block(0,0)报错，就我(2,0)...查半天也差不出什么原因，我竟然能自己找出来是U盘格式原因我也挺佩服自己的）。 这里说一下发现的比较好玩的地方。win要安装到u盘需要win to go，貌似就是那个vhd，而且好像win8以上才支持。而这个linux启动盘，选择install后发现，他就是拿我下的ubuntu版本当作pe，然后有个可执行文件放在里面再把这个版本装一遍到硬盘里，挺有意思的。 #四、建立根目录与安装# 毕竟Ubuntu，安装界面相当友好。其他步骤都很简单，唯一有难度的是分区着一块。 首先是选择语言。有简体中文。我也选了简体中文，这个对新手还是很友好的。不过有一个问题，选了中文后你以后的用户文件目录下的文件夹名字也是中文（比如”文档“、”下载“、”图片“之类的文件夹）。 和Windows不同，Win下的用户文件夹不同，Win下虽然显示着中文， ，但是其文件目录本质还是英文，只是显示为中文罢了。比如说文档， ，显示是文档，但其实目录是 英文。但这里Ubuntu不一样，你选了中文，它的个人文件夹名字就真的变成中文了。。。所以我现在还有一点点小后悔选中文。不过好在ubuntu里的个人文件夹作用没win那么大，以后装软件、开发用到的不多。 安装ubuntu时下载更新与安装第三方软件均随意，（我这边是因为已经装好了，所以再打开安装面板做演示时第一个选项就灰了） 安装类型自己看它的描述很清楚，同样因为我已经装好了，所以前几个选项会不一样。但是一般前几个选项都满足不了你，都会选其他选项。 选择“其他选项”后就到了重头戏，分区。 ##分区## 这界面和win不一样。。。一开始我都分不清哪个是哪个区。sda代表它找到的第一块硬盘，在我电脑里是ssd，那下面的sda1、2、3就是ssd的分区。我们的目标是机械硬盘，也就是这里识别为sd2的这块。sdb5、6、7是我的其他盘，不管。 首先我事先格式化了一个60G的盘。然后把这个盘删了，释放为空闲的空间。然后就到瓜分这个60G的时间了。（这60G最后分的结果就是我的sdb1、8、9、10、11） Linux的文件系统和win完全不一样！啥都不懂就硬上的我一开始一脸蒙蔽！win下么创建个分区，格式化，系统装起来。而linux要安装，需要一个根目录。这个根目录类似于C盘，但是在它下面还需要自己挂载一些其他目录才能安装。详情先查Linux文件系统、Linux磁盘分区、挂载点等关键词。 查了这么多的结果就是，首先得分一个根目录，这是必须的。（如果像win那样建个盘，格式化，选中后就点安装，会提示找不到根目录安装不了）然后可以创几个分区。下面讲一下几个常用分区（所谓常用就是非必须，但是你了解了各自功能后感觉还是装一下比较好的）顺序也是根据我的分区顺序。 /boot：这玩意引导用的，但也不是必须（除非你电脑是老标准引导则必须要这个，还有这玩意对双系统在win中用easybcd引导grub2有帮助）但我新手，为了稳，分了200MB。另外要说的是，网上推荐/boot放在根目录前面并设为主分区，于是我先分了/boot。 步骤是：选择sdb这片名为“空闲”的60G的区域，点击左下角+号，弹出对话框（没截图）分区类型:主分区； 新建分区容量:200mb； 新建分区位置:起始（在这60G开头分出来）； 用于:Ext4日志文件系统（Ext4最能充分发挥linux性能）； 挂载点:选择“/boot”。 根目录：必须有的目录！！我之前看到好几个教程被坑了，都没让你创建根目录！一般20G绝对够了，盘小的就也相应少给点没问题，我60G大着呢，给了20G不到。 步骤是：选择“空闲”的区域，点击左下角+号，弹出对话框。分区类型:逻辑分区； 新建分区容量:20000mb； 新建分区位置:起始； 用于:还是Ext4日志文件系统； 挂载点:选择“/”。 交换空间：与windows的虚拟内存有点类似。一般如果你内存小于等于512MB，建议分两倍于内存大小的交换空间，如果内存大于512mb，可以分等于内存大小的空间。如果你内存很充裕，那就不用建立了。我内存8G，其实完全不需要这个。但是以防万一嘛，万一将来要运行什么大玩意呢？于是给了2G。 步骤是：选择“空闲”的区域，点击左下角+号，弹出对话框。分区类型:逻辑分区； 新建分区容量:2048mb； 新建分区位置:起始； 用于:swap（没记错的话是这个名字）； 此时挂载点灰了没法选。 /usr：与Windows的 Program Files文件夹、AppData文件夹有些许类似。主要功能是存放软件啊、库文件啊、其他可执行文件什么的。以后你会看到里面有/bin、/lib、/local什么的目录，很亲切。因为分了20G只剩40G了，后面还有一个home要分，想想软件怎么会比文件大，就决定1：3分，usr给1/（1+3）*40=10G。 步骤是：点击左下角+号，分区类型:逻辑分区； 新建分区容量:10240mb； 新建分区位置:起始； 用于:Ext4日志文件系统；挂载点:“/usr”。 /home：与win的个人文件夹类似，自带文档、图片、下载等文件夹。同时你作为用户的所有文件（工程啊、源文件啊、照片啊、小电影啊）都放这里了。所以给30G多。一般网上的建议都是剩下的空间全部作为home 步骤同上，就改个容量和挂载点，而且容量就默认的全部不用改。 以上是我的分配，也是综合了网上的方案，应该是个比较大众点的方案吧。其他如/var啊/tmp啊等等很多分区自行wiki功能，比如有的针对服务器我就不需要装了。 最后点击安装即可。重启后就可以了（win拔U盘重启后还有后续安装步骤，而linux重启直接好了）。 然后一个崭新的Ubuntu诞生了！ 第一件事换个壁纸AoA，毕竟是目前唯一不用教就会做的事。 当然了，这张图是后截的，已经装了些东西了比如某显眼的红色图标与某显眼的绿色图标。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-7UVa804 - Petri Net Simulation]]></title>
    <url>%2Fposts%2F10913.html</url>
    <content type="text"><![CDATA[题意：模拟Petri网的执行。虽然没听说过Petri网，但是题目描述的很清晰。 代码：（Accepted，0.210s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990//UVa804 - Petri Net Simulation//Accepted 0.210s//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;map&gt;using namespace std;struct &#123; map&lt;int, int&gt; ipt, opt;&#125; Trans[111];int NP, NT, NF, Cnt, T(0);int Token[111];void IniAndInput() &#123; Cnt = 0; for (int i(1);i &lt;= NP;++i) scanf("%d", Token + i); scanf("%d", &amp;NT); for (int i(1);i &lt;= NT;++i) &#123; Trans[i].ipt.clear(); Trans[i].opt.clear(); int n; while (scanf("%d", &amp;n) != EOF &amp;&amp; n) &#123; if (n &lt; 0) ++Trans[i].ipt[-n]; else ++Trans[i].opt[n]; &#125; &#125; scanf("%d", &amp;NF);&#125;bool JudgeTrans(int i) &#123; for (auto&amp; t : Trans[i].ipt) if (Token[t.first] &lt; t.second) return false; return true;&#125;bool TryTrans() &#123; for (int i(1);i &lt;= NT;++i) &#123; if (!JudgeTrans(i)) continue; for (auto&amp; t : Trans[i].ipt) Token[t.first] -= t.second; for (auto&amp; t : Trans[i].opt) Token[t.first] += t.second; return true; &#125; return false;&#125;void Output() &#123; printf("Case %d: ", ++T); if (Cnt &lt; NF) printf("dead after %d transitions\n", Cnt); else printf("still live after %d transitions\n", NF); printf("Places with tokens:"); for (int i(1);i &lt;= NP;++i) if (Token[i]) printf(" %d (%d)", i, Token[i]); printf("\n\n");&#125;void Debug() &#123; cerr &lt;&lt; "\nToken:\n"; for (int i(1);i &lt;= NP;++i) cerr &lt;&lt; Token[i] &lt;&lt; ' '; cerr &lt;&lt; "\nTrans:\n"; for (int i(1);i &lt;= NT;++i) &#123; for (const auto&amp; t : Trans[i].ipt) cerr &lt;&lt; t.first &lt;&lt; " - " &lt;&lt; t.second &lt;&lt; '\n'; for (const auto&amp; t : Trans[i].opt) cerr &lt;&lt; t.first &lt;&lt; " + " &lt;&lt; t.second &lt;&lt; '\n'; &#125;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif while (scanf("%d", &amp;NP) != EOF &amp;&amp; NP) &#123; IniAndInput(); //Debug();// for (;Cnt &lt; NF;++Cnt) &#123; if (!TryTrans()) break; //Debug();// &#125; Output(); &#125; return 0;&#125; 分析：其实就是无脑模拟。比前一题简单好多，有些意外。一遍通过，好久没一遍过了，好爽。题目描述的很清晰，看紫书的中文简述反而看不懂。这次尽量给不同部分分了个块，分到不同函数里去了，看着清晰点。210ms好像有点长，看网上别人的做法也基本类似，也不优化了。 说起来我一开始对每一个Case进行初始化Trans数组时，一开始选择的对整个数组的ipt、opt进行clear，用时190ms。后来改成只对要用的部分进行clear初始化，反而用时更长了（210ms）。这应该是处理器的优化的结果吧。就是让处理器反复干一件事时它会预测下一步还是这个同样的计算，就会处理的特别快。也算是硬件因素吧？]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-6UVa12166 - Equilibrium Mobile]]></title>
    <url>%2Fposts%2F23916.html</url>
    <content type="text"><![CDATA[题意：二叉树代表使得平衡天平，修改最少值使之平衡。 代码：（Accepted，0.030s） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//UVa12166 - Equilibrium Mobile//Accepted 0.030s//#define _XIENAOBAN_#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;map&gt;int T;int total;std::map&lt;long long, int&gt; leaf;void build(int dp) &#123; char c(getchar()); if (c == '[') &#123; build(dp + 1),build(dp + 1); getchar(); return; &#125; long long n(0); do &#123; n = n * 10 + c - '0'; c = getchar(); &#125; while (c &gt;= '0' &amp;&amp; c &lt;= '9'); ++leaf[n&lt;&lt;dp]; ++total; return;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif scanf("%d",&amp;T); while (getchar() != '\n'); while (total = 0,leaf.clear(),T--) &#123; build(0); int mx(0); for (auto p(leaf.begin());p != leaf.end();++p) if (p-&gt;second &gt; mx) mx = p-&gt;second; printf("%d\n",total - mx); &#125; return 0;&#125; 分析：题目给了每一片树叶的值与深度与树的形状。 由题，每个结点（除了树叶）的值为左右儿子之和，且其左右儿子值均相同。 推出，确定任意树叶与树的形状，其他结点的唯一可能的值均可求出(唯一确定)。 推出，确定任意结点与树的形状，其他结点的唯一可能的值均可求出(唯一确定)。 反之，若根节点值为N，且已知树的形状，可推出每个树叶的唯一可能的值(唯一确定)。 一开始想在以每个树叶为基准的情况下求出其他所有树叶的对应值，所以要遍历每个树叶，并对每个树叶遍历其他树叶求是否需要改变，时间复杂度O(n^2)，明显就麻烦。 看了题解，既然以某一树叶唯一确定一棵树，则只需求出以每片树叶为基准下的根节点值，看所有树叶对应根节点值相同的最多的，就是不需要改动的树叶最多的情况。时间复杂度O(n)。 唉，大神们的逆向思维就是厉害。论审题、分析题目的重要性。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A星寻路算法初探]]></title>
    <url>%2Fposts%2F56919.html</url>
    <content type="text"><![CDATA[写在开始之前 最近突然对各路游戏的寻路算法很感兴趣，于是去学习了下游戏里的AI们是如何寻路的。网上相关内容很多，但同时有些说法也不一，制作自己的A* 算法时也有因不同的说法而困惑。整理多方资料并自己实践之后，以下是我对寻路算法，尤其是A* 算法的一些自己的总结。以下为自己的思考与想法，可能不准确之处，请指正。 我本次的模拟比较简单，下面简述一下模拟环境： 地图是棋盘式的格子地图； 各个点没有权值，或者说权值为1； 只能上下左右走，不支持斜着走； 未考虑终点被包住而到达不了的情况，发生此类情况时，算法会遍历所有可到达点无果后才证明目标无法到达。 虽然模拟的比较简单，但是足以学习、说明问题。为了使算法更形象可视化，我给算法的过程做了小动画。成品存在了我的Github里：https://github.com/XieNaoban/Pathfinding 这里代码就不贴了。使用的java编写。由于是初学java，所以代码写的狗屎一样不要介意（讲道理我现在自己也看不下去了。不过做出来的GUI效果还挺满意。）另外一开始对这个寻路理解的比较混乱，体系没有建全，所以不同算法所在的函数也很不一样，函数分类也不合理（然而不高兴改了）。 寻路的基本思路 首先总结一下寻路的最常见的两个思路， 遍历 与 贪心算法 。 遍历：只考虑起点 这里说的遍历其实用的是Dijkstra算法或BFS，也就从起点开始一扩散出去寻找最短路径。也就是遍历距离起点最短距离为1、2、3……n-1、n的点。对于地形复杂比如有山有沼泽（即有权值）的地图（图），使用Dijkstra算法，用优先队列存储遍历到地图的每一个点时的权值和。对于一张平滑的也就是无权值（权值相同）的地图，Dijkstra的表现与BFS相同，即只需退化使用队列进行BFS遍历即可，无需使用Dijkstra算法。这里我的模拟的地图没有权值，直接使用了BFS。 图1. BFS小障碍寻路演示 黄色代表被搜索过，蓝色代表搜索完成后找到的路径（在这里显然也是最短路径）。格子中的值为从起点到本格子的最短距离。由图可知算法从起点向周围扩散，直到扩散到终点。 结论是，BFS（或带权图中用的Dijkstra）肯定找到最短路径，但是问题在于，它太耗时了，访问的点（黄色格子）太多了。想想就知道很多点完全没有必要遍历。 造成这一现象的原因是，这个算法只考虑了起点，一直找距离起点最短的路直到遇到终点。 贪心：只想着终点 试图不遍历，直接找到终点去，那基本就是使用贪心算法了吧。 以上的启发式函数仅仅考虑了起点，因而导致算法无目的地向四周扩散寻找。那既然是使用贪心算法，每次寻找目前为之的最优解，那么这次只要考虑终点在哪里就行了，一路向终点走，起点不用考虑。这使得算法疯狂试图向终点靠近。 结果发现无障碍情况下效果杠杠的，没有一块多余的白色。但是如果有障碍呢？ 虽然一格都没有多搜索，但是游戏里AI要是这样走路那玩家肯定吃不消。而且还有一个问题，万一走到了死胡同里，算法就会判定无法到达终点，而事实却是是算法自己钻了牛角尖。所以必须允许算法倒退，从死胡同里后退一步或多步，换条路子走。可以使用栈即可实现。有时会发现换了路之后反而更快地到达了之前到过的一个点，于是有些点重复搜索了，重复搜索的话很有可能比无脑遍历都不划算。于是我关闭了重复搜索，效果好多了。 可以看到算法产生了很多失败的搜索（黄格子）（都是被自己走过的路堵死的。。。创战记既视感）但是搜索的路比遍历少多了，但是说起来，允许倒退重新寻路，说到底这也还算是是进行遍历了。。。有时候还不及遍历。（其实我搜索完后画的路径不是完全根据算法来的，算法找的路还要更绕，我很多地方已经根据黄格子的梯度抄近路了。） 同时贪心算法只考虑了终点，永远只向着终点方向走，不考虑目前离起点已经走了多少格了。 A算法 A 用的也是Dijkstra。每次找出当前期望值最高的点（即最可能最快速度通往终点的点），一步步搜索过去。Wiki上也说了，这是对Dijkstra's Algorithm 的扩展，因为它使用了性能更好的启发式引导其搜索。 疑问：“最短”路径还是“最合理”路径 这是个令我困惑的问题。翻了些知乎或博客等，竟然众说纷纭。有人说“不是。因为‘启发’是不精确的。”。也有人说“尽管A* 基于无法保证最佳解的启发式方法，A* 却能保证找到一条最短路径。”这就很尴尬了。 看了这么多资料以及加上我以往的玩游戏经验，我认为A* 只是个比较宽的概念，它可以找到最佳路径，也可以找的只是合理路径。既然用了启发，那么它很可能找的不是“最短”而只是说根据这个启发找到的最“合理”路径。但是也可能你的启发式函数做的很好，找到的最合理路径就是最佳路径（就比如文章开头的说的遍历，下面说）。关键就在于你给他的“启发”是怎么样的。 小时候玩红警还是什么游戏时就遇到过单位走的路不是最短路径。 核心：寻找启发式函数h(n) A* 既然用了Dijkstra，那它的基本过程就是：从优先队列里拉出期望最高的n点（在我的算法里表示为h(n)值最低），标记，并把它周围的未知点放进优先队列。所以关键就是这个h(n)。 h(n)怎么找？其实最简单的，上面讲的遍历说起来也是h(n)的一种。从起点进行遍历的 h(n) = n.t （t为距离起点的距离），也就是说而对距离近的优先搜索。而这个算法其实就是最短路径的算法，这里“最合理路径”就是“最短路径”。 而对于上面讲的贪心算法，他的引导函数可以看作是 h(n) = max(abs(n.x - end.x), abs(n.y - end.y)) ，哪边离终点近就走哪里。之前这是用贪心实现的，但如果用做A*的h(n)实现呢？ 效果很好，不过这只能用在仅支持上下左右行走的场景，找的路也比较“合理”（虽然明显不是最短路径）。现在只考虑还有什么可以试试呢？ 想到起点终点都要考虑进去，首先想到了这个： h(n) = sqrt((n.x - end.x) ^ 2 + (n.y - end.y) ^ 2) + sqrt((n.x - start.x) ^ 2 + (n.y - end.y) ^ 2) 。即点n到起始点的距离加上n到终点的距离。也就是说，距离起点终点所在的直线越近，h(n)就越低。 效果还不错。但是问题在于sqrt计算成本太高。即时策略类游戏的话这不好。而且对于这次只有直着走的模拟有些大材小用了。而且还是有些部分是不需要搜索的。 还有几个可用的函数，一个和之前的h(n) = max(abs(n.x - end.x), abs(n.y - end.y)) 比较像： h(n) = abs(x - end.x) + abs(y-end.y) 找出x、y轴方向哪边离终点远，哪边远倾向于走哪边。还有一个和sqrt那个比较像： h = abs((x - end.x) * (start.y-end.y) - (start.x-end.x) * (y-end.y)) ，倾向与走与起点终点所在直线方向的平行线，这个个人觉得不错，比sqrt那个计算少，而且在棋盘式地图里效果也好。但是它也有一个问题： 他会搜索反向于终点的方向。所以可以考虑用多个函数组合： h = abs((x - end.x) * (start.y-end.y) - (start.x-end.x) * (y-end.y)) + (abs(x - end.x) + abs(y-end.y))*500; 效果比单一使用好很多。虽然实际效果其实不比h(n) = max(abs(n.x - end.x), abs(n.y - end.y)) 强，但也给我们提供一个寻找h(n)的思路，将来可以运用到任意方向的地图上。其中里面不同函数还有权重，比如第二个函数乘以了500。权重可以按照实战效果来定。 不过你可能也根据我放的截图发现了，这些算法都倾向于走起点与终点所在直线之上。即每当越过一个障碍物，就试图重新靠近起点终点所在连线上。尽管连线上或许还有障碍物。这也是我应该改进的地方。 总结：“精度”还是“速度” 显然，复杂些的启发式函数或是会造成更多搜索的方法往往能取得更好的效果，但是同时速度也更慢。因此如何选择将是本算法的一道难题。对于本次模拟的图，甚至BFS的表现都非常良好，但对于很大的地图、有很多NPC的游戏，就得权衡运行速度与寻路精度了。只要运行结果看似合理不会引起玩家破口大骂，A*算法的目的也算是达到了。]]></content>
      <tags>
        <tag>笔记</tag>
        <tag>造轮子</tag>
        <tag>A*寻路算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-4UVa439 6-5UVa1600]]></title>
    <url>%2Fposts%2F50450.html</url>
    <content type="text"><![CDATA[比较忙比较累，只贴代码了。 题目：6-4 UVa439 - Knight Moves 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162//UVa439 - Knight Moves//Accepted 0.000s//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define M(po) Map[po.x][po.y]using namespace std;struct poi &#123; int x, y, weight; poi operator +(const poi &amp;that) const &#123; return poi&#123; x + that.x, y + that.y, weight&#125;; &#125; bool operator ==(const poi &amp;that) const &#123; return (x == that.x) &amp;&amp; (y == that.y); &#125;&#125; op, ed;const poi dir[8] = &#123; &#123; 2,1 &#125;,&#123; -2,1 &#125;,&#123; 2,-1 &#125;,&#123; -2,-1 &#125;,&#123; 1,2 &#125;,&#123; -1,2 &#125;,&#123; 1,-2 &#125;,&#123; -1,-2 &#125; &#125;;bool Map[10][10];char xstart, ystart, xend, yend;int xs, ys, xe, ye;int BFS()&#123; if (op == ed) return 0; queue&lt;poi&gt; Q; Q.push(op); M(op) = true; while (!Q.empty()) &#123; for (int i(0);i &lt; 8;++i)&#123; poi nxt(Q.front() + dir[i]); if (nxt.x &gt; 0 &amp;&amp; nxt.y &gt; 0 &amp;&amp; nxt.x &lt; 9 &amp;&amp; nxt.y &lt; 9 &amp;&amp; !M(nxt)) &#123; ++nxt.weight; if (nxt == ed) return nxt.weight; M(nxt) = true; Q.push(nxt); &#125; &#125; Q.pop(); &#125; return -1;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout);#endif while (scanf("%c%c %c%c", &amp;xstart, &amp;ystart, &amp;xend, &amp;yend) == 4) &#123; memset(Map, 0, sizeof(Map)); op.x = xstart - 96, op.y = ystart - 48, op.weight = 0; ed.x = xend - 96, ed.y = yend - 48, ed.weight = 0; printf("To get from %c%c to %c%c takes %d knight moves.\n", xstart, ystart, xend, yend, BFS()); while (getchar() != '\n'); &#125; return 0;&#125; 题目：6-5 UVa1600 - Patrol Robot 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//UVa1600 - Patrol Robot//Accepted 0.000s//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#define DONE 2333333using namespace std;struct step &#123; int x, y, k, mov; &#125;;int T, m, n, k;int Map[24][24],Obst[24][24];void judge(queue&lt;step&gt; &amp;Q, step &amp;now, int x, int y) &#123; if (Obst[x += now.x][y += now.y] == DONE) return; int _k = (Obst[x][y] ? now.k + 1 : 0); if (_k &lt;= k) &#123; if (_k) &#123; if (Map[x][y] &amp;&amp; Map[x][y] &lt;= _k) return; Map[x][y] = _k; &#125; else Obst[x][y] = DONE; Q.push(step&#123; x, y, _k, now.mov + 1 &#125;); &#125;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d%d", &amp;m, &amp;n, &amp;k); for (int i(1);i &lt;= m;++i) for (int j(1);j &lt;= n;++j) scanf("%d", &amp;Obst[i][j]); memset(Map, 0, sizeof(Map)); queue&lt;step&gt; Q; Q.push(step&#123; 1,1,0,0 &#125;); Obst[1][1] = DONE; while (!Q.empty()) &#123; step &amp;now(Q.front()); if (now.x == m &amp;&amp; now.y == n) break; if (now.x + 1 &lt;= m) judge(Q, now, 1, 0); if (now.y + 1 &lt;= n) judge(Q, now, 0, 1); if (now.x - 1 &gt;= 1) judge(Q, now, -1, 0); if (now.y - 1 &gt;= 1) judge(Q, now, 0, -1); Q.pop(); &#125; if (Q.empty()) printf("-1\n"); else printf("%d\n", Q.front().mov); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 6-1UVa673 6-2UVa712 6-3UVa536]]></title>
    <url>%2Fposts%2F51530.html</url>
    <content type="text"><![CDATA[这三题比较简单，只放代码了。 题目：6-1 UVa673 - Parentheses Balance 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//UVa673 - Parentheses Balance//Accepted 0.000s//#define _XIENAOBAN_#include&lt;iostream&gt;using namespace std;int N;char line[130];bool st[130];bool cal() &#123; if (*line == '\0') return true; auto *p = line; auto *top = st; do &#123; switch (*p) &#123; case '(': *++top = false;break; case '[': *++top = true;break; case ')': if (top == st || *top) return false; --top; break; default: if (top == st || !*top) return false; --top; break; &#125; &#125; while (*++p != '\0'); return top == st;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif scanf("%d",&amp;N); getchar(); while (N--) &#123; gets(line); cout &lt;&lt; (cal() ? "Yes" : "No") &lt;&lt; '\n'; &#125; return 0;&#125; 题目：6-3 UVa712 - S-Trees 1234567891011121314151617181920212223242526272829303132333435363738394041//UVa712 - S-Trees//Accepted 0.000s//#define _XIENAOBAN_#include&lt;iostream&gt;using namespace std;int N(0);int n, m, ord[10], run[10], val[130];int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout);#endif while (scanf("%d", &amp;n) != EOF &amp;&amp; n != 0) &#123; printf("S-Tree #%d:\n", ++N); int num(1 &lt;&lt; n); for (int i(1);i &lt;= n;++i) &#123; while (getchar() != 'x'); ord[i] = getchar() - 48; &#125; while (getchar() != '\n'); for (int i(0);i &lt; num;++i) val[i] = getchar() - 48; scanf("%d", &amp;m); for (int i(0);i &lt; m;++i) &#123; while (getchar() != '\n'); for (int j(1);j &lt;= n;++j) run[j] = getchar() - 48; int ans(1); for (int j(1);j &lt;= n;++j) ans = (ans &lt;&lt; 1) + run[ord[j]]; printf("%d", val[ans - num]); &#125; printf("\n\n"); &#125; return 0;&#125; 题目：6-3 UVa536 - Tree Recovery 1234567891011121314151617181920212223242526272829303132//UVa536 - Tree Recovery//Accepted 0.000s//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;char pre[30], in[30];void cal(char *pre, char *in, int len) &#123; int root(0); while (*(in + root) != *pre) ++root; if (root) cal(pre + 1, in, root); if (len - root - 1) cal(pre + root + 1, in + root + 1, len - root - 1); printf("%c", *pre);&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 129) freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout);#endif while (scanf("%s%s", pre, in) != EOF) &#123; cal(pre, in, strlen(in)); puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-16UVa212 - Use of Hospital Facilities]]></title>
    <url>%2Fposts%2F17472.html</url>
    <content type="text"><![CDATA[题意：模拟患者做手术。 其条件为：医院有Nop个手术室、准备手术室要Mop分钟，另有Nre个恢复用的床、准备每张床要Mre分钟，早上Ts点整医院开张，从手术室手术完毕转移到回复床要Mtr分钟。现在医院早上开张了，给你一张患者的表，有Npa个患者等着做手术，每个患者的的信息有：名字、做手术需要的时间、恢复需要的时间。只要有空的手术室位就安排患者进去，优先安排门牌号低的。若多人同时竞争，输入列表靠前的先进。进入恢复室的优先顺序是，也是优先安排床号靠前的床，同时做完手术的人按照手术室的门牌号小的 （很奇葩的设定）优先。 代码：（Accepted，0.000s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108//UVa212 - Use of Hospital Facilities//Accepted 0.000s//#define _XIENAOBAN_#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;iomanip&gt;#include&lt;utility&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;#define ipt cin#define opt cout//just for convenience and appearance, because size("cout"+" ")=5, which is longer than a tab(which is 4)#define time_convert(t) setw(2) &lt;&lt; (t / 60) &lt;&lt; ':' &lt;&lt; setfill('0') &lt;&lt; setw(2) &lt;&lt; (t % 60) &lt;&lt; setfill(' ')using namespace std;struct ROOM &#123; int id, at; ROOM() &#123;&#125; ROOM(int a, int b) :id(a), at(b) &#123;&#125; bool operator &lt;(const ROOM&amp; that) const &#123; if (at != that.at) return at &gt; that.at; return id &gt; that.id; &#125;&#125;;struct PATIENT &#123; string name; int id, room, bed, top, tre, t1, t2, t3, t4;&#125;;int Nop, Nre, Ts, Te, Mtr, Mop, Mre, Npa;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 66666) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif ios::sync_with_stdio(false); while (ipt &gt;&gt; Nop) &#123; ipt &gt;&gt; Nre &gt;&gt; Ts &gt;&gt; Mtr &gt;&gt; Mop &gt;&gt; Mre &gt;&gt; Npa; Te = 0, Ts *= 60; vector&lt;int&gt; Top(Nop + 1, 0), Tre(Nre + 1, 0); vector&lt;PATIENT&gt; Info(Npa + 1); vector&lt;int&gt; Bre(Nre + 1, Ts); priority_queue&lt;ROOM&gt; Rop; for (int i(1);i &lt;= Nop;++i) Rop.push(ROOM(i, Ts)); //For all the operating rooms for (int N(1);N &lt;= Npa;++N) &#123; auto&amp; now(Info[N]); now.id = N; ROOM op(Rop.top()); Rop.pop(); ipt &gt;&gt; now.name &gt;&gt; now.top &gt;&gt; now.tre; now.t1 = op.at; now.t2 = now.t1 + now.top; now.t3 = now.t2 + Mtr; now.t4 = now.t3 + now.tre; now.room = op.id; op.at = now.t2 + Mop; Top[op.id] += now.top; Rop.push(op); &#125; sort(Info.begin() + 1, Info.end(), [](PATIENT&amp; a, PATIENT&amp; b)-&gt;bool &#123;if (a.t2 != b.t2) return a.t2 &lt; b.t2;return a.room &lt; b.room;&#125;);//Sort by t2 //For all the recovery rooms for (int N(1);N &lt;= Npa;++N) &#123; auto&amp; now(Info[N]); int re; for (re = 1;re &lt;= Nre;++re) if (Bre[re] &lt;= now.t2) break; now.bed = re; Bre[re] = now.t4 + Mre; Tre[re] += now.tre; if (Te &lt; now.t4) Te = now.t4; &#125; sort(Info.begin() + 1, Info.end(), [](PATIENT&amp; a, PATIENT&amp; b) &#123;return a.id &lt; b.id;&#125;);//Sort by id //Output opt &lt;&lt; " Patient Operating Room Recovery Room\n" &lt;&lt; " # Name Room# Begin End Bed# Begin End\n" &lt;&lt; " ------------------------------------------------------\n"; for (int N(1);N &lt;= Npa;++N) &#123; auto&amp; now(Info[N]); opt &lt;&lt; setw(2) &lt;&lt; N &lt;&lt; " " &lt;&lt; left &lt;&lt; setw(10) &lt;&lt; now.name &lt;&lt; right &lt;&lt; setw(2) &lt;&lt; now.room &lt;&lt; " " &lt;&lt; time_convert(now.t1) &lt;&lt; " " &lt;&lt; time_convert(now.t2) &lt;&lt; " " &lt;&lt; setw(2) &lt;&lt; now.bed &lt;&lt; " " &lt;&lt; time_convert(now.t3) &lt;&lt; " " &lt;&lt; time_convert(now.t4) &lt;&lt; '\n'; &#125; opt &lt;&lt; '\n' &lt;&lt; "Facility Utilization\n" &lt;&lt; "Type # Minutes % Used\n" &lt;&lt; "-------------------------\n"; for (int N(1);N &lt;= Nop;++N) &#123; opt &lt;&lt; "Room " &lt;&lt; setw(2) &lt;&lt; N &lt;&lt; setw(8) &lt;&lt; Top[N] &lt;&lt; setw(8) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (Top[N] * 100.0 / (float)(Te - Ts)) &lt;&lt; '\n'; &#125; for (int N(1);N &lt;= Nre;++N) &#123; opt &lt;&lt; "Bed " &lt;&lt; setw(2) &lt;&lt; N &lt;&lt; setw(8) &lt;&lt; Tre[N] &lt;&lt; setw(8) &lt;&lt; fixed &lt;&lt; setprecision(2) &lt;&lt; (Tre[N] * 100.0 / (float)(Te - Ts)) &lt;&lt; '\n'; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 分析：终于是本章节的最后一题啦！书上说很难，感觉其实不难啊，就是麻烦了点，写了好久。就是死在了一句话上“If two patients emerge from surgery at the same time, the patient with the lower number will be the first assigned to a recovery room bed.”（就是上面题意里加黑的那句）我还以为指的是患者编号，即患者输入顺序。结果WA。。。udebug上没有数据，不知道问题在哪里。自己做了一套数据发现了错误，百度查了别人的排序逻辑，才发现原来那个the patient with the lower number指的是在门牌号小的手术室做手术的患者。那个number竟然指的门牌号！所以只把sort函数的lambda比较函数改了一小下就AC了。 手术室的模拟使用了优先队列，空一个房间就来一个人，但是恢复床位不能用优先队列。因为恢复床位进入可使用状态最早的不一定是床号最小的，即当有人要转移到床位时可使用床位可能不止一个，和他做完手术的时间有关系。 附：测试数据 10 30 01 16 15 1 30 Jones 90 140 Smith 10 200 Thompson 60 75 Albright 40 82 Poucher 33 209 Comer 10 201 Perry 3 188 Page 111 120 Roggio 69 100 Brigham 42 79 Nute 22 71 Young 38 50 Bush 26 40 Cates 120 32 Johnson 10 2 Jones 28 140 Smith 120 200 Thompson 23 75 Albright 19 82 Poucher 133 209 Comer 74 101 Perry 93 188 Page 111 223 Roggio 69 122 Brigham 42 79 Nute 22 71 Young 38 140 Bush 26 121 Cates 120 248 Johnson 10 50]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-15UVa12333 - Revenge of Fibonacci]]></title>
    <url>%2Fposts%2F46172.html</url>
    <content type="text"><![CDATA[题意：在前100000个Fibonacci（以下简称F）数字里，能否在这100000个F里找出以某些数字作为开头的F。要求找出下标最小的。没找到输出-1。 代码：（Accepted，0.250s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475//UVa12333 - Revenge of Fibonacci//Accepted 0.250s//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;cstring&gt;#define MAXS 0xffffff#define CIN 50using namespace std;struct EACH_DIGIT &#123; int id; bool flag; EACH_DIGIT* next[10];//0~9&#125;nodes[MAXS];class DIC_TREE &#123; int index; EACH_DIGIT* ini;public: DIC_TREE() :index(0), ini(nodes) &#123;&#125; void insert(const int* F, int d, const int&amp; n) &#123; EACH_DIGIT* p(ini); int brk(d &gt; 41 ? d - 41 : 0); while (d-- &gt; brk) &#123; if (p-&gt;next[F[d]] == nullptr) p-&gt;next[F[d]] = nodes + (++index); if (!p-&gt;flag &amp;&amp; !p-&gt;id) p-&gt;id = n; p = p-&gt;next[F[d]]; &#125; if (!p-&gt;flag) p-&gt;flag = true, p-&gt;id = n; &#125; int search(const int* F) &#123; EACH_DIGIT* p(ini); for (int i(0);F[i] != -1;++i) &#123; if (p-&gt;next[F[i]] == nullptr) return -1; p = p-&gt;next[F[i]]; &#125; return p-&gt;id; &#125;&#125;dic;int Fnum[2][21000];//In average, Fibonacci numbers in each digit is about 5, 21000 &gt; (100000/5)int T, N, SN[CIN];char S[CIN];int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 66666) freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout);#endif memset(Fnum, 0, sizeof(Fnum)); memset(nodes, 0, sizeof(nodes)); int dgt(1); Fnum[0][0] = Fnum[1][0] = 1; dic.insert(Fnum[0], dgt, 0); for (int n(2);n &lt; 100000;++n) &#123; int two(n % 2), one((two + 1) % 2);//two:F(n-2)(also means the place of F(n)) one:F(n-1) for (int i(dgt &lt; 51 ? 0 : dgt - 51);i &lt; dgt;++i) if ((Fnum[two][i] += Fnum[one][i])&gt;9) Fnum[two][i] -= 10, Fnum[two][i + 1] += 1; if (Fnum[two][dgt]) ++dgt; dic.insert(Fnum[two], dgt, n); &#125; while (scanf("%d", &amp;T) != EOF)//Start to handle cases for (N = 1;N &lt;= T;++N) &#123; scanf("%s", S); int i(0); for (;S[i];++i) SN[i] = S[i] - 48; SN[i] = -1; printf("Case #%d: %d\n", N, dic.search(SN)); &#125; return 0;&#125; 分析：暴力求出前100000个F数字的话妥妥地超时。我一开始也想只取前面多少位以减少计算，担心出现99999...999什么什么的情况，导致精度不对，但看网上取50位的都过了，那就不虚了。 思路是用树的结构，每一位数（next）为一个结点，每个结点还储存“遍历到当前位数时满足的最小的F下标（index）”。若某个F刚好遍历到当前结点时结束，则修改当前结点index为当下F下标，并将其置为不可修改状态（flag:=true;）。若F遍历到当前还未结束，则若当前下标小于已储存下标且flag=false，则修改当前index。其实很好理解，但我好像说的不太清楚。 这题并没用到STL，看网上也是这样。数据结构的组建参考了 http://blog.csdn.net/a197p/article/details/44170921 。真的只是大概的看两眼那两个结构体，看了两眼想自己思考实现出来，但最后自己实现出来发现结构体里的变量和他的一样，最好的实现方法也只能是这样。最神奇的是甚至insert函数和search（他的query）函数和我的都和他写的一样—。— 但是他的代码就是0.130s，而我的时间是他的两倍，明明差不多我却没找出多在哪里。但是大神的代码里有好多巧妙的地方，比如他的 tnode dict[nodesize];//line 14 tnode* newnode() { return &amp;dict[size++]; }//line 31 这样就免去了每次都new，节约时间还免去了delete的烦恼，厉害了。于是毫不犹豫抄过来。再比如他的 memset(dict,0,sizeof(dict));//line 28 我一开始是在struct EACH_DIGIT 里面写了个构造函数 EACH_DIGIT():flag(0),id(0){memset(next,NULL,sizeof(next));} 但是发现他一个memset全设为0和我效果不是一样的嘛。刷过去还快。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-14UVa1598 - Exchange]]></title>
    <url>%2Fposts%2F554.html</url>
    <content type="text"><![CDATA[题意：模拟买卖，当出售价bid等于或低于出售价ask，则交易。 代码：（Accepted，0.330s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102//UVa1598 - Exchange//Accepted 0.330s//#define _XIENAOBAN_#include&lt;functional&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;utility&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;struct INFO &#123; char type; int size, price; &#125;for_push_back;int N, T(0);char type[20];vector&lt;INFO&gt; LIST; //key: buy/ask id, value: type, sizemap&lt;int, set&lt;int&gt;, greater&lt;int&gt; &gt; BUY; //key: bid price, value: idmap&lt;int, set&lt;int&gt;, less&lt;int&gt; &gt; SELL; //key: ask price, value: idmap&lt;int, int&gt; BUY_VAL; //key: bid price, value: sizemap&lt;int, int&gt; SELL_VAL; //key: ask price, value: sizeinline int sum(set&lt;int&gt;&amp; now) &#123; int re(0); for (const auto&amp; r : now) re += LIST[r].size; return re;&#125;void trade(bool flag) &#123; int bid_size, bid_price, ask_size, ask_price; while (true) &#123; auto bid(BUY.begin()), ask(SELL.begin()); if (bid == BUY.end()) bid_size = 0, bid_price = 0; else bid_size = BUY_VAL[bid-&gt;first], bid_price = bid-&gt;first; if (ask == SELL.end()) ask_size = 0, ask_price = 999999; else ask_size = SELL_VAL[ask-&gt;first], ask_price = ask-&gt;first; if (bid_price &lt; ask_price) &#123; printf("QUOTE %d %d - %d %d\n", bid_size, bid_price, ask_size, (ask_price == 999999 ? 99999 : ask_price)); return; &#125; auto sizeb(LIST[*bid-&gt;second.begin()].size), sizea(LIST[*ask-&gt;second.begin()].size); const auto mini(min(sizeb, sizea)); printf("TRADE %d %d\n", mini, flag ? ask_price : bid_price); auto&amp; b(bid-&gt;second), &amp;a(ask-&gt;second); BUY_VAL[bid-&gt;first] -= mini; if (!b.empty() &amp;&amp; (LIST[*b.begin()].size -= mini) == 0) b.erase(b.begin()); if (b.empty()) BUY.erase(bid); SELL_VAL[ask-&gt;first] -= mini; if (!a.empty() &amp;&amp; (LIST[*a.begin()].size -= mini) == 0) a.erase(a.begin()); if (a.empty()) SELL.erase(ask); &#125;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 66666) freopen("in.txt", "r", stdin); freopen("out.txt", "w", stdout);#endif while (scanf("%d", &amp;N) != EOF) &#123; if (T++) puts(""); LIST.clear(), BUY.clear(), SELL.clear(), BUY_VAL.clear(), SELL_VAL.clear(); LIST.push_back(for_push_back); for (int n(1);n &lt;= N;++n) &#123; INFO tmp; scanf("%s", type); if (*type == 'C') &#123; int id; scanf("%d", &amp;id); auto&amp; csl(LIST[id]); if (csl.type == 'B') &#123; BUY_VAL[csl.price] -= csl.size; LIST[id].size = 0; auto&amp; now(BUY[csl.price]); now.erase(id); if (now.empty()) BUY.erase(csl.price); &#125; else &#123; SELL_VAL[csl.price] -= csl.size; LIST[id].size = 0; auto&amp; now(SELL[csl.price]); now.erase(id); if (now.empty()) SELL.erase(csl.price); &#125; &#125; else &#123; tmp.type = *type; scanf("%d%d", &amp;tmp.size, &amp;tmp.price); if (*type == 'B') BUY[tmp.price].insert(n), BUY_VAL[tmp.price] += tmp.size; else SELL[tmp.price].insert(n), SELL_VAL[tmp.price] += tmp.size; &#125; LIST.push_back(std::move(tmp)); trade(*type == 'B'); &#125; &#125; return 0;&#125; 分析：书上推荐使用优先队列，然而并没有想出来怎么去用。想了想还是用了map，用它的begin()，效果一样的，还可以灵活差入数据。一开始老是在某组测试数据上出现Runtime error，搞得生无可恋。（从一老司机学到的新技能：当提交OJ出现RE时（WA也行），在执行每组数据计算的代码末尾加一句“while(1);”再提交如果从RE变成TLE了则说明是某些特殊数据没照顾到。毕竟不是所有OJ都有udebug可以用，这招还是不错的） 然后过了一天还是心里放不下，又回来想了想，是题目中一个细节“If there is no active order to sell, then it is assumed that ask size is zero and ask price is 99 999. Note, that zero is not a legal price, but 99 999 is a legal price. Recipient of quote messages distinguishes actual 99 999 ask price from the special case of absent orders to sell by looking at its ask size.”出了问题。于是把不可交易价格改成999999，与交易最大价格加以99999区分，果然似乎没问题了。然而接下来就有新问题，Time limit exceeded。。。 又过了一天，心里还是放不下，于是去网上查了查别人的代码，他们不仅用两个map存买卖信息，还再单独开辟两个map来存放sell与buy的总size（就相当于我上面那两个BUY_VAL 和 SELL_VAL），而当时我只用了两个map（BUY和SELL）存买卖的所有信息，所以每次查询循环总的size时要经历一个比较烦的循环，就是以下这个循环： 123456//求当前价格总的size函数int sum(set&lt;int&gt;&amp; now) &#123; int re(0); for (const auto&amp; r : now) re += LIST[r].size; return re;&#125; 123456//trade函数片段auto bid(BUY.begin()), ask(SELL.begin());if (bid == BUY.end()) bid_size = 0, bid_price = 0;else bid_size = sum(bid-&gt;second), bid_price = bid-&gt;first;if (ask == SELL.end()) ask_size = 0, ask_price = 999999;else ask_size = sum(ask-&gt;second), ask_price = ask-&gt;first; 这就是超时的罪魁祸首。改进了下瞬间变成0.330s，还是有些出乎意料。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-13UVa822 - Queue and A]]></title>
    <url>%2Fposts%2F16231.html</url>
    <content type="text"><![CDATA[题意：模拟客服MM，一共有N种话题，每个客服MM支持处理其中的i个（i &lt; N），处理的话题还有优先级。为了简化流程方便出题，设每个话题都是每隔m分钟来咨询一次。现知道每个话题前来咨询的时间、间隔、处理此话题所需的时长与一共有多少次咨询。问多少时间后全部话题处理完成。 代码：（Accepted，0.010s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081//UVa822 - Queue and A//Accepted 0.010s//#define _XIENAOBAN_#include&lt;algorithm&gt;#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;#define MI 2147483647using namespace std;struct T &#123; int ti; //time for per task queue&lt;int&gt; table;&#125; ttmp;struct P &#123; int id, at, st, n, to[22];//identity, available time, start time of last task, number of topics, topics bool operator&lt; (const P&amp; that) const &#123; if (st != that.st) return st &lt; that.st; return id &lt; that.id; &#125;&#125; ptmp;int Tpc, Psnl;//Number of Topics &amp; Personnelint name, num, nt, to, Scenario(0);int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 80) freopen("in.txt", "r", stdin);#endif ptmp.at = 0; while (scanf("%d", &amp;Tpc) != EOF &amp;&amp; Tpc != 0) &#123; int time(MI), needtime(0); map&lt;int, T&gt; tpc; for (int i(0);i &lt; Tpc;++i) &#123; scanf("%d%d%d%d%d", &amp;name, &amp;num, &amp;nt, &amp;ttmp.ti, &amp;to); if (time &gt; nt) time = nt; auto&amp; now(tpc[name] = ttmp); for (int i(0);i &lt; num;++i) now.table.push(nt), nt += to; &#125; scanf("%d", &amp;Psnl); vector&lt;P&gt; psnl(Psnl); for (int i(0);i &lt; Psnl;++i) &#123; scanf("%d%d", &amp;ptmp.id, &amp;ptmp.n); for (int j(0);j &lt; ptmp.n;++j) scanf("%d", ptmp.to + j); psnl[i] = ptmp; &#125; while (Tpc) &#123; int jumpt = MI;//Jump time to the earliest possible available time of all the men sort(psnl.begin(), psnl.end()); for (auto&amp; p : psnl) &#123;//For all staff members int pti(MI);//Man's earliest possible available time if (p.at &gt; time) pti = p.at;//Man is busy else &#123; //Man is available for (int i(0);i &lt; p.n;++i) &#123;//For all topics that man can handle auto&amp; t(tpc[p.to[i]]); if (t.table.empty()) continue; //Man find current topic finished if (t.table.front() &lt;= time) &#123; //Man find his topic pti = time + t.ti; if (needtime &lt; pti) needtime = pti; p.st = time; t.table.pop(); if (t.table.empty()) --Tpc; break; &#125; else if (t.table.front() &lt; pti) pti = t.table.front(); //Man find current topic will be available at t.table.front() &#125; p.at = pti; &#125; if (pti &lt; jumpt) jumpt = pti; &#125; time = jumpt; &#125; printf("Scenario %d: All requests are serviced within %d minutes.\n", ++Scenario, needtime); &#125; return 0;&#125; 分析：每分钟每分钟的模拟的话就有点慢了。我的做法是： 对每个topic，把它们每次过来询问的时间放在queue里，每开始处理一件就pop一件，直到它empty则说明处理完毕。 对每个员工，找出他的下一次“开始空闲”或“可能有事情做”的时间pti。所谓“开始空闲”或“可能有事情做”的时间是指： 若这人正在处理一个topic，则pti=处理完本topic的时间，这叫“开始空闲”； 若这人闲着，则给他找活干，若找到了可处理topic，pti=处理完这个topic的时间，也是“开始空闲”； 若这人闲着，但发现无活可干，每个他可以处理的topic都还没到来，那么他的pti=最快到来的下一个topic的时间，即只有topic来了他才可能“可能有事情做”。之所以是“可能”，因为每次都要按照“上一次开始干活的时间与ID”把每个人排序，所以他的活可能被抢，依然是“无事可干”状态。 pti初始化时为int的最大值。只有当该员工的每个topic全都处理完的状态时，pti全程没有被赋值，于是该员工的下一个空闲时间变成无限大，一定程度上相当于以后的模拟运算就不考虑他了。 找出了每个人的pti，让时间跳转到最近的一个pti，进行下一次循环（要注意的是time最终跳出循环时可能不等于所需时间，所以又定义了个needtime）。 这题最坑的是，udebug的算法是错误的(⊙﹏⊙)。它的数据答案我死活对不上，害的我调试了好几天。。。后来去网上找别人的算法，发现结果和udebug也一大半数据对不上。但是提交后就AC了。（这uva的数据也比较水，udebug上的100个测试数据我运算了蛮慢的，但提交上去就0.010s。不过开心的是我的运算比网上找的那几个算法都快。）]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-12UVa511 - Do You Know the Way to San Jose]]></title>
    <url>%2Fposts%2F6720.html</url>
    <content type="text"><![CDATA[题意：N张地图，查找某地点在不在某些地图上，若在，使用细节多的地图。使用哪个地图的破要求挺多，细心一点就好。 代码：（Accepted，0.000s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104//UVa511 - Do You Know the Way to San Jose?//Accepted 0.000s//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;cmath&gt;#include&lt;map&gt;using namespace std;#define EPS 1e-7struct mapdat &#123; float area,ratio, midx, midy, x1, y1, x2, y2; int level; string name; mapdat(char* n, float&amp; t1, float&amp; t2, float&amp; t3, float&amp; t4) :name(n), midx((t1 + t3) / 2), midy((t2 + t4) / 2) &#123; if (t1 &lt; t3) x1 = t1, x2 = t3; else x1 = t3, x2 = t1; if (t2 &lt; t4) y1 = t2, y2 = t4; else y1 = t4, y2 = t2; area = (x2 - x1)*(y2 - y1); ratio = (float)fabs((y2 - y1) / (x2 - x1) - 0.75); &#125;&#125;;inline bool findloc(const mapdat&amp; m, float&amp; x, float&amp; y) &#123; return x &gt; m.x1&amp;&amp;x&lt;m.x2&amp;&amp;y&gt;m.y1&amp;&amp;y &lt; m.y2;&#125;inline float dist(const mapdat&amp; m, float&amp; x, float&amp; y) &#123; return (x - m.midx)*(x - m.midx) + (y - m.midy)*(y - m.midy);&#125;vector&lt;mapdat&gt; maps;map&lt;string, pair&lt;float, float&gt; &gt; locs;char stmp[80];int l, lev(0);float t1, t2, t3, t4;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 80) freopen("in.txt", "r", stdin);#endif gets(stmp); while (scanf("%s", stmp) != EOF &amp;&amp; strcmp(stmp, "LOCATIONS")) &#123; scanf("%f%f%f%f", &amp;t1, &amp;t2, &amp;t3, &amp;t4); maps.push_back(mapdat(stmp, t1, t2, t3, t4)); &#125; sort(maps.begin(), maps.end(), [](mapdat&amp; a, mapdat&amp; b) &#123;return a.area &gt; b.area;&#125;); float a(-1.0); for (auto&amp; r : maps) &#123; if (fabs(r.area - a)&gt;EPS) r.level = ++lev, a = r.area; else r.level = lev; &#125; //for (auto&amp; r : maps) cout &lt;&lt; r.level &lt;&lt; ' ' &lt;&lt; r.name &lt;&lt; '\t' &lt;&lt; r.midx &lt;&lt; ' ' &lt;&lt; r.midy &lt;&lt; ' ' &lt;&lt; r.area &lt;&lt; endl;// while (scanf("%s", stmp) != EOF &amp;&amp; strcmp(stmp, "REQUESTS")) &#123; scanf("%f%f", &amp;t1, &amp;t2); locs[stmp] = make_pair(t1, t2); &#125; while (scanf("%s", stmp) != EOF &amp;&amp; strcmp(stmp, "END")) &#123; scanf("%d", &amp;l); printf("%s at detail level %d ", stmp, l); auto nowloc(locs.find(stmp)); if (nowloc == locs.end()) &#123; printf("unknown location\n"); continue; &#125; vector&lt;mapdat&gt; m,nm; for (const auto&amp; r : maps) if (findloc(r, nowloc-&gt;second.first, nowloc-&gt;second.second)) if(r.level!=l)m.push_back(r); else nm.push_back(r); if (m.empty()) &#123; printf("no map contains that location\n"); continue; &#125; auto cmp = [&amp;nowloc](mapdat&amp; a, mapdat&amp; b)-&gt;bool &#123; auto&amp; X(nowloc-&gt;second.first),&amp; Y(nowloc-&gt;second.second); if (a.level != b.level) return a.level &gt; b.level; auto da(dist(a, X, Y)),db(dist(b, X, Y)); if (fabs(da - db) &gt; EPS) return da &lt; db; if (fabs(a.ratio - b.ratio) &gt; EPS) return a.ratio &lt; b.ratio; da = (X - a.x2)*(X - a.x2) + (Y - a.y1)*(Y - a.y1); db = (X - b.x2)*(X - b.x2) + (Y - b.y1)*(Y - b.y1); if (fabs(db - da) &gt; EPS) return da &gt; db; return a.x1 &lt; b.x1; &#125;; if (nm.empty()) &#123; sort(m.begin(), m.end(), cmp); if (m[0].level &lt; l) printf("no map at that detail level; "); printf("using %s\n", m[0].name.c_str()); continue; &#125; sort(nm.begin(), nm.end(), cmp); printf("using %s\n", nm[0].name.c_str()); &#125; return 0;&#125; 分析：状态不好没认真编，编的比较乱比较丑。还没开始优化，想着先提交个试试，结果这也0.000s通过了。。。看来数据比较水。那就不改动不优化了。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-11UVa12504 - Updating a Dictionary]]></title>
    <url>%2Fposts%2F27478.html</url>
    <content type="text"><![CDATA[题意：对比新老字典的区别：内容多了、少了还是修改了。 代码：（Accepted，0.000s） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374//UVa12504 - Updating a Dictionary//#define _XieNaoban_#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;int T;int main()&#123;#ifdef _XieNaoban_ freopen("in.txt", "r", stdin);#endif ios::sync_with_stdio(false); cin &gt;&gt; T; cin.ignore(); while (T--) &#123; map&lt;string, string&gt; dic; for (int i(0);i &lt; 2;++i) &#123; string line, key, value; getline(cin, line); for (auto &amp;r : line) if (r == ',' || r == ':' || r == '&#123;' || r == '&#125;') r = ' '; istringstream in(line); while (in &gt;&gt; key) &#123; in &gt;&gt; value; if (i) &#123; auto d(dic.find(key)); if (d != dic.end()) &#123; if (d-&gt;second != value) d-&gt;second = "*";//changed else d-&gt;second = '&amp;';//not changed &#125; else dic[key] = "+";//increased &#125; else dic[key] = value; &#125; &#125; vector&lt;string&gt; inc, rmv, chg; for (const auto&amp; r : dic) switch (r.second[0]) &#123; case '+': inc.push_back(r.first);break; case '*': chg.push_back(r.first);break; case '&amp;': break; default: rmv.push_back(r.first);break; &#125; if (inc.empty() &amp;&amp; rmv.empty() &amp;&amp; chg.empty()) cout &lt;&lt; "No changes\n"; else &#123; if (!inc.empty()) &#123; cout &lt;&lt; '+' &lt;&lt; inc[0]; for (auto i(inc.begin() + 1);i != inc.end();++i) cout &lt;&lt; ',' &lt;&lt; *i; cout &lt;&lt; '\n'; &#125; if (!rmv.empty()) &#123; cout &lt;&lt; '-' &lt;&lt; rmv[0]; for (auto i(rmv.begin() + 1);i != rmv.end();++i) cout &lt;&lt; ',' &lt;&lt; *i; cout &lt;&lt; '\n'; &#125; if (!chg.empty()) &#123; cout &lt;&lt; '*' &lt;&lt; chg[0]; for (auto i(chg.begin() + 1);i != chg.end();++i) cout &lt;&lt; ',' &lt;&lt; *i; cout &lt;&lt; '\n'; &#125; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; 分析：这题很水，轻松AC，没啥好说的。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACMICPC 2016北京赛站网络赛 第1题 第3题]]></title>
    <url>%2Fposts%2F14358.html</url>
    <content type="text"><![CDATA[第一次玩ACM。。。有点小紧张小兴奋。这题目好难啊，只是网赛就这么难。。。只把最简单的两题做出来了。 题目１： 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//#define _ACM_#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;char line[111], word[111];int T(0);struct CAT&#123; //string N; //name of current category map&lt;string, CAT&gt; C; //categorys set&lt;string&gt; B; //books void show(const int sp) const&#123; for (const auto &amp;r : C) &#123; for (int i = 0;i &lt; sp;++i) printf(" "); printf("%s\n", r.first.c_str()); r.second.show(sp+1); &#125; for (const auto &amp;r : B) &#123; for (int i = 0;i &lt; sp;++i) printf(" "); printf("%s\n", r.c_str()); &#125; &#125;&#125;;int main()&#123;#ifdef _ACM_#define gets(T) gets_s(T, 111) freopen("in.txt", "r", stdin);#endif while (gets(line)) &#123; map&lt;string, CAT&gt; cat; do &#123; CAT* pc(NULL); char *p(word); for (char *pl(line);*pl != '\0';++pl) &#123; if (*pl != '/') *p++ = *pl; else &#123; *p = '\0';p = word; if (pc == NULL) pc = &amp;cat[word]; else pc = &amp;(pc-&gt;C[word]); &#125; &#125; *p = '\0'; pc-&gt;B.insert(word); &#125; while (gets(line) &amp;&amp; strcmp(line, "0")); printf("Case %d:\n", ++T); for (const auto &amp;r : cat) &#123; printf("%s\n", r.first.c_str()); r.second.show(1); &#125; &#125; return 0;&#125; 题目３： 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//#define _ACM_#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;inline bool isch(char c) &#123; return c &gt;= 'a' &amp;&amp; c &lt;= 'z'; &#125;char ch, line[555], word[555];string pr;map&lt;string, unsigned&gt; phs;int main()&#123;#ifdef _ACM_#define gets(T) gets_s(T, 555) freopen("in.txt", "r", stdin);#endif ch = getchar(); while (true) &#123; char *p(word); while (isch(ch)) &#123; *p++ = ch; ch = getchar(); &#125; *p = '\0'; bool ispunc(false); while (ch != EOF &amp;&amp; !isch(ch) &amp;&amp; ch != '#') &#123; if (ch == ',' || ch == '.' || ch == '\n') ispunc = true; ch = getchar(); &#125; if (ch == EOF) break;//the end of test file else if (ch == '#') &#123;//the end of current text if (!pr.empty()) ++phs[pr + ' ' + word]; if (ispunc) pr.clear(); else pr = word; unsigned maxu = 0; string maxs; for (const auto&amp; r : phs) if (r.second &gt; maxu) maxu = r.second, maxs = r.first; printf("%s:%u\n", maxs.c_str(), maxu); phs.clear(), pr.clear(); getchar(), getchar(), getchar(), getchar(); ch = getchar(); &#125; else &#123;//find a word/phrase if (!pr.empty()) ++phs[pr + ' ' + word]; if (ispunc) pr.clear(); else pr = word; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>ACM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-10UVa1597 - Searching the Web]]></title>
    <url>%2Fposts%2F651.html</url>
    <content type="text"><![CDATA[题意：不难理解，照搬题意的解法。 代码：（Accepted，0.190s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147//UVa1597 - Searching the Web//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;map&lt;string, set&lt;unsigned&gt; &gt; word;char lines[1510][85];unsigned N, M, la[105], ln(1);//la:last line of the article; ln:line numberchar tmpword[80], tmpline[88], w1[80], w2[80], w3[80];void ONLY(bool&amp; flag, const string&amp; on) &#123; auto &amp;t(word[on]); auto p(t.begin()); for (unsigned i(1);i &lt;= N;++i) &#123; while (p != t.end() &amp;&amp; *p &lt; la[i - 1]) ++p; if (p != t.end() &amp;&amp; *p &lt; la[i]) &#123; if (flag) puts("----------"); else flag = true; while (p != t.end() &amp;&amp; *p &lt; la[i]) puts(lines[*p++]); &#125; &#125;&#125;void NOT(bool&amp; flag, const string&amp; on) &#123; auto &amp;t(word[on]); auto p(t.begin()); for (unsigned i(0);i &lt; N;++i) &#123; while (p != t.end() &amp;&amp; *p &lt; la[i]) ++p; if (p == t.end() || *p &gt;= la[i + 1]) &#123; if (flag) puts("----------"); else flag = true; for (auto j(la[i]);j &lt; la[i + 1];++j) puts(lines[j]); &#125; &#125;&#125;void AND(bool&amp; flag, const string&amp; le, const string&amp; ri) &#123; auto &amp;t1(word[le]), &amp;t2(word[ri]); auto p1(t1.begin()), p2(t2.begin()); for (unsigned i(1);i &lt;= N;++i) &#123; while (p1 != t1.end() &amp;&amp; *p1 &lt; la[i - 1]) ++p1; while (p2 != t2.end() &amp;&amp; *p2 &lt; la[i - 1]) ++p2; if ((p1 != t1.end() &amp;&amp; *p1 &lt; la[i]) &amp;&amp; (p2 != t2.end() &amp;&amp; *p2 &lt; la[i])) &#123; if (flag) puts("----------"); else flag = true; unsigned re; while ((p1 != t1.end() &amp;&amp; *p1 &lt; la[i]) || (p2 != t2.end() &amp;&amp; *p2 &lt; la[i])) &#123; if (p1 == t1.end() || *p1 &gt;= la[i]) re = *p2++; else if (p2 == t2.end() || *p2 &gt;= la[i]) re = *p1++; else if (*p2 &gt; *p1) re = *p1++; else if (*p2 &lt; *p1) re = *p2++; else re = *p1++, *p2++; puts(lines[re]); &#125; &#125; &#125;&#125;void OR(bool&amp; flag, const string&amp; le, const string&amp; ri) &#123; auto p1(word[le].begin()), p2(word[ri].begin()); for (unsigned i(1);i &lt;= N;++i) &#123; while (p1 != word[le].end() &amp;&amp; *p1 &lt; la[i - 1]) ++p1; while (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i - 1]) ++p2; if ((p1 != word[le].end() &amp;&amp; *p1 &lt; la[i]) || (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i])) &#123; if (flag) puts("----------"); else flag = true; unsigned re; while ((p1 != word[le].end() &amp;&amp; *p1 &lt; la[i]) || (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i])) &#123; if (p1 == word[le].end() || *p1 &gt;= la[i]) re = *p2++; else if (p2 == word[ri].end() || *p2 &gt;= la[i]) re = *p1++; else if (*p2 &gt; *p1) re = *p1++; else if (*p2 &lt; *p1) re = *p2++; else re = *p1++, *p2++; puts(lines[re]); &#125; &#125; &#125;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 88) freopen("in.txt", "r", stdin);#endif scanf("%d", &amp;N); getchar(); for (unsigned now(0);now &lt; N;++now) &#123; //read contexts of articles la[now] = ln; while (gets(tmpline) &amp;&amp; strcmp(tmpline, "**********")) &#123; strcpy(lines[ln], tmpline); char *pl(tmpline); do &#123; if ((*pl &gt;= 'a' &amp;&amp; *pl &lt;= 'z') || (*pl &gt;= 'A' &amp;&amp; *pl &lt;= 'Z')) &#123; char *pw(tmpword); while ((*pl &gt;= 'a' &amp;&amp; *pl &lt;= 'z') || (*pl &gt;= 'A' &amp;&amp; *pl &lt;= 'Z')) &#123; if (*pl &gt;= 'A' &amp;&amp; *pl &lt;= 'Z') *pl += 32; *pw++ = *pl++; &#125; *pw = 0; word[tmpword].insert(ln); &#125; &#125; while (*pl++ != 0); ++ln; &#125; &#125; la[N] = ln; scanf("%d", &amp;M); getchar(); int nnnn = 0; while (M--) &#123; //read requests gets(tmpline); char *p = tmpline, *pw1 = w1, *pw2 = w2, *pw3 = w3; while (*p &amp;&amp; *p != ' ') *pw1++ = *p++; *pw1 = '\0'; if (*p) ++p; while (*p &amp;&amp; *p != ' ') *pw2++ = *p++; *pw2 = '\0'; if (*p) ++p; while (*p &amp;&amp; *p != ' ') *pw3++ = *p++; *pw3 = '\0'; bool flag(false); if (!*w2) ONLY(flag, w1); else if (*w1 == 'N') NOT(flag, w2); else if (*w2 == 'A') AND(flag, w1, w3); else OR(flag, w1, w3); if (!flag) puts("Sorry, I found nothing."); puts("=========="); //printf("==========%d\n", ++nnnn);// &#125; return 0;&#125; 分析：我选择死亡。。。难倒是不难，很快就解出来了。但是一开始用了近1秒的时间，很郁闷。于是又花了几天的时间去研究别人的代码，也包括把之前sstream全改掉用gets和puts，把only not and or全部分开做函数，写的老长。用gets和puts的版本用了0.600s，还是比别人的都慢好多。GitHub上看到大神0.080s的（https://github.com/morris821028/UVa/blob/master/temp/1597%20-%20Searching%20the%20Web.cpp），我天这是差了多少倍！于是仿着大神的代码也写了个，结果1.090s！！？？一定是我没抄到其精髓？！花了几天时间了，结果还变慢了，好难过啊。。。然后过了几天我又回来研究了。我发现其实网上看到的算法全都是大同小异的，那我的代码一定是哪里有问题。看到大神函数里面的这一句：set&lt;int&gt; &amp;t = wordInLine[args[1]]; 一开始我以他只是图个书写方便，但想了想，这样就不需要每次寻找wordInLine[args[1]]的值了，于是我就抱着试试的心态，也加了句类似的。结果瞬间从0.960s降到0.190s！新技能get！ 下面是仅仅没有给word[on]、word[le]、word[ri]加引用的版本。 代码：（Accepted，1.090s） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144//UVa1597 - Searching the Web//#define _XIENAOBAN_#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cstring&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;map&lt;string, set&lt;unsigned&gt; &gt; word;char lines[1510][85];unsigned N, M, la[105], ln(1);//la:last line of the article; ln:line numberchar tmpword[80], tmpline[88], w1[80], w2[80], w3[80];void ONLY(bool&amp; flag, const string&amp; on) &#123; auto p(word[on].begin()); for (unsigned i(1);i &lt;= N;++i) &#123; while (p != word[on].end() &amp;&amp; *p &lt; la[i - 1]) ++p; if (p != word[on].end() &amp;&amp; *p &lt; la[i]) &#123; if (flag) puts("----------"); else flag = true; while (p != word[on].end() &amp;&amp; *p &lt; la[i]) puts(lines[*p++]); &#125; &#125;&#125;void NOT(bool&amp; flag, const string&amp; on) &#123; auto p(word[on].begin()); for (unsigned i(0);i &lt; N;++i) &#123; while (p != word[on].end() &amp;&amp; *p &lt; la[i]) ++p; if (p == word[on].end() || *p &gt;= la[i + 1]) &#123; if (flag) puts("----------"); else flag = true; for (auto j(la[i]);j &lt; la[i + 1];++j) puts(lines[j]); &#125; &#125;&#125;void AND(bool&amp; flag, const string&amp; le, const string&amp; ri) &#123; auto p1(word[le].begin()), p2(word[ri].begin()); for (unsigned i(1);i &lt;= N;++i) &#123; while (p1 != word[le].end() &amp;&amp; *p1 &lt; la[i - 1]) ++p1; while (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i - 1]) ++p2; if ((p1 != word[le].end() &amp;&amp; *p1 &lt; la[i]) &amp;&amp; (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i])) &#123; if (flag) puts("----------"); else flag = true; unsigned re; while ((p1 != word[le].end() &amp;&amp; *p1 &lt; la[i]) || (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i])) &#123; if (p1 == word[le].end() || *p1 &gt;= la[i]) re = *p2++; else if (p2 == word[ri].end() || *p2 &gt;= la[i]) re = *p1++; else if (*p2 &gt; *p1) re = *p1++; else if (*p2 &lt; *p1) re = *p2++; else re = *p1++, *p2++; puts(lines[re]); &#125; &#125; &#125;&#125;void OR(bool&amp; flag, const string&amp; le, const string&amp; ri) &#123; auto p1(word[le].begin()), p2(word[ri].begin()); for (unsigned i(1);i &lt;= N;++i) &#123; while (p1 != word[le].end() &amp;&amp; *p1 &lt; la[i - 1]) ++p1; while (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i - 1]) ++p2; if ((p1 != word[le].end() &amp;&amp; *p1 &lt; la[i]) || (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i])) &#123; if (flag) puts("----------"); else flag = true; unsigned re; while ((p1 != word[le].end() &amp;&amp; *p1 &lt; la[i]) || (p2 != word[ri].end() &amp;&amp; *p2 &lt; la[i])) &#123; if (p1 == word[le].end() || *p1 &gt;= la[i]) re = *p2++; else if (p2 == word[ri].end() || *p2 &gt;= la[i]) re = *p1++; else if (*p2 &gt; *p1) re = *p1++; else if (*p2 &lt; *p1) re = *p2++; else re = *p1++, *p2++; puts(lines[re]); &#125; &#125; &#125;&#125;int main()&#123;#ifdef _XIENAOBAN_#define gets(T) gets_s(T, 88) freopen("in.txt", "r", stdin);#endif scanf("%d", &amp;N); getchar(); for (unsigned now(0);now &lt; N;++now) &#123; //read contexts of articles la[now] = ln; while (gets(tmpline) &amp;&amp; strcmp(tmpline, "**********")) &#123; strcpy(lines[ln], tmpline); char *pl(tmpline); do &#123; if ((*pl &gt;= 'a' &amp;&amp; *pl &lt;= 'z') || (*pl &gt;= 'A' &amp;&amp; *pl &lt;= 'Z')) &#123; char *pw(tmpword); while ((*pl &gt;= 'a' &amp;&amp; *pl &lt;= 'z') || (*pl &gt;= 'A' &amp;&amp; *pl &lt;= 'Z')) &#123; if (*pl &gt;= 'A' &amp;&amp; *pl &lt;= 'Z') *pl += 32; *pw++ = *pl++; &#125; *pw = 0; word[tmpword].insert(ln); &#125; &#125; while (*pl++ != 0); ++ln; &#125; &#125; la[N] = ln; scanf("%d", &amp;M); getchar(); int nnnn = 0; while (M--) &#123; //read requests gets(tmpline); char *p = tmpline, *pw1 = w1, *pw2 = w2, *pw3 = w3; while (*p &amp;&amp; *p != ' ') *pw1++ = *p++; *pw1 = '\0'; if (*p) ++p; while (*p &amp;&amp; *p != ' ') *pw2++ = *p++; *pw2 = '\0'; if (*p) ++p; while (*p &amp;&amp; *p != ' ') *pw3++ = *p++; *pw3 = '\0'; bool flag(false); if (!*w2) ONLY(flag, w1); else if (*w1 == 'N') NOT(flag, w2); else if (*w2 == 'A') AND(flag, w1, w3); else OR(flag, w1, w3); if (!flag) puts("Sorry, I found nothing."); puts("=========="); //printf("==========%d\n", ++nnnn);// &#125; return 0;&#125; 哎呀呀，就少那么几行，天壤之别。顺便把一开始做的版本也贴了： 代码：（Accepted，0.960s） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//UVa1597 - Searching the Web#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;struct article &#123; map&lt;string, vector&lt;unsigned&gt; &gt; word; vector&lt;string&gt; line;&#125;;const article tmpart;//an empty article,just for push_backunsigned N, M;string tmpstr;vector&lt;article&gt; dat;inline bool ONLY(const article&amp; ar, const string&amp; l, const string&amp; r) &#123; return ar.word.count(l);&#125;inline bool AND(const article&amp; ar, const string&amp; l, const string&amp; r) &#123; return ar.word.count(l) &amp;&amp; ar.word.count(r);&#125;inline bool OR(const article&amp; ar, const string&amp; l, const string&amp; r) &#123; return ar.word.count(l) || ar.word.count(r);&#125;void NOT(const string&amp; on) &#123; bool flag(false); for (const auto&amp; r : dat) &#123; if (!r.word.count(on)) &#123; if (flag) cout &lt;&lt; "----------\n"; else flag = true; for (const auto&amp; rr : r.line) cout &lt;&lt; rr &lt;&lt; '\n'; &#125; &#125; if (!flag) cout &lt;&lt; "Sorry, I found nothing.\n";&#125;void solve(bool(*f)(const article&amp;, const string&amp;, const string&amp;), const string&amp; le, const string&amp; ri) &#123; bool flag(false); for (auto&amp; r : dat) &#123;//why it can't be "const auto&amp; r"? because if a map is const,r.word[i] would be invalid if (f(r, le, ri)) &#123; set&lt;unsigned&gt; re; if (r.word.count(le)) for (const auto&amp; rr : r.word[le]) re.insert(rr); if (r.word.count(ri)) for (const auto&amp; rr : r.word[ri]) re.insert(rr); if (re.empty()) continue; if (flag) cout &lt;&lt; "----------\n"; else flag = true; for (const auto&amp; rr : re) cout &lt;&lt; r.line[rr] &lt;&lt; '\n'; &#125; &#125; if (!flag) cout &lt;&lt; "Sorry, I found nothing.\n";&#125;int main()&#123; //freopen("in.txt", "r", stdin);// std::ios::sync_with_stdio(false); cin &gt;&gt; N; cin.ignore();//absorb '\n' for (unsigned now(0);now &lt; N;++now) &#123; //read contexts of articles int ln(0);//line number of current article dat.push_back(tmpart);//create a empty article while (getline(cin, tmpstr) &amp;&amp; tmpstr != "**********") &#123; dat[now].line.push_back(tmpstr); for (auto&amp; r : tmpstr) &#123; if (r &gt;= 'a'&amp;&amp;r &lt;= 'z') continue; if (r &gt;= 'A'&amp;&amp;r &lt;= 'Z') r += 32; else r = ' '; &#125; istringstream in(tmpstr); while (in &gt;&gt; tmpstr) dat[now].word[tmpstr].push_back(ln); ++ln; &#125; &#125; cin &gt;&gt; M; cin.ignore(); while (M--) &#123; //read requests string sl, sm, sr;//left middle right getline(cin, tmpstr); istringstream in(tmpstr); in &gt;&gt; sl; if (!(in &gt;&gt; sm)) solve(ONLY, sl, sl); else if (!(in &gt;&gt; sr)) NOT(sm);//why are you so special else if (sm[0] == 'A') solve(AND, sl, sr); else solve(OR, sl, sr); cout &lt;&lt; "==========\n"; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-9UVa1596 - Bug Hunt]]></title>
    <url>%2Fposts%2F20085.html</url>
    <content type="text"><![CDATA[//开学了，好烦啊啊啊啊啊！怎么开个学那么多破事情！！都俩星期了，终于有时间写出来一道题 题意：不难理解，不写了。这几天忙的心累。 代码：（Accepted， 0.010s） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071//UVa1596 - Bug Hunt#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;stack&gt;#include&lt;map&gt;using namespace std;struct o_O &#123; int size; map&lt;int, int&gt; dim;&#125;;map&lt;string, o_O&gt; dat;string line;bool get(stack&lt;string&gt;&amp; st,int&amp; num) &#123; while (!st.empty()) &#123; if (num &gt;= dat[st.top()].size) return false; if (!dat[st.top()].dim.count(num)) return false; num = dat[st.top()].dim[num]; st.pop(); &#125; return true;&#125;bool declare() &#123;//定义数组 for (auto&amp; r : line) if (r == '[' || r == ']') r = ' '; istringstream in(line); string na; int nu; in &gt;&gt; na &gt;&gt; nu; dat[na].size = nu; return nu &gt;= 0;&#125;bool solve()&#123;//处理赋值 for (auto&amp; r : line) if (r == '[' || r == ']' || r == '=') r = ' '; stack&lt;string&gt; stl, str; int numl, numr; istringstream in(line); string now,sl; in &gt;&gt; sl; while (in &gt;&gt; now &amp;&amp; now[0] &gt; '9') stl.push(now); istringstream inl(now);inl &gt;&gt; numl; while (in &gt;&gt; now &amp;&amp; now[0] &gt; '9') str.push(now); istringstream inr(now);inr &gt;&gt; numr; if (!get(stl, numl) || !get(str, numr)) return false; if (numl &gt;= dat[sl].size) return false; dat[sl].dim[numl] = numr; return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin);// while (cin&gt;&gt;line &amp;&amp; line[0] != '.') &#123; unsigned flag = 0, linenum = 0; dat.clear(); do &#123; ++linenum; if (flag) continue; if (!(line.find('=') == string::npos ? declare() : solve())) flag = linenum; &#125; while (cin&gt;&gt;line &amp;&amp; line[0] != '.'); cout &lt;&lt; flag &lt;&lt; '\n'; &#125; return 0;&#125; 分析：给数组找bug，只有赋值和定义两种语句。一开始我想复杂了，以为会有诸如 a[b[c[0]=1]=d[2]]=e[e[e[e[e[e[3]]]=e[1]=e[2]=e[3]=233]]]=1 这种情况发生，于是就用递归做，做了好久，还老是WA（/* 实在难抽出一块一块的时间来学习，断断续续写了一星期，思路老是想到一半就断了。而且事情多烦的脑子疼，想不出东西。妈蛋还不如放假。*/） 结果昨天晚上一个老司机跟我说，干嘛那么烦，一行只有一个赋值。。。。。 好的，瞬间简单了。。今天花了一个小时不知道到不到就做出来了。可能是用了sstream，再转存到stack的原因，比较慢，用时10ms。 附：之前以为一行可以多个赋值的时候写的代码（更新：终于调试的AC了）： 代码：（Accepted， 0.010s） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//UVa1596 - Bug Hunt#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;map&gt;using namespace std;string line;queue&lt;string&gt; qu;struct o_O &#123; int len; map&lt;int, int&gt; def;&#125;;map&lt;string, o_O&gt; dat;int get() &#123;//从qu中get当前index的值，通过递归实现 string now = qu.front(); qu.pop(); if (now[0] &gt; '9') &#123;//若为变量名，说明有嵌套 int n = get();//得到当前变量的index qu.pop(); if (n &gt;= dat[now].len || n &lt; 0) return -1;//数组越界 if (qu.empty() || qu.front()[0] == '&#125;') &#123;//不是赋值，直接返回 if (!dat[now].def.count(n)) return -1;//没初始化 return dat[now].def[n]; &#125; return dat[now].def[n] = get();//赋值 &#125; int num;//若为数字 istringstream iin(now); iin &gt;&gt; num; return num;&#125;bool declare() &#123;//定义数组 for (auto&amp; r : line) if (r == '[' || r == ']') r = ' '; istringstream in(line); string na; int nu; in &gt;&gt; na &gt;&gt; nu; dat[na].len = nu; return nu &gt;= 0;&#125;bool solve() &#123;//预处理当前行 for (auto&amp; r : line) if (r == '[' || r == '=') r = ' '; istringstream in(line); string now; int num; while (in &gt;&gt; now) &#123; if (now[0] &gt; '9') qu.push(now); else &#123; int i = 0; for (auto&amp; r : now) if (r == ']') r = ' ', ++i; qu.push(now); while (i--) qu.push("&#125;");//为什么要用&#125;不用]，一开始想的是&#125;的ASCII是125，而]夹在大小写字母之间。然而后来发现并没有什么卵用 &#125; &#125; return get() &gt;=0;&#125;int main()&#123; //freopen("in.txt", "r", stdin);// while (getline(cin, line) &amp;&amp; line[0] != '.') &#123; unsigned flag = 0, linenum = 0; dat.clear(); while (!qu.empty()) qu.pop();//queue不自带clear()的?! do &#123; ++linenum; if (flag) continue; if (!(line.find('=') == string::npos ? declare() : solve())) flag = linenum; &#125; while (getline(cin, line) &amp;&amp; line[0] != '.'); cout &lt;&lt; flag &lt;&lt; '\n'; &#125; return 0;&#125; 虽然是我想多了，但是应用到单个赋值也是没问题的呀。但是还是想不通哪里就WA了。。。应该是哪个特殊的格式没考虑到。以后有心情再调试。（更新：终于调试得AC啦，代码已经覆盖更新。竟然也是0.010s。）]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-8UVa230 - Borrowers]]></title>
    <url>%2Fposts%2F9828.html</url>
    <content type="text"><![CDATA[//又开学啦，不知不觉成为大二的老人了。。。时间过得好快啊，感觉好颓废。。。 题意：建立一个借书/归还系统。有借、还、把还的书插到书架上这三个指令。 代码：（Accepted， 0ms） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263//UVa230 - Borrowers#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;struct BOOK &#123; string au, ti; BOOK(const string&amp; a, const string&amp; t) :au(a), ti(t) &#123;&#125; BOOK() :ti("X"), au("X") &#123;&#125; bool operator &lt;(const BOOK &amp;that)const &#123; if (au == that.au) return ti &lt; that.ti; return au &lt; that.au; &#125;&#125;;map&lt;BOOK, bool&gt; list;//int:0在书架 1已经借出map&lt;string, BOOK&gt; auth;set&lt;BOOK&gt; ret;//归还列表string tmp;void B(const string&amp; t) &#123; list[auth[t]] = true;&#125;void R(const string&amp; t) &#123; auto f = list.find(auth[t]); ret.insert(f-&gt;first);&#125;void S() &#123; for (auto&amp; r : ret) &#123; cout &lt;&lt; "Put " &lt;&lt; r.ti; auto re = list.find(r),p=re; //if (re == list.end()) cout &lt;&lt; "FUCK!\n";// while (p != list.begin() &amp;&amp; (--p)-&gt;second); //cout &lt;&lt; "喵喵喵?????\n";// if (p == list.begin() &amp;&amp; p-&gt;second) cout &lt;&lt; " first\n"; else cout &lt;&lt; " after " &lt;&lt; p-&gt;first.ti &lt;&lt; '\n'; re-&gt;second = false; &#125; cout &lt;&lt; "END\n"; ret.clear();&#125;int main()&#123; //freopen("in.txt", "r", stdin); while (getline(cin, tmp) &amp;&amp; tmp[0] != 'E') &#123; size_t n = tmp.rfind('\"'); string ti(tmp.substr(0, n + 1)); string au(tmp.substr(n + 5, tmp.size() - n - 6)); list[BOOK(au, ti)] = false; auth[ti] = BOOK(au, ti); &#125; //for (auto&amp;r : list) cout &lt;&lt; "--" &lt;&lt; r.first.ti &lt;&lt; '\t' &lt;&lt; r.first.au &lt;&lt; endl;// while (getline(cin, tmp) &amp;&amp; tmp[0] != 'E') &#123; if (tmp[0] == 'B') B(tmp.substr(7)); else if (tmp[0] == 'R') R(tmp.substr(7)); else S(); &#125; return 0;&#125; 分析：使用了STL的map和set。一个map存放所有书（书的作者与标题作为key，借阅/归还状态为value），一个map用来从标题映射到书的信息（因为下面borrow和return指令里不带作者信息，映射一下方便，但我内心还是不大情愿。的确有更好的方法，我不大会，下面再讲。）还有一个set存储归还了但还未放回书架的书。其他没啥要说的。 本来想将key设为标题，value设为作者的，但是不知道如何将map按value排序。查了查要用到vector+pair 中转，好像有点烦啊。但是网上看到这个，http://blog.csdn.net/a197p/article/details/43747539 。他就是采用了 12345struct book&#123; string author; int status; &#125;; map&lt;string, book&gt; books; 来存储。我还以为他能给map按照value重排，结果他建立了个vector&lt; string &gt; name; 来存放标题，存放顺序用以下方法 1234bool compare(string a, string b)&#123; if(books[a].author == books[b].author) return a &lt; b; else return books[a].author &lt; books[b].author; &#125; 原来是稍微绕了一下，但是也不错耶。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-7UVa12100 - Printer Queue]]></title>
    <url>%2Fposts%2F34815.html</url>
    <content type="text"><![CDATA[题意：一堆文件但只有一个打印机，按优先级与排队顺序进行打印。也就是在一个可以插队的的队列里，问你何时可以打印到。至于这个插队啊，题目说”Of course, those annoying term papers that others are printing may have to wait for quite some time to get printed, but that's life.“嗯，这就是生活。 代码：（Accepted， 0ms） 1234567891011121314151617181920212223242526272829303132333435//UVa12100 - Printer Queue#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int T,M,N;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;T); while (T--) &#123; scanf("%d%d", &amp;N, &amp;M); queue&lt;int&gt; q; priority_queue&lt;int&gt; p; int time = 1; for (int i = 0;i &lt; N;++i)&#123; int tmp; scanf("%d", &amp;tmp); q.push(tmp), p.push(tmp); &#125; while (true) &#123; if (q.front() == p.top()) &#123; if (!M) break; q.pop(), p.pop(); ++time; &#125; else &#123; q.push(q.front()); q.pop(); &#125; if (--M == -1) M = N - time; &#125; printf("%d\n", time); &#125; return 0;&#125; 分析：采用了队列和优先队列。排的队存在队列q里，每读取一个，与p的top()比对，若一致，则弹出p和q的首个元素已打印的份数time进行++，否则p的首元素放最后面去。这个优先队列就是比大小来的，只不过用着方便。 一遍过，哈哈，开心，前两天的题目总是WA和RE，现在终于挽回一点心情。本来还想了好几个办法的，或许比这个还要快一点，但是这章就是让你练习STL嘛，而且这个方法已经0ms了而且方便的很，是不是更快区别不大，也不高兴再换个方法试试了。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-6UVa1595 - Symmetry]]></title>
    <url>%2Fposts%2F37527.html</url>
    <content type="text"><![CDATA[题意：平面上给若干点，问它们是不是关于某垂直于x轴的直线对称。 代码：（Wrong Answer， --ms） 1234567891011121314151617181920212223242526272829303132333435363738394041424344//UVa1595 - Symmetry#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;struct point &#123; int x, y; bool operator &lt;(point&amp; that)const &#123; if (y == that.y) return x &lt; that.x; return y &lt; that.y; &#125;&#125;;int T, N;int main() &#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;N); vector&lt;point&gt; all(N); int sym(0);//2倍的对称轴 for (auto &amp;r : all) &#123; scanf("%d%d", &amp;r.x, &amp;r.y); sym += r.x; &#125; sym = sym * 2 / N; sort(all.rbegin(), all.rend()); //printf("sym:%d\n", sym);for (int i = 0;i &lt; N;++i) printf("%d&amp;%d ", all[i].y, all[i].x);printf("\n");//------------ int i = 0; while (i &lt; N) &#123; int k, ij, j = i; while (++j != N &amp;&amp; all[j].y == all[i].y); ij = (--j - i) / 2; //printf("i:%d\t", i);printf("j:%d\t", j);printf("ij:%d\n", ij);//---------- for (k = 0;k &lt;= ij;++k) &#123; if (all[i + k].x + all[j - k].x != sym) break; &#125; if (k &lt;= ij) break; i = j + 1; &#125; printf((i &lt; N ? "NO\n" : "YES\n")); &#125; return 0;&#125; 分析：好气呀，这么简单的题目，做了一下午+一上午，无限WA，至今找不到错误。不玩了，学会放弃，以后有心情再看。 我的想法是：定义一个结构体存每个点的x、y，读取每个数据后排序，优先y从小到大，其次x从小到大（目的是方便找出每个点对应的点。例如相同的y里面，最小的x与最大的x对应）。随便找出一个可能的对称轴（可以是找最大、最小的x，相加除以二；也可以所有的x相加再除以N。我选的后者）。然后取每对对应的两个点看相加的结果是不是对称轴两倍。 然而自己的测试数据都对，到了提交就总是WA。换成网上都用的set的方法重新做一遍，还是WA，开始怀疑人生。以下是我的测试数据，我实在是找不到其他的特殊情况了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103125 -2 5 0 0 6 5 4 0 2 3 4 2 3 0 4 4 0 0 0 4 5 14 6 105 10 6 14107 -6660 5-1 -6667 53 40 -6664 44 -6663 -6668 -6661233 3222-10000 9999999 9982-999 9990 99931 12 14 131 12 13 131 12 23 140 12 13 15 1371 12 23 34 45 56 67 78 89 91 92 83 74 66 47 38 29 15 65 75 555 45 35 -456 57 58 510 555 54 53 52 50 5-45 58 1007 1003 1002 100]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-5UVa10391 - Compound Words]]></title>
    <url>%2Fposts%2F4342.html</url>
    <content type="text"><![CDATA[题意：问在一个词典里，那些单词是复合词，即哪些单词是由两个单词拼出来的。 渣渣代码：（Accepted， 30ms） 12345678910111213141516171819202122//UVa10391 - Compound Words#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;set&lt;string&gt; dic;int main()&#123; //freopen("in.txt", "r", stdin); string w; while (cin &gt;&gt; w) dic.insert(w); for (const auto &amp;r : dic) &#123; int s = r.size(); for (int i = 1;i &lt; s;++i) &#123; if (dic.count(r.substr(0, i)) &amp;&amp; dic.count(r.substr(i, s - i))) &#123; cout &lt;&lt; r &lt;&lt; '\n'; break; &#125; &#125; &#125; return 0;&#125; 分析：遍历两遍词典找出两个单词来找/判断复合词肯定不行，慢死了，肯定只能是拆当前单词拆成两部分，枚举所有可拆分的情况，看这两部分有没有找到两个独立的单词。于是用了如上面的超简单的方法，但是30ms。学习他们的0ms至10ms的做法，发现他们都用了hash。我不知道什么是hash，一下子看他们代码也看的一愣一愣的。看了一下午代码和hash资料了，累死了。。明天继续改进这题，今天我要歇息下了。明天再会更新此博客。 更新：对hash还不熟，但是自己做了一下，但是总是Runtime error！我要哭了，自己做了N组不同的测试数据，没有任何异常，但是提交总是RE！为什么啊！！！！： 垃圾代码：（Runtime Error， --） 1234567891011121314151617181920212223242526272829303132333435363738394041//UVa10391 - Compound Words#include&lt;cstdio&gt;#include&lt;cstring&gt;const int mdic = 120200, d[] = &#123; 4616,177,7 &#125;;char dic[mdic][40];int hash(char* s) &#123; int re = 0; for (int i = 0;s[i] &amp;&amp; i &lt; 3;++i) re = (s[i] - 'a')*d[i]; return re;&#125;bool find(char* s) &#123; int h = hash(s); while (strcmp(s, dic[h]) &gt; 0) ++h; if (strcmp(s, dic[h])) return 0; return 1;&#125;int main()&#123; freopen("in.txt", "r", stdin); memset(*dic, 0, sizeof(*dic)); char w[40], (*p)[40] = dic; while (scanf("%s", w) != -1) &#123; int h = hash(w); while (dic[h][0]) ++h; strcpy(dic[h], w); &#125; for (int I = 0;I &lt; mdic;++I, ++p) &#123; if (!*p) continue; int len = strlen(*p); for (int i = 1;i &lt; len;++i) &#123; char a[40], b[40]; strncpy(a, *p, i);a[i] = 0; strcpy(b, *p + i); if (find(a) &amp;&amp; find(b)) printf("%s\n", *p); &#125; &#125; return 0;&#125; 分析：尽量按照自己的想法做的。对于获得hash那个函数，我也是自己想的（4616=120010/26，177=120010/26/26，7=120010/26/26/26），不知道高人有什么看法。还有再次声明：这个代码是RE的！！我测试了好多数据都没问题，一到oj上就RE。。好歹来个WA啊啊啊（哇的一声就哭了） 就我自己的测试数据，上面的版本用时2136，下面的4726。。。。怎么还慢了。。不服。。以后学精了再说吧。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-4UVa10763 - Foreign Exchange]]></title>
    <url>%2Fposts%2F25094.html</url>
    <content type="text"><![CDATA[题意：有若干交换生、若干学校，有人希望从A校到B校，有的想从B到C、C到A等等等等。如果有人想从A到B也刚好有人想从B到A，那么可以交换（不允许一对多、多对一）。看作后如果有人找不到人交换，那么整个交换计划失败。 代码：（Accepted， 50ms） 12345678910111213141516171819//UVa10763 - Foreign Exchange#include&lt;cstdio&gt;#include&lt;cstring&gt;int N, a, b,all[1003][1003];int main() &#123; //freopen("in.txt", "r", stdin); while (scanf("%d", &amp;N) != -1 &amp;&amp; N != 0) &#123; memset(all, 0, sizeof(all)); while (N--) &#123; scanf("%d%d", &amp;a, &amp;b); ++all[a][b], --all[b][a]; &#125; int *p = all[0], i = 0; for (;i &lt; 1006009;++i, ++p) if (*p != 0) break; printf(i&lt;1006009 ? "NO\n" : "YES\n"); &#125; return 0;&#125; 分析：一开始我使用multimap &lt; int,int &gt;去完全的模拟，但是其实我不大会使用，不知道怎么删除单个元素而不把整个key删除，就把那个元素置为-1。最后遍历一遍看看有没有不是-1的。结果。。。。虽然一遍过了，蛮开心，但一看结果1870ms！！！我的天呐！我开始怀疑人生啦！近2000毫秒什么鬼！突然怀疑我是不是不适合计算机这个专业/(ㄒoㄒ)/~~。于是去网上看他们怎么做的。好吧，好好一个题目被我搞复杂了。神经病啦，谁需要用到multimap啦。 看到网上有几个方法： 1. 就是我现在的方法，定义一个二维数组all，all[A][B]即为A到B的人数。下标1000就够了，题目的数据里没有标号更大的学校（但1000*1000还是好大！又是空间换时间的交♂易，不过这场交♂易明显合算啊）。 2. 把“原来所在学校x”到“交换目标学校y”的数据输入数组后，排序；再按照y到x的顺序存入数组，排序；若两个数组一样，则yes。相当好的想法呢。就是实现烦一点而且有bug（待会说）。 3. 直接统计各个学校想进来、想出去的人数，看看是不是平衡。与方法2有一样的bug。 好，说说那个bug。就是甲：A→B；乙：B→C；丙：C→A；的情况。题目只说了A到B、B到A可行，没说这个也行。但是VJ和博客上看到好多这两个方法的也AC了，而且代码又快又少。一开始有点懵圈了，不知道是题目没说清还是代码的bug。现在想想应该是网友没想到这点吧。但是我还是用法三做了一遍：（法三，Accepted， 60ms） 1234567891011121314151617181920//UVa10763 - Foreign Exchange#include&lt;iostream&gt;#include&lt;map&gt;int N, a, b;int main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%d", &amp;N) != -1 &amp;&amp; N != 0) &#123; std::map&lt;int, int&gt; all; while (N--) &#123; scanf("%d%d", &amp;a, &amp;b); ++all[a], --all[b]; &#125; bool num = false; for (const auto &amp;r : all) if (r.second) &#123; num = true;break; &#125; printf(num ? "NO\n" : "YES\n"); &#125; return 0;&#125; 出人意料的那个用all[1003][1003]的方法比法三那个投机取巧还便宜了10ms。map有这么慢？好吧。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-3UVa10935 - Throwing cards away I]]></title>
    <url>%2Fposts%2F64810.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 12345678910111213141516171819202122//UVa10935 - Throwing cards away I#include&lt;iostream&gt;#include&lt;queue&gt;int N;int main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%d", &amp;N) != -1 &amp;&amp; N != 0) &#123; std::queue&lt;int&gt; C; for (int i = 1;i &lt;= N;++i) C.push(i); printf("Discarded cards:"); for (int n = 0;n &lt; N - 1;++n) &#123; if (n) printf(","); printf(" %d",C.front()); C.pop(); C.push(C.front()); C.pop(); &#125; printf("\nRemaining card: %d\n", C.front()); &#125; return 0;&#125; 题意：N张扑克从1到N编号，表面那张扔掉，表面那张放最后去；表面那张扔掉，表面那张放最后去；表面那张扔掉，表面那张放最后去；表面那张扔掉，表面那张放最后去……直到只剩一张。求扔牌的顺序和最后一张。 分析：用了紫书教的queue，直接模拟，pop一张，然后把front的一张push到最后面去，再pop掉这张。直至只剩一张。 本来想直接在N张牌的数组里面，用指针p先指向第一张，把应扔掉的牌设为0，再搜索下一张不为0的牌（当p一直搜索直至指向最后一张牌的后面时，把p拉回第一张。所以其实搞个环形链表倒是不错，就是STL里我不知道list能不能做成环形的，又不高兴自己做。）。但是虽然应该快一点，实现起来比较烦，而且遇到了奇怪的bug，整了半天愣是没找出来出错的原因，鼻子都气歪了（第一次花了一下午找不出自己的错误在哪里，还是在短短的二三十行里，很不服。）。最后还是全部推倒重来，用了队列，还顺便熟悉下queue。然后发现也不会慢。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-2UVa1594 - Ducci Sequence]]></title>
    <url>%2Fposts%2F3706.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，20 ms） 123456789101112131415161718192021222324252627282930313233//UVa1594 - Ducci Sequence#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;vector&gt;using namespace std;int T,N;bool is_zero(vector&lt;int&gt; &amp;d) &#123; for (const auto &amp;i : d) if (i) return false; return true;&#125;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;N); vector&lt;int&gt; D(N); for (auto &amp;i : D) scanf("%d", &amp;i); int i = -1; while (++i&lt;200) &#123; int D0 = D[0]; for (int i = 0;i &lt; N-1;++i) D[i] = abs(D[i] - D[(i + 1)]); D[N - 1] = abs(D[N - 1] - D0); if (is_zero(D)) break; &#125; printf(i==200?"LOOP\n": "ZERO\n"); &#125; return 0;&#125; 题意：一个数组每次做一定变换，问最后他是循环了还是数据全都变成0了。 分析：模拟每一步，没什么思路。但是纯模拟量很大。 一开始我直接无限模拟每一步，看是不是全变成0了，还是有没有进入循环。 用了set来存储每一步的结果，用set的count函数来判断是不是进入循环了。代码如下： 123456789101112131415161718192021222324252627282930313233343536//UVa1594 - Ducci Sequence#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;#include&lt;vector&gt;#include&lt;set&gt;using namespace std;int T,N;bool is_zero(vector&lt;int&gt; &amp;d) &#123; for (const auto &amp;i : d) if (i) return 0; return 1;&#125;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;T); while (T--) &#123; scanf("%d", &amp;N); vector&lt;int&gt; D(N); set&lt;vector&lt;int&gt; &gt; P; for (auto &amp;i : D) scanf("%d", &amp;i); P.insert(D); while (1) &#123; vector&lt;int&gt; D2(N); for (int i = 0;i &lt; N;++i) D2[i] = abs(D[i] - D[(i + 1) % N]); if (is_zero(D2)) &#123; printf("ZERO\n"); break; &#125; if (P.count(D2)) &#123; printf("LOOP\n"); break; &#125; D = D2; P.insert(D); &#125; &#125; return 0;&#125; 但是结果把我从椅子上吓得掉下去：“Time: 520 MS”！一口老血喷了出来（与上面最终提交的结果差了十万八千里！）。想了想，问题在哪里呢？于是去网上看了大神们的做法：他们都没有做数据是否循环的检查。原来如此，虽然set的检查已经很快了，但是如此庞大的检查量还是不敢恭维。直接不检查，1000次循环，要么出现全0，否则就是循环了，题目给你保证了不过1000的。现在知道了，原来还可以这么玩！ 于是我又去除set的循环检查又提交一遍，100ms。那么与别人的40ms、50ms又差在哪儿呢？一看，人家只循环了500次甚至更少。为什么呢？我试了200，依然AC。想找点规律会不会保证它在200之内必有结果，没找出来。或许是题目的数据太水了原因。（本来猜想只要有一半的数字是一样的就应该是loop，想提交试试的，但是想想加个这样的判断并不合算）所以100ms差不多了。像我这样算是钻空子了。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 5-1UVa1593 - Alignment of Code]]></title>
    <url>%2Fposts%2F27312.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 123456789101112131415161718192021222324252627282930313233343536//UVa1593 - Alignment of Code#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;iterator&gt;#include&lt;iomanip&gt;using namespace std;vector&lt;string&gt; text[1009];int num[100] = &#123; 0 &#125;, X = 0;char line[200];int main()&#123; //freopen("in.txt", "r", stdin); while (cin.getline(line, 200)) &#123; istringstream in(line); istream_iterator&lt;string&gt; fi(in), eof; int y = 0; while (fi != eof) &#123; text[X].push_back(*fi); num[y] = max(num[y], (int)fi-&gt;size()); ++y, ++fi; &#125; ++X; &#125; for (int i = 0;i &lt; X;++i) &#123; int t = text[i].size() - 1; for (int j = 0;j &lt; t;++j) cout &lt;&lt; left &lt;&lt; setw(num[j] + 1) &lt;&lt; text[i][j]; cout &lt;&lt; *(text[i].rbegin()) &lt;&lt; '\n'; &#125; return 0;&#125; 题意：把很多行的单词排整齐。本来每一行中的各个单词之间含有随机个空格或tab，现在要求每一列单词左对齐。很好懂。 分析：思路很简单：找出每一列单词的最大字母数，再根据此输出即可。紫书也说了，这章不难，主要练习一下STL。之前我抱着C++ Primer也啃了很久，那这章就把之前学到的不管是不是很偏的东西尽量都用上吧。 读取文件不仅用了&lt;sstream&gt;，而且用了头文件iterator，用了流迭代器。其实流迭代器这里并没有什么优势，直接用流读入就行。我只是练习一下。（因为对流还能有迭代器感觉很神奇） 对于头文件&lt;algorithm&gt;，用到了max函数。其实在这里的情况下并没有很划算。就是 a=max(a,b);的情况。直接if (a &lt; b) a = b;更好，这样还省掉一些赋值。 输出直接用了头文件&lt;iomanip&gt;里的setw对齐，left左对齐,方便的很！]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cin、cout与scanf、printf的效率差异对比分析]]></title>
    <url>%2Fposts%2F30653.html</url>
    <content type="text"><![CDATA[之前上传UVa227 puzzle时，好不容易AC了，但发现自己用时50(ms)，而在VJ上看到人家都是40ms、20ms，于是打开一个20ms的代码查看人家强在哪里。但结果研究了半天感觉差不多，于是想着应该不是算法的问题。然后又想到，网上提交的答案，大家都是用scanf和printf写的，而我用的cin cout，而这题的确需要大量的输入输出，于是就想着把所有cin cout改成scanf printf。结果 —。— 上面c++版，下面c版。 于是我很好奇C的输入输出方法和C++提倡的方法为什么差距那么大。经过一番研究和查询，结果如下： 首先是scanf和cin： cin之所以慢，主要是因为要与scanf同步的关系，即允许scanf与cin混用。但是如果你的代码里没用到scanf，那么想关闭同步也可以。 只要使用这行代码，就可关闭同步：std::ios::sync_with_stdio(false); 关闭同步后的cin效率大大提高。有人说比scanf还高，有人说差不多，网上评论不一。其实cin关闭同步后真正的效率如何还是依赖编译器。下面这篇博文很详尽地比较了cin和关闭同步的cin和scanf：https://www.byvoid.com/blog/fast-readfile 。看完这篇基本就可以了解性能上的差异了，编译器占的因素蛮大的。那么关了同步的cin与scanf差不多，但是cin是新标准，更安全更便捷。况且string只能用cin。 然后是printf和cout： 对于cout和printf，则效率差异不明显。有人认为流更快有人认为printf快，逛论坛查询时看到他们都吵起来了。具体怎样我又找到一篇博文：http://www.cnblogs.com/killerlegend/p/3918452.html 。他的结论是：输出时尽量使用cout,输入时尽量使用scanf。不过我也测试了，试了点最简单的： 12345678910int main()&#123; clock_t a, b; a = clock(); for (int i = 0;i &lt; 29999;++i) cout &lt;&lt; i &lt;&lt; '\n'; b = clock(); cout &lt;&lt; b - a; return 0;&#125; 与 12345678910int main()&#123; clock_t a, b; a = clock(); for (int i = 0;i &lt; 29999;++i) printf("%d\n",i); b = clock(); printf("%d",b - a); return 0;&#125; 结果是：cout用时6124，printf用时3536。cout比printf差了一倍不到。而且对于cout，那句“std::ios::sync_with_stdio(false);”其实是不起作用的，它只针对cin。于是我的结论与上面链接里的博文相反。 所以cout和printf效率可以说差不多，主要还是看编译器吧。使用时也不必纠结，只是cout毕竟新标准，更安全适用面更广更灵活。 最后： 本文讨论的输入输出使用仅仅针对ACM做题。scanf的确快，拿来做题还是很不错的。输入量少的话拿cin也毫无问题，刷个题目也没必要特地跑过去关闭同步。而且cin更安全更便捷，还支持重载。且对于string与自定义的数据，就只能用cin、cout没跑了。 对于我们这种有强迫症、选择恐惧症的，有两个方法给你自由选择也未必是个好事。不分分清楚心理难受哈哈。]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-10UVa815 - Flooded!]]></title>
    <url>%2Fposts%2F14458.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 123456789101112131415161718192021222324//UVa815 - Flooded!#include&lt;iostream&gt;#include&lt;algorithm&gt;int M, N, W, S[1000], T = 0;int main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%d%d", &amp;M, &amp;N) != -1 &amp;&amp; M != 0 &amp;&amp; N != 0) &#123; for (int i = 0, *p = S;i &lt; M*N;++i) scanf("%d", p++); scanf("%d", &amp;W); std::sort(S, S + M*N); int i, water = 0; for (i = 1;i &lt; M*N;++i) &#123; int t = water + i*(S[i] - S[i - 1]) * 100; if (t &gt;= W) break; water = t; &#125; float level = (float)(W - water) / (float)(i * 100) + S[i - 1]; printf("Region %d\nWater level is %.2f meters.\n", ++T, level); printf("%.2f percent of the region is under water.\n\n", (float)(i * 100) / (float)(M*N)); &#125; return 0;&#125; 题意：简单的理解，就是给你一个铁桶，铁桶桶壁无限高，桶底是个长方形，一边长M · 10米，另一边长N · 10米。把这个桶底分为M · N个正方形区域，即每个正方形边长10米。现在每单个正方形区域高度处处都是一样的，每个不同的区域高度不一。现在一桶体积位W的水倒进去，问淹了多少区域，水高度多少。 分析：看懂这题后感觉很惊奇，原来在现实生活中都没想过的简单问题在编程里实现要考虑的东西还不少！紫书说：本题有多种解法，可以锻炼思维。那我先说说我想到的方法吧： 计算平均海拔后再看哪些地本应该是露在外面的，依此调整水高度。但是后来发现并不合算。 一桶水全浇第一块地上，往旁边扩散。但是怎么实现。。想想也不合算。 每10 · 10 · 1体积的水填进最低海拔的区域去，对于一样高的区域随便填哪个。直到最后可能发现水平面不平，把凸出来的水平均划分到整个没在水里的区域。但是按每一个单位的水来循环，循环量很大，最后凸出来的水也要分开计算。 现在使用的方法。（本来想到好几个方法，最后发现其实都很相近，把这些类似的方法整合、优化成了这一个）升序排序每一个区域的高度，一个区域一个区域地填水。具体如下： 这里写图片描述]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-9UVa1591 - Data Mining]]></title>
    <url>%2Fposts%2F55710.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 1234567891011121314151617#include&lt;iostream&gt;unsigned N, A, B, Sp, Sq, ansA, ansB;unsigned long long Pofs, K, nowK;int main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%u%u%u", &amp;N, &amp;Sp, &amp;Sq) != -1) &#123; K = 0xffffffffffffffff; for (A = 0;A &lt; 32;++A) for (B = 0;B &lt; 32;++B) &#123; Pofs = (N - 1)*Sp; nowK = (Pofs + (Pofs &lt;&lt; A) &gt;&gt; B) + Sq; if (nowK &gt;= N*Sq &amp;&amp; nowK &lt; K) K = nowK, ansA = A, ansB = B; &#125; printf("%llu %u %u\n", K, ansA, ansB); &#125; return 0;&#125; 题意：看着好复杂的题目。看了半天不懂，看网上人家的解释也是一头雾水。于是花了好久把他翻译并理解。翻译只是大概翻翻，但和原意基本一致，括号内的内容是我最终理解的内容。 翻译如下： Tuple博士正在给ACM公司研究数据挖掘。其中一个子工程是关于P、Q两个数组的，两个数组各含N组数据（这个“组”的单位是record，不知道怎么翻译好。论好好学习英语的重要性。）。这N个record的数据从0到N-1命名。数组P包含含密钥的类似哈希的结构。P用来给程序定位要用哪个record，且这个数据的对应的Q里的record待会会从Q数组里恢复出来（如紫书中文的理解就是知道P的第i个record的偏移量求Q第i个数据的偏移量）。 数组P中的每个record长度为Sp字节，Q的每个record长Sq字节。Tuple酱需要最最高效地执行这个程序，因为这是整个数据挖掘一直要用到的地方。但是坑爹的是Sp和Sq只在运行时知道其大小，没法在编译时进行优化（哦就跟定义数组必须要用常量来定义的原因类似）。 找到P数组的第i个record的偏移量（不懂偏移量是什么，差不多就是指：比如一个数组a[10]，那么a[3]的地址在首地址的右边地三个，偏移量就是(&amp;a[3]-a) · sizeof(int)，也就是3 · sizeof(int)。如果我没猜错应该就是了）的最直接的方法是用以下函数： Pods(i) = Sp * I (1) Q的也一样： Qods(i) = Sq * I (2) 但是！乘法比加减法慢多了（哦你好烦啊，直接说你最后用了什么就行了啊）。Tuple酱拒绝使用乘法。那么他怎么做的？他保存了已经计算好的第i个record的偏移量Pofs(i)，而不是保存这个下标（索引）i（哦就相当于一个数组a[10]，你已经计算得你要的数据是a[2]，现在别人要调用a[2]，你给他 p=&amp;a[2]比直接给他i=2让他自己找到a{2}更快。是这个意思吧）。于是现在当他需要计算第i个record旁边的record的偏移量时，就用下面的方程： Pofs(i + 1) = Pofs(i) + Sp Pofs(i - 1) = Pofs(i) – Sp （好吧，原来就相当于我们遍历数组时用指针p先指向首地址，然后不停p++指向下一个数据一样啊，比直接调用a[i++]快啊） 当一个P的record不管是用上面两个方法的哪个（用乘法扫描数组，及用其他数据的偏移量用加减法获得），Tuple酱需要从对应Q数组把数据恢复进去。要获取Q的record的偏移量Qofs(i)也要计算。当Pofs(i)已知时可以直接用(1)、(2)两个函数求得Qofs(i)。 Qofs(i) = Pofs(i)/SP SQ (3)（就把(1)、(2)整合了一下） 然后又来了。“Unfortunately”，这个函数不仅有乘法，甚至还有除法！“我不管我不管，乘除就是比加减慢！我就是不允许乘除的出现！” Tuple酱傲娇地鼓起了腮帮。 最后Tuple酱研究得出，可以这么求Qofs(i)： Qofs'(i) = (Pofs(i) + Pofs(i) &lt; &lt; A) &gt; &gt; B (4) （Qofs'(i)那个’不是求导的意思哦，我说一开始怎么没看懂。）(等一下让我查一下位移运算和加法运算的优先级。。。好的+比&lt;&lt;优先级高？？不对啊，那他要这个括号干嘛？看了下别人的代码，这里题目错了。应该是(Pofs(i) +（(Pofs(i) &lt; &lt; A)) &gt; &gt; B。但是还是没看懂怎么从(3)推出这个式子的??!!）（好的现在看懂了，这是一个新方法，和(3)无关，不是从(3)推导出来的。这个方法牺牲了些没用上的内存但是速度快了。详见分析） A和B是无符号整形。这个函数跑的比(3)不知道快到哪里去了。但是不管A、B选何值，它一般不能总是产生和(3)一样的结果（喵喵喵？？？为什么不一样？没看懂。根据紫书：“为了让(4)成立，在P数组连续存储的情况下Q可以不连续存储”我去？哪里说可以不连续存储了。好吧现在看懂了，最下面一起讲。）。但是如果你愿意牺牲点内存，你还是可以用。 传统的布局里，Q在内存里需要NSq字节去储存整个数组。Tuple发现总是可以找到一个K（K&lt;=NSq）（题目反了吧？？！！K&gt;=N · Sq还差不多，看样例输入输出也明显是1119&gt;=1024 · 1*），如果分配K字节的内存给Q且小心地找A和B的值，(4)会给不重复的把存储地址给数组Q的N个record。 你的目标是写一个程序找出当(4)被用时最小的内存K去分配给Q，对应的A、B也要找出来。若多个A、B得到一样的最小的K，那么找出A最小的那组，还不行，那就找B最小的。 (这个CSDN-markdown编辑器好垃圾啊，为什么不能输出多个空格？导致不能每段首行缩进两个字？？！！狂按空格也没效果。。我按空格你也要管。。) 分析：好的那么就是说 （比如如图，P是上面那个，每个数据占3bit，Q占2bit）以P的某个数据的偏移量按照(4)快速求出Q对应数据的地址（算的快的结果是部分内存没用上）。所以原来(3)、(4)不是等价的，是Tuple酱另外想的方法。我说怎么死活看不懂、推不出来(4)这个公式。 所以简言之，已知A和B，P的每一个元素的偏移量Pofs（其实就是第i个元素首地址位置）通过含A和B的公式4计算得出Qofs（即求出Q的第i个元素的位置）后，即知道了Q的各个元素的位置。现在要求找出Q最少占用多少空间，即求Q的后一个元素的最后一个字节的地址与分配的第一个内存地址的距离即可。（本来我还想Q的各个元素的存储位置不能重叠，要不要判断，但是题目已经说了，用公式4保证不会出现存储重叠） 那么暴力枚举A，B即可。而还有个问题，A，B没说范围。那么因为 &gt; 1 ≤ N ≤ 2^20,1 ≤ SP ≤ 2^10,1 ≤ SQ ≤ 2^10 因为Pofs最大为(N-1)Sp，所以这里最大(2^20-1) · 2^10差不多2的30次方。而long long64位，也就30多位可以给你移的。而且参考了 http://blog.csdn.net/code4101/article/details/38540759 这篇博文，那么30多次的枚举就行了。那么说到这里，这题其实是个超简单的题目。 / 本来我一开始看题目时觉得这都什么鬼，看不懂。 但是看到紫书上说“本题有一定实际意义，不过描述比较抽象。如果对本题兴趣不大，可以先跳过。”于是瞬间来了兴趣... （—。—） 哈哈我简直是个受虐狂。 */]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-8UVa12108 - Extraordinarily Tired Students]]></title>
    <url>%2Fposts%2F50108.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 1234567891011121314151617181920212223242526272829303132333435//UVa12108 - Extraordinarily Tired Students#include&lt;iostream&gt;struct how_cute_my_sleepy_boys_are &#123; int a,//awaken period : a&gt;=1; b,//sleeping period : b&lt;=5; s,//state : 0醒着,1睡觉; t;//time : 睡/醒到什么时候;&#125;g[12];int n, c, mi, cnt, T = 0;//cnt:统计睡着的人;mi:minuteint main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%d", &amp;n) &amp;&amp; n != 0) &#123; for (int I = 0;I &lt; n;++I) &#123;//读入数据 scanf("%d%d%d", &amp;g[I].a, &amp;g[I].b, &amp;c); g[I].s = (c &gt; g[I].a ? 1 : 0); g[I].t = (g[I].s ? g[I].a + g[I].b - c + 1 : g[I].a - c + 1); &#125; for (mi = 1;mi &lt; 400;++mi) &#123;//直接循环400分钟，不高兴做-1这一情况的循环检查了 cnt = 0; for (int I = 0;I &lt; n;++I)//计算本分钟的睡觉人数 if (g[I].s == 1) ++cnt; if (!cnt) break; for (int I = 0;I &lt; n;++I) &#123;//睡或醒状态转换 if (g[I].t != mi) continue; if (g[I].s == 1) g[I].s = 0, g[I].t += g[I].a; else if (cnt &gt; n / 2) g[I].s = 1, g[I].t += g[I].b; else g[I].t += g[I].a; &#125; &#125; printf("Case %d: %d\n", ++T, !cnt ? mi : -1); &#125; return 0;&#125; 题意：一个班级所有学生个个是特“困”生。每个人睡着和醒着有一定规律，那就是：醒着a分钟，然后想睡觉了，环顾四周，如果睡着的人比醒着的多，那我也睡，睡b分钟后再坚挺a分钟，否则直接再坚挺a分钟。简言之，也就是每醒a分钟就检查接下来是继续醒a分钟还是睡b分钟后再醒a分钟。（这“醒a分钟-睡b分钟”的a+b分钟被题目称为一个周期。）然后每个学生一上课就有个初始状态，是在各自醒-睡周期的第几分钟。求何时第一次全班醒着，还是说全班永远有人在睡觉。 分析：直接模拟每一分钟即可。struct一个结构体储存每个学生的状态，存放内容代码注释里已经很详细。本来t想存放的是还有几分钟到达目前状态的最后一分钟，但转念一想这样的话每分钟都要自减一次，直接存到哪一分钟更为便捷。具体模拟没用问题，很简单。 最大的问题是，就是老师上课永无天日的情况，永远没人醒着。本来我想做个数组存放每分钟的状态检查其是否构成循环，想想略麻烦，但是我看网上大家好多人都没检查，直接从一分钟检测到1000分钟（或其他很大的数字），1000分钟后还是没有全醒的情况就直接判定为“it'll never happen”。的确不够严谨但是很方便。最后昨晚睡觉前想了下，决定使用这个不严谨的方案。理由如下： 本来这每一分钟的模拟运算量就很小，还要每一分钟都去循环判断，有循环且循环很短的情况下不错，但是如果循环有几百分钟或很久后找到全醒的情况，综合这些情况下好像并不很合算。 题目的状态转换并不复杂，1000分钟甚至更短（我用的400分钟就AC了）该循环的绝对能循环了，当然数学上肯定能求出个这个分钟的最小值，也没必要去搞吧。 谁上个课上1000分钟啊！！！我一开始循环的150分钟，也已经2.5个小时了，结果WA，改成400分钟，AC了。400分钟已经6.666小时了。嗯，可以，老师学生们都很666。。。 听谁说过：竞赛题没人看你的代码是否优美，它也不关心你的算法，只要通过就行。→.→适当投机有益身心健康哈（大雾）。 懒得写循环检查了哈哈&gt;_&lt;。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-7UVa509 - RAID!]]></title>
    <url>%2Fposts%2F26431.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//UVa509 - RAID!#include&lt;iostream&gt;int d, s, b, t, times = 0;char disk_data[7][6666], type;inline char* disk(int x, int y, int z) &#123;//二维数组当作三维数组使,方便运算 return *(disk_data + x - 1) + (y - 1)*s + z - 1;&#125;inline char* parity(int y, int z) &#123;//定位到当前一行blocks的parity return *(disk_data + (y - 1) % d) + (y - 1)*s + z - 1;&#125;void print_data() &#123; int f = 1, n = 0; for (int j = 1;j &lt;= b;++j) for (int i = 1;i &lt;= d;++i) for (int k = 1;k &lt;= s;++k) &#123; if (disk(i, j, k) == parity(j, k)) continue; if (f == 5) &#123; printf("%X", n); f = 1, n = 0; &#125; n = (n &lt;&lt; 1) + *disk(i, j, k) - 48; ++f; &#125; printf("%X\n", (n &lt;&lt; (5 - f)));&#125;int main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%d", &amp;d) &amp;&amp; d != 0) &#123; scanf("%d%d\n%c", &amp;s, &amp;b, &amp;type); t = (type == 'E' ? 0 : 1); for (int i = 0;i &lt; d;++i) scanf("%s", disk_data[i]); for (int j = 1;j &lt;= b;++j) for (int k = 1;k &lt;= s;++k) &#123;//数据读取完毕,开始检测 int sum = 0; bool flag = false;//0:没有x问题;1:有一个x; char *p;//定位x的位置 for (int i = 1;i &lt;= d;++i) &#123; if (*disk(i, j, k) != 'x') sum += *disk(i, j, k) - '0'; else if (flag) goto o_O;//invalid:two or more disks are unavailable for that block else p = disk(i, j, k), flag = true;//出现第一个x,并定位 &#125; if (flag) *p = (sum % 2 == t ? '0' : '1');//计算x else if (sum % 2 != t) goto o_O;//invalid:a parity error is detected &#125; printf("Disk set %d is valid, contents are: ", ++times);//能执行完所有循环的才是真男人 print_data(); continue; o_O:printf("Disk set %d is invalid.\n", ++times);//我就是用goto了怎么着!跳出三重循环用goto多方便 &#125; return 0;&#125; 题意：好几块硬盘组RAID，组的方法是每个硬盘都平均划分成b个块(block)，每块硬盘的第i个块一起组成一个区域（也就是一块数据平均保存在n个硬盘里，实际上说是保存在n-1个硬盘里更合理，因为其中一块硬盘的这个区域保存的是用于数据恢复用的，名为parity block）同时不同parity还错开保存在不同的硬盘里，这样就有效防止了某个硬盘损坏导致全盘数组丢失。 而这个parity存的又到底是什么呢，是这一行每个data block对应的每个bit进行某种运算得来。运算法则可理解为，每个bit存的0或1进行相加，若结果(在我的代码里用sum表示)为偶数，parity对应bit储存为0，否则为1（even的情况。odd反过来：若为奇数储存为0。没什么意义，就是个标准不同）。 然后就是校验数据是否损坏。若直接告诉你一行里有一个损坏(表示为x)，那么没关系，可以通过其他那几个盘恢复。若一行里有俩损坏，那就没戏了。若一行没有出现x，那么所有数据相加，结果若为0（E的情况。O为1）则数据正常，否则出错。 分析：没什么特殊的思路，就一步步按照题目来呗。输入的格式和题目给的图表格式坐标是反的，比较讨厌。得用到三重循环，不同地方循环的顺序还不一样，比较绕，思路要理清了。然后三重循环跳出麻烦（因为我把其中两个循环写在了一行，这样理解上方便，代码看着也清楚，所以不方便加大括号），我就用了goto。是的我就是用goto了怎么着啦o_O！你咬我啊！在这种情况下多好用！具体算法都在代码注释里了。 还有那个print_data()函数，那个三重循环里面我本来写的是 123456789for (int j = 1;j &lt;= b;++j) for (int i = 1;i &lt;= d;++i) for (int k = 1;k &lt;= s;++k) &#123; if (f == 5) &#123; printf("%X", n); f = 1, n = 0; &#125; if (disk(i, j, k) == parity(j, k)) continue; n = (n &lt;&lt; 1) + *disk(i, j, k) - 48; ++f;&#125; 也就是三个步骤（是否输出、当前数据是否是parity的、是否读入数据到n）顺序不一样。我原本的目的是除了最后一个十六进制数字，其他均在三重循环里输出。理由是最后一个数据比较特殊，它有可能不满4bit，要手动添加0直至其满4bit，而且顺便要输出换行。下面这个版本有个bug，就是如果最最后一个block是parity block，那么会多输出一个0。原因很简单我就不说了，但是怎么改动我倒是想了很久，怎么改都要加变量、加好几个if，代码瞬间复杂很多，我不太情愿。最后发现只需要顺序倒一下即可！ 果然编程这个东西，顺序很重要啊。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-6UVa508 - Morse Mismatches]]></title>
    <url>%2Fposts%2F55954.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，10 ms） 123456789101112131415161718192021222324252627282930313233343536373839404142434445//UVa508 - Morse Mismatches#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;map&gt;using namespace std;map&lt;char, string&gt; morse;map&lt;string, string&gt; word;string wo, tran, result;char c;int cmp(string a, string b) &#123; if (a == b) return 0; if (a.size() &gt; b.size()) a.swap(b); if (a == b.substr(0, a.size())) return b.size() - a.size(); return 666;&#125;int main()&#123; //freopen("in.txt", "r", stdin); //ios::sync_with_stdio(false); while ((cin &gt;&gt; c) &amp;&amp; c != '*') cin &gt;&gt; morse[c]; while ((cin &gt;&gt; wo) &amp;&amp; wo[0] != '*') &#123; auto cp = wo.begin(); tran = morse[*cp]; while (++cp != wo.end()) tran += morse[*cp]; word[wo] = tran; &#125; while ((cin &gt;&gt; tran) &amp;&amp; tran[0] != '*') &#123; result.clear(); int min = 888; for (auto i = word.begin();i != word.end();++i) &#123; if (i-&gt;second == tran)//精确寻找 if (!result.size() || *result.rbegin() == '?') result = i-&gt;first; else &#123; result += "!";break; &#125; else if (!result.size() || *result.rbegin() == '?') &#123;//模糊寻找 int n = cmp(tran, i-&gt;second); if (n&lt;min) min = n, result = i-&gt;first + "?"; &#125; &#125; cout &lt;&lt; result &lt;&lt; '\n'; &#125; return 0;&#125; 分析：思路是先根据电报代码表把单词全部转换成代码，单词和其代码存在一个map里，然后一个个检测下面的码的匹配。精确匹配不用说，如果只找到一个，直接输出，找到多个的话还是只输出第一个，但加一个“!”；模糊匹配是检索每个单词的代码，看哪一串缺的最多出来的代码最少 / 看VJ上好些0ms的，但我又想不出来什么更好的算法。想过会不会是循环的问题，于是试过将精确寻找和模糊寻找分开循环，结果还是10ms。就想到应该又是流的速度太慢导致。就加了一句ios::sync_with_stdio(false);关了stdio同步，果然变0ms了。唉好吧。。不过想了想不必太较真，博客里使用的还是没关同步的版本。 不用map也可以做的，map似乎还自带排序来着？我也是第一次用map，一开始做没用map，后来想试试看map，就改了。不过改成map后好像有些问题，主要是针对char[]字符串，因为char[]不可以用=来赋值，只能用strcpy()函数，而用这个函数给map赋值报错了，编译通不过，捣鼓半天不知道怎么改，就改用string了，慢一点但是方便。 好几天没刷题了，整个人懒洋洋的，脑子使不出劲，这题写了好久。。主要还是那win10那破一周年更新，导致显卡驱动不正常，折腾了好几天，题目落下了。虽然作为一个win10脑残粉，甚至在考虑要不要回win7. /]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-5UVa1590 - IP Networks]]></title>
    <url>%2Fposts%2F35518.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 12345678910111213141516171819202122232425262728293031323334353637383940//UVa1590 - IP Networks#include&lt;iostream&gt;unsigned i, m, num, ip[4], ipmax[4], ipmin[4], mask[4];int cmp(unsigned *a, unsigned *b) &#123;//compare for (int i = 0;i &lt; 4;++i) &#123; if (a[i] &lt; b[i]) return -1; if (a[i] &gt; b[i]) return 1; &#125; return 0;&#125;int main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%d", &amp;m) != -1) &#123; scanf("%d.%d.%d.%d", &amp;ip[0], &amp;ip[1], &amp;ip[2], &amp;ip[3]); for (i = 0;i &lt; 4;++i) ipmax[i] = ipmin[i] = ip[i]; while (--m) &#123; scanf("%d.%d.%d.%d", &amp;ip[0], &amp;ip[1], &amp;ip[2], &amp;ip[3]); if (cmp(ip, ipmax) == 1) for (i = 0;i &lt; 4;++i) ipmax[i] = ip[i]; else if (cmp(ip, ipmin) == -1) for (i = 0;i &lt; 4;++i) ipmin[i] = ip[i]; &#125; for (i = 0;i &lt; 4;++i) &#123; if (i == 0 || mask[i - 1] == 255) &#123; mask[i] = 255 ^ (ipmax[i] ^ ipmin[i]); for (int j = 0;j &lt;= 8;++j) if ((mask[i] &gt;&gt; j) == (255 &gt;&gt; j)) &#123; mask[i] = ((mask[i] &gt;&gt; j) &lt;&lt; j); break; &#125; &#125; else mask[i] = 0; &#125; printf("%u.%u.%u.%u\n", mask[0] &amp; ipmax[0], mask[1] &amp; ipmax[1], mask[2] &amp; ipmax[2], mask[3] &amp; ipmax[3]); printf("%u.%u.%u.%u\n", mask[0], mask[1], mask[2], mask[3]); &#125; return 0;&#125; 分析：网上他们说这是水题ToT。。。他们说只要知道点IP地址的知识就行了。。。然而我并不知道。。。于是看那英文的题目也没细说ip地址与子网掩码的规则，就自己查了好久子网掩码和ip地址的转化规则，其实到现在也仅仅是“好像懂了”，却竟然做出来了，不知道是开心还是不开心。而且之前我也没学过按位运算，这次竟然自己摸索着运用的还可以。 IP地址与子网掩码转化规则如下：（假设ip地址为a，a 的子网掩码为b，图个打字方便） a与b（每一段分别）按位与，就得到它的smallest possible IP network 如果a1、a2、a3……分别与b“按位与”运算均得到一个答案，那么说明这些电脑全在一个子网里。 而现在要求已知很多地址，且知道他们在一个子网里，让你求smallest possible IP network和子网掩码。那么其实只要知道最大最小两个ip就行。于是找出最大最小，ipmax和ipmin。然后看ipmax和ipmin从哪一位（二进制）开始不同，从不同的那一位开始，那些电脑就是在同一个子网里了，于是可以求得子网掩码。我的算法是，最大最小两个ip进行异或运算，目的是找出第一个开始不一样的地方，然后再与1111 1111（二进制，即255）异或运算，相当于取反，但是这里不能直接使用取反运算“~”，因为一个unsigned有32位，会使得比1111 1111高位的0也取反。于是得到子网掩码的雏形。而子网掩码前n位连续为1，后32-n位连续为0，这个雏形仅仅办到了前n位为1，所以得想办法把后32-n位清零。于是用了这个方法 12345for (int j = 0;j &lt;= 8;++j) if ((mask[i] &gt;&gt; j) == (255 &gt;&gt; j)) &#123; mask[i] = ((mask[i] &gt;&gt; j) &lt;&lt; j); break; &#125; 再根据子网掩码和随意一个ip按位与，就得到smallest possible IP network。 （应该没说错吧）]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-4UVa253 - Cube painting]]></title>
    <url>%2Fposts%2F24045.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;char str[15];void change(int b) &#123;//更换顶上的面 char t; if(b) t = str[0], str[0] = str[1], str[1] = str[5], str[5] = str[3], str[3] = t; else t = str[0], str[0] = str[4], str[4] = str[5], str[5] = str[2], str[2] = t;&#125;bool compare() &#123; if (str[0] != str[6] || str[5] != str[11]) return 0; int i,j; for (i = 0;i &lt; 4;++i) &#123; for (j = 0;j &lt; 4;++j) if (str[(j + i) % 4 + 1] != str[j + 7]) break; if (j == 4) return 1; &#125; return 0;&#125;int main()&#123; //freopen("in.txt", "r", stdin); while (scanf("%s", str) != -1) &#123; int i; i = str[3], str[3] = str[4], str[4] = i; i = str[9], str[9] = str[10], str[10] = i; for (i = 0;i &lt; 6;++i) &#123; //printf("----------------%c%c%c%c%c%c\n", str[0], str[1], str[2], str[3], str[4], str[5]); if (compare()) break; if(i!=5) change(i%2); &#125; printf((i &lt; 6 ? "TRUE\n" : "FALSE\n")); &#125; return 0;&#125; 分析：这题告诉我认真审题的重要性。。。题目给的各个面的输入顺序是123546，即各个对面为1-6,2-5,3-4，而我当作了123456。。。于是面与面的对应关系错了。。我说怎么老是WA。 很奇怪题目为什么要这么给各个面的顺序，按他这样做起来比较烦（至少我没发现他故意这样排能有什么快速的途径）于是我把地4和第5个数据换了个位： 12i = str[3], str[3] = str[4], str[4] = i;i = str[9], str[9] = str[10], str[10] = i; 这样绕着上下两个面的中点所形成的直线旋转比较方便（也算是历史遗留问题。。。如果一开始就没看错题目的话，应该会想别的方法，现在WA的怕了，就直接转化一下数据了事）。 题目一共有6*4=24种情况，即6个面分别朝向上方时周围4各面旋转4次，所以甚至直接枚举也是极好的。VJ看到直接列6个数组，代表各个面朝上时其他面所在的情况，代码极其简洁： LINK。这里因为量不大，用枚举很不错啊。而我的还要做5次旋转，旋转需要要不停地赋值。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scanf的使用(主要是针对char)]]></title>
    <url>%2Fposts%2F5943.html</url>
    <content type="text"><![CDATA[学的是C++，用cin cout也用的很顺溜，写自己的类时重载“&lt;&lt;”与“&gt;&gt;”运算符也很爽，但是发现在刷算法竞赛题时，cin cout很没优势，输入量大时一道题我用cin cout要50ms，用scanf printf只要10ms、20ms，这个就差的太大了时间都花在输入输出上也是很郁闷。于是开始使用C的输入输出标准。输出很正常，也可以轻松更改double输出的精度，c++还要个iomanip头文件，还烦一点。格式化字符%u %d %ld %lld %f %lf %s %c等就这几个限死了，也就是只能输入输出这几个系统自带的格式，是没法将自己的类重载到里面的，，只能自己做个print函数。不过毕竟面向对象是c++的内容。 就是那个输入scanf有些异类。首先输入得取地址，输入int的a要&amp;a不能写a。这我总是忘记。先输入整形、long long、double、字符串什么的都没问题，可以任意换行。scanf(&quot;%d%d%d%d&quot;, &amp;a, &amp;b, &amp;c, &amp;d); 像下面这样输入 1234123 2 23 6 有任意空格和回车都可以接收。 而对于字符串char sss[100]，不支持空格的读取，要读取空格得用gets()。 而scanf(&quot;%s&quot;,sss)还是scanf(&quot;%s&quot;,&amp;sss)都可以，论坛里上说前者还少取个地址更快一点。 而对于char型，char ch;scanf(&quot;%c&quot;,ch)；可以是可以，但是不能像int等一样随心所欲地加空格和回车，明明说好的scanf自带无视回车和空格。比如下一段代码 1234567891011int main()&#123; int a, b, c, d; char x, y, z,s1[10],s2[10],s3[10]; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); scanf("%s%s%s", s1, s2, s3); scanf("%c%c%c", &amp;x, &amp;y, &amp;z); printf("%c%c%c", x, y, z); printf("%d%d%d%d\n'%c'\t'%c'\t'%c'\n%s\n%s\n%s", a, b, c, d, x, y, z,s1,s2,s3); return 0;&#125; 输入： 1111 222 333 444 555 666 777 8 9 0 输出： 12345111222333444' ' '8' ' '555666777请按任意键继续. . . 而输入： 12345678111222333444555666777890 则输出： 123456111222333444'' '8' '9'555666777请按任意键继续. . . char的什么回车啊空格啊都读进去了。 而如果先读入char，一旦char坏掉了，后面也全乱了。 ####我总结的规律是： scanf读取int等内容时，读取完一个数据后后面的空格回车仅仅是表示这个数据输入完了，没有略过，它一直存在于输入缓冲区，而到了下一个数据，若也是int或字符串什么的，会自动把空格回车略过，直到找到应输入的内容，然后读取。而char不同，它不忽略本该读取的数据前面的空白，就把那空格或回车读进去了，如果是有多个空格回车，剩下那些空白就依然还存在与缓冲区，给下一个char读取了。 ####我现在找到了以下几种解决方案 使用fflush(stdin)。scanf读取char之前，用fflush(stdin)空输入缓冲区，使其为空，然后输入char就不会有空白符阻碍了。 scanf读取char之前使用getchar()把''和' '吃了，getchar()不跳过空格回车。当然getchar()几次，即吃几个字符也是个问题，所以本方法仅适用于比如竞赛题什么的，输入格式都很标准，不会出现不定多少的空格回车。不过现在想想好像scanf和getchar功能一样欸，都不跳空白的。那么这么说来直接用scanf吸收空格应该也是可以的，比如scanf(&quot;%c%c&quot;,&amp;ch,&amp;ch)但是好像没见人用过。 VJ上看到这个写法scanf(&quot;%c&quot;,ch)，即在每个输入char的scanf里的%c前面，都加上。对于在scanf里不仅仅写%c还写其他的东西，就像输出一样，我没细研究，就知道比如scanf(&quot;233%c666&quot;,ch)我必须先输入233再输入char再输入666，想想好像也有道理，以此来忽略，但是我发现它也可以忽略空格。虽然不是很懂，空格和回车在编译器眼里一样吗？于是试了试scanf(&quot; %c&quot;,ch)，也一样的效果！于是这就达到了与输入int、double一样的格式，任意输入多少空格和回车都没事了。现在也是这么在用，虽然其实我不是很懂其原理。 CSDN论坛里看到有12级的大神说不要用scanf输入字符。。不是很懂，全用getchar()吗。。。还是输入字符转用cin。。。 0.0 [震惊哭]。 附[方法三]实例： 1234567891011int main()&#123; int a, b, c, d; char x, y, z,s1[10],s2[10],s3[10]; scanf("%d%d%d%d", &amp;a, &amp;b, &amp;c, &amp;d); scanf("%s%s%s", s1, s2, s3); scanf(" %c\n%c %c", &amp;x, &amp;y, &amp;z); //x = getchar(), y = getchar(), z = getchar(); printf("%d%d%d%d\n'%c'\t'%c'\t'%c'\n%s\n%s\n%s", a, b, c, d, x, y, z,s1,s2,s3); return 0;&#125; 输入： 12345671 2 3 4 5 6 7 8 9 0 输出： 123451234'8' '9' '0'567请按任意键继续. . .]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-3UVa220 - Othello]]></title>
    <url>%2Fposts%2F25421.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182//UVa 220 - Othello#include&lt;iostream&gt;char Board[11][11], Current, Command[5];bool Flag, L_Refresh;//flag用于空格的输出,同时可以判断出本局是不是当前颜色的棋子无路可走int Times, Num[2];//Num:0白1黑int Rx[] = &#123; 0, 0,1,-1,1,-1,1,-1 &#125;;int Ry[] = &#123; 1,-1,0, 0,1,-1,-1,1 &#125;;inline char oppo() &#123; return (Current == 'W' ? 'B' : 'W'); &#125;bool judge(int i, int j, int x, int y, bool is_print) &#123; int ii = i + 1, jj = j + 1, flg = 0; while ((i += x) &lt; 8 &amp;&amp; (j += y) &lt; 8 &amp;&amp; i &gt;= 0 &amp;&amp; j&gt;=0) &#123; if (Board[i][j] == '-') break; if (Board[i][j] == Current) &#123; if (!flg) break; if (is_print) &#123; if (Flag) printf(" "); printf("(%d,%d)", ii, jj); &#125; if (!Flag) Flag = true; return true; &#125; ++flg; &#125; return false;&#125;void change(int i, int j, int x, int y) &#123; int n = 0; while (Board[i += x][j += y] != Current) &#123; Board[i][j] = Current, ++n; &#125; Current == 'W' ? (Num[0] += n, Num[1] -= n) : (Num[0] -= n, Num[1] += n);&#125;void L(bool is_print) &#123; L_Refresh = 1, Flag = 0; for (int i = 0;i &lt; 8;++i) for (int j = 0;j &lt; 8;++j) &#123; if (Board[i][j] != '-') continue; for (int l = 0;l &lt; 8;++l) if (judge(i, j, Rx[l], Ry[l], is_print)) break; &#125; if (is_print) Flag ? printf("\n") : printf("No legal move.\n");&#125;void M() &#123; char i = Command[1] - 49, j = Command[2] - 49; if (!L_Refresh) L(0); if (!Flag) Current = oppo(); for (int l = 0;l &lt; 8;++l) if (judge(i, j, Rx[l], Ry[l], 0)) change(i, j, Rx[l], Ry[l]); Current == 'W' ? Num[0] += 1 : Num[1] += 1; Board[i][j] = Current; Current = oppo(); L_Refresh = 0; printf("Black - %2d White - %2d\n", Num[1], Num[0]);&#125;void Q() &#123; for (int i = 0;i &lt; 8;++i) printf("%s\n", Board[i]);&#125;int main()&#123; //freopen("in.txt", "r", stdin); scanf("%d", &amp;Times); while (Times--) &#123; for (int i = 0;i &lt; 8;++i) scanf("%s", Board[i]); scanf("\n%c", &amp;Current); L_Refresh = 0; Num[0] = Num[1] = 0; for (int i = 0;i &lt; 8;++i) for (int j = 0;j &lt; 8;++j) &#123; if (Board[i][j] == 'W') ++Num[0]; else if (Board[i][j] == 'B') ++Num[1]; &#125; while (scanf("%s", Command) &amp;&amp; Command[0] != 'Q') Command[0] == 'L' ? L(1) : M(); Q(); if (Times) printf("\n"); &#125; return 0;&#125; 分析： 在uDebug上调试都对了，提交时还是无限WA，挠的头发都要掉光了，最后发现忘记把freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);加注释了@。@。。。。气得我笑出声。 首先是List all possible moves for the current player.有上下左右与4条斜线8种情况。8*8个格子每个都要检索一遍。先judge()查看每个位置各个方向是否legal，如果可以放置，输出之。输出直接放在judge里了，不高兴写入字符数组了，后面M()也会用到judge，这时不希望他输出，于是给judge()加了个is_print变量来控制。尽量代码重用。还有对于这八个方向，我一开始是用的傻傻的枚举， 12345678if (judge(i, j, 0, 1, is_print)) continue;if (judge(i, j, 0, -1, is_print)) continue;if (judge(i, j, 1, 0, is_print)) continue;if (judge(i, j, -1, 0, is_print)) continue;if (judge(i, j, 1, 1, is_print)) continue;if (judge(i, j, -1, -1, is_print)) continue;if (judge(i, j, 1, -1, is_print)) continue;if (judge(i, j, -1, 1, is_print)) continue; 后来VJ上看到别人用以下数组， 1int rx[] = &#123; 0, 0,1,-1,1,-1,1,-1 &#125;， ry[] = &#123; 1,-1,0, 0,1,-1,-1,1 &#125;; 一开始没看懂他这奇怪的数组干嘛的，看懂后真的是令我拍大腿叫绝。 所以现在只需一个循环 12for (int l = 0;l &lt; 8;++l) if (judge(i, j, Rx[l], Ry[l], 0)) change(i, j, Rx[l], Ry[l]); 即可，真心方便。下面M()函数也一样。 还有就是L_Refresh的作用。系统有可能一口气执行多次L()（当然我不确定，只是有可能），也可能未执行就执行M，这时需要知道是不是无合法操作，还得先执行L()，L_Refresh就是用来检测L()有没有执行过，且防止其重复执行多次。 还有那个输出，比如“Black - 1 White - 4”，数字1和4在输出时应用“ %2d”输出，而不是两个空格键。之前看题目“Black - xx White - yy”的xx、yy没看懂，后来才知道是占两个格子的意思。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-2UVa201 - Squares]]></title>
    <url>%2Fposts%2F61878.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，20 ms） 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int N, M, x, y, CO[12], Times = 0;// 2 &lt;=n&lt;= 9,CO=Countchar SQ[12][12], ch;inline bool V(char a) &#123; return (a == 'B' || a == 'V' ? 1 : 0); &#125;inline bool H(char a) &#123; return (a == 'B' || a == 'H' ? 1 : 0); &#125;int main()&#123; //freopen("in.txt", "r", stdin); while (~scanf("%d%d",&amp;N,&amp;M)) &#123; getchar(); memset(SQ, '0', sizeof(SQ)); memset(CO, 0, sizeof(CO)); for (int i = 0;i &lt; M;++i) &#123; scanf("%c%d%d", &amp;ch, &amp;x, &amp;y); getchar(); if (SQ[x][y] == '0') SQ[x][y] = ch; else SQ[x][y] = 'B';//Both &#125; for (x = 1;x &lt; N;++x) for (y = 1;y &lt; N;++y) &#123; int ml = (x &gt; y ? N - x : N - y);//max_length,最大边长 for (int i = 1;i &lt;= ml;++i) &#123; int j; for (j = 0;j &lt; i;++j) if (!V(SQ[y][x + j]) || !V(SQ[y + i][x + j]) || !H(SQ[x][y + j]) || !H(SQ[x + i][y + j])) break; if (j == i) ++CO[i]; &#125; &#125; int flag = 0; if(Times)printf("\n**********************************\n\n"); printf("Problem #%d\n\n",++Times); for (int i = 1;i &lt; N;++i) if (CO[i]) &#123; printf("%d square (s) of size %d\n", CO[i],i); if (!flag) flag = 1; &#125; if (!flag) printf("No completed squares can be found.\n"); &#125; return 0;&#125; 分析：把每个可能的正方形都枚举一遍。。比较坑的是V和H的坐标顺序是反的。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典(第2版) 4-1UVa1589 - Xiangqi]]></title>
    <url>%2Fposts%2F28602.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 代码：（Accepted，0 ms） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293//UVa1589#include&lt;iostream&gt;#include&lt;cmath&gt;#define P(x,y) Pi[x].position[y]using namespace std;int N;//2&lt;=N&lt;=7bool A[4];//around,储存"将"周围是不是已经不能走了 0上 1左 2下 3右struct piece &#123; char name; int position[2];//0x 1y&#125;Pi[10];inline bool f1(int i, int j, bool po) &#123;//判断第j个子是否堵在第i个子前面,针对"车"和"帅"和"炮" if (P(i, (po + 1) % 2) != P(j, (po + 1) % 2)) return 0; int ii = P(i, po) - P(0, po), jj = P(j, po) - P(0, po); if (ii &gt; 0 &amp;&amp; jj &gt; 0 &amp;&amp; ii &gt; jj) return 1; if (ii &lt; 0 &amp;&amp; jj &lt; 0 &amp;&amp; ii &lt; jj) return 1; return 0;&#125;inline bool f2(int i) &#123;//判断第i个子是不是在"将"周围 if (P(i, 0) == P(0, 0) &amp;&amp; abs(P(i, 1) - P(0, 1)) == 1) return 1; if (P(i, 1) == P(0, 1) &amp;&amp; abs(P(i, 0) - P(0, 0)) == 1) return 1; return 0;&#125;bool f3(int i, int xx, int yy) &#123;//判断"马"是否可以到达"将"周围 if ((abs(xx) == 2 &amp;&amp; abs(yy) == 1) || (abs(xx) == 1 &amp;&amp; abs(yy) == 2)) &#123; for (int j = 0;j &lt;= N;++j) &#123; if (P(j, 0) == P(i, 0) - int(xx / 2) &amp;&amp; P(j, 1) == P(i, 1) - int(yy / 2)) return 0; //cerr &lt;&lt;"H:"&lt;&lt;i&lt;&lt;' '&lt;&lt;j&lt;&lt;'\t'&lt;&lt; P(j, 0) &lt;&lt; ' ' &lt;&lt; P(i, 0) - int(xx / 2) &lt;&lt; '\t' &lt;&lt; P(j, 0) &lt;&lt; ' ' &lt;&lt; P(i, 1) - int(yy / 1) &lt;&lt; '\n';//------------------- &#125; return 1; &#125; return 0;&#125;void GR(int i, bool po) &#123;//"将"和"车"的函数 if (P(i, (po + 1) % 2)&gt;P(0, (po + 1) % 2) + 1 || P(i, (po + 1) % 2) &lt; P(0, (po + 1) % 2) - 1) return; int j = 1; for (;j &lt;= N&amp;&amp;!f1(i, j, po);++j); if (j &gt; N) &#123; if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) - 1) &#123; if (!f2(i)) A[(po + 1) % 2] = 1; &#125; else if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) + 1) &#123; if (!f2(i))A[(po + 1) % 2 + 2] = 1; &#125; else if (f2(i)) P(i, po) - P(0, po) &gt; 0 ? A[po] = 1 : A[po + 2] = 1; else A[po] = A[po + 2] = 1; &#125;&#125;void H(int i) &#123;//"马"的函数 if (f2(i)) return; if (!A[0] &amp;&amp; f3(i, P(i, 0) - (P(0, 0) - 1), P(i, 1) - P(0, 1))) A[0] = 1; if (!A[1] &amp;&amp; f3(i, P(i, 0) - P(0, 0), P(i, 1) - (P(0, 1) - 1))) A[1] = 1; if (!A[2] &amp;&amp; f3(i, P(i, 0) - (P(0, 0) + 1), P(i, 1) - P(0, 1))) A[2] = 1; if (!A[3] &amp;&amp; f3(i, P(i, 0) - P(0, 0), P(i, 1) - (P(0, 1) + 1))) A[3] = 1;&#125;void C(int i, bool po) &#123;//"炮"的函数 if (f2(i) || P(i, (po + 1) % 2) &gt; P(0, (po + 1) % 2) + 1 || P(i, (po + 1) % 2) &lt; P(0, (po + 1) % 2) - 1) return; int flag = 0; for (int j = 1;j &lt;= N;++j) if (f1(i, j, po)) ++flag; if (flag == 1) &#123; if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) - 1) A[(po + 1) % 2] = 1; else if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) + 1) A[(po + 1) % 2 + 2] = 1; else &#123; int j = 1; for (;j &lt;= N;++j) if (f1(i, j, po) &amp;&amp; f2(j)) break; if (j &lt;= N) P(i, po) - P(0, po) &gt; 0 ? A[po] = 1 : A[po + 2] = 1; else A[po] = A[po + 2] = 1; &#125; &#125;&#125;int main()&#123; //freopen("in.txt", "r", stdin); //freopen("out.txt", "w", stdout); while ((cin &gt;&gt; N &gt;&gt; P(0, 0) &gt;&gt; P(0, 1)) &amp;&amp; N &amp;&amp; P(0, 0) &amp;&amp; P(0, 1)) &#123; for (int i = 1;i &lt;= N;++i) cin &gt;&gt; Pi[i].name &gt;&gt; P(i, 0) &gt;&gt; P(i, 1); A[0] = (P(0, 0) == 1 ? 1 : 0); A[1] = (P(0, 1) == 4 ? 1 : 0); A[2] = (P(0, 0) == 3 ? 1 : 0); A[3] = (P(0, 1) == 6 ? 1 : 0); //cerr &lt;&lt; "A:" &lt;&lt; A[0] &lt;&lt; '\t' &lt;&lt; A[1] &lt;&lt; '\t' &lt;&lt; A[2] &lt;&lt; '\t' &lt;&lt; A[3] &lt;&lt; "\n";//-------- for (int i = 1;i &lt;= N;++i) &#123; if (Pi[i].name == 'G') GR(i, 0); else if (Pi[i].name == 'R') GR(i, 0), GR(i, 1); else if (Pi[i].name == 'H') H(i); else C(i, 0), C(i, 1); &#125; int i; //cerr &lt;&lt; "A:" &lt;&lt; A[0] &lt;&lt; '\t' &lt;&lt; A[1] &lt;&lt; '\t' &lt;&lt; A[2] &lt;&lt; '\t' &lt;&lt; A[3] &lt;&lt; "\n";//-------- for (i = 0;i &lt; 4 &amp;&amp; A[i];++i); cout &lt;&lt; (i &lt; 4 ? "NO" : "YES") &lt;&lt; '\n'; &#125; return 0;&#125; 分析： 看着挺烦的，以为会调试很久，有那么多情况，感觉还不好找出错的点。结果两遍就AC了，喜出望外~ 我的思路是，判断每个子有没有把“将”周围堵住，对棋子大循环。同时我没有定义9*10的大棋盘。（现在想想定义了个棋盘好像简单好多。甚至可以打表查看哪里红子可以到达。或许我太过在意空间的占用了） A[4]的0上 1左 2下 3右是有顺序要求的，这样定义可以方便地和po对应起来。 车炮帅的攻击范围都是直线，所以定义的函数只针对其中一个方向，而G只能是向x轴方向出击，所以是只使用向x轴（po=0）方向的函数，而车和炮要使用两次函数。这三者有两种情况将军，第一是指向“将”旁边，使“将”无法向旁边行走。另一种是直接指向“将”，使之只能往旁边走不能在车炮指向的方向行走。三者都得考虑被堵住看不见“将”的情况。 不过这题有个小bug，就是将和帅面对面的情况，将可以直接飞过去翻盘赢了，无需躲闪。但是题目好像没有考虑这种情况，应该是规避了这类输入数据。我也是点击“Submit”时突然想起来这个情况没写。。。不过竟然AC了，那就算了。。。 还有就是车和炮直接在将旁边的情况，将可以吃掉它们消除威胁（当然前提是没有别人可以吃这个位置）。这个情况下，比如红车在（1，6），黑将在（1，5），那么黑将可以向右吃掉它，但是不能向左，因为向左进入（1，4）后车依然可以吃“将”。这是比较特殊的。 还有就是这一段： 123//在GR(...)函数的最后几行if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) - 1) &#123; if (!f2(i)) A[(po + 1) % 2] = 1; &#125;else if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) + 1) &#123; if (!f2(i))A[(po + 1) % 2 + 2] = 1; &#125; 本来我写的是 12if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) - 1) A[(po + 1) % 2] = 1;else if (P(i, (po + 1) % 2) == P(0, (po + 1) % 2) + 1) A[(po + 1) % 2 + 2] = 1; 没有后面的if。结果出现的问题就是当比如车在（1，6），将在（1，5）时，会判定为在针对x轴方向时，（1，6）（即将右侧，即A[3]）是将不可以走的。 还有炮的函数C，对于该函数最后几行， 123456else &#123; int j = 1; for (;j &lt;= N;++j) if (f1(i, j, po) &amp;&amp; f2(j)) break; if (j &lt;= N) P(i, po) - P(0, po) &gt; 0 ? A[po] = 1 : A[po + 2] = 1; else A[po] = A[po + 2] = 1; &#125; 意思是，如果炮架子刚好在将前面，那么炮只能攻击将的后面（即“将”不能后移），将前面即跑架子所在那个点打不到。 马的函数竟然算是最简单的了。。判断够不够得到将旁边的点，已及马有没有蹩脚即可。 附：uDebug上看到的测试数据： 2 1 4 G 10 5 R 6 4 3 1 5 H 4 5 G 10 5 C 7 5 2 1 5 R 4 4 G 10 5 3 1 5 G 10 4 R 5 5 H 3 7 4 1 5 G 10 4 C 6 5 H 5 5 R 1 1 5 1 5 G 10 4 C 6 5 H 5 5 H 4 5 R 1 1 3 1 5 G 10 4 C 2 7 H 3 7 3 1 5 G 10 4 R 5 5 R 1 6 4 1 5 G 10 4 R 5 5 R 1 6 H 3 7 0 0 0]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的整形大数类(支持正负)]]></title>
    <url>%2Fposts%2F18423.html</url>
    <content type="text"><![CDATA[好几天没刷题没看书没写博客了，一直在闭关修炼写大数，现在终于写出来啦！我也终于有了属于我自己的大数~~~~并且以头文件的形式写出的，可以算是一个完整的成品了，拿过来就可以用。 本大数类：longer实现的功能：加减乘除、取余、取绝对值，开根号什么的没精力弄了，只是声明了一下没定义，以后会更新的。同时支持正负号。数据用的vector&lt; long long &gt;存储，long long最大储存9位数，也就是999999999，因为2个999999999相乘刚好不越界。不过后来发现好像没必要，用int就行了，但是写都写一半了，就没改。不过灵活性也蛮高的吧，可以很轻松地把数据类型从long long 改为int，同时只要把MAX改为int的最大值10000，把DIGIT改为4即可（没具体试过，应该没问题）。就是下面这几行： 1234//longer类内定义typedef long long ll;static constexpr ll MAX = 1000000000;static constexpr int DIGIT = 9; 当然有储存，这应该不是最好的方法，不过就我目前的水平就这样吧。而且现在对于编程是“空间换时间”还是“时间换空间”一直很纠结。。。 然后单独定义一个sign表示正负号。那么当然啦，对于这种用单独一个符号标记来表示正负数字的，就会有+0和-0的问题，我也是基本解决了，就是把负的改成正的。当然不排除还有bug，没精力检测了。后续更新吧。 加法减乘除均使用小学教的竖式方法。。。因为网上也没学到更快的方法，最快的方法（尤其是除法）好像看到个，没会。。。所以这个东西在处理比如一千多位除以几百之类的数据时会很慢。。。不过毕竟我现在还算是新手嘛，以后可以还会再写一个更快的大数。使用竖式时，加法减法乘法使用的10^10进制，即统一算出一个ll（long long）的值，进位到下一个。 加法减法本质上由get_addition()与get_subtraction()实现，这两个函数无视正负号，全都看成是正的进行运算，只支持大的数加减小的数。因此对于有不同的正负符号的数字，比如负+正，可以看作-（正-负），所以只要调用get _subtraction()运算后添个负号即可；而对于正-负，可看作正+正，反而调用get _addition()。所以本质上还是正数之间的运算。 乘法与加法类似，甚至还少了符号的问题。 除法也是小学教的竖式法，一位位除，也就是一位位减，但是由于我得先乘以10的好多次，再循环减，再看下一位，速度还是慢，就比如3000位的数字除以50位的数字，那速度醉啦，要十几秒。 取余使用的&quot;this - (this / n)*n&quot;，所以比除号还慢。 比较符号没有很仔细地调试，但是应该没什么问题吧。 截图： 这里写图片描述 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365//我的大数类，定义为longer好了[笑哭]#ifndef _LONGER_H#define _LONGER_H#include&lt;vector&gt;#include&lt;string&gt;#include&lt;sstream&gt;#include&lt;iomanip&gt;//#pragma warning(disable:4996) //对使用VS2015且开启了“安全开发生命周期(SDL)检测”的项目奏效(VS2013应该也有用)class longer&#123; //必要定义 (-.-;) typedef long long ll; static constexpr ll MAX = 1000000000; //每个ll的存储限制，999999999*999999999刚好不溢出(9个9) static constexpr int DIGIT = 9; //ll支持的最大位数 //数据储存 (-.-;) bool sign; //正负号：0正1负 std::vector&lt;ll&gt; number; //大数存储区public: //构造函数 (-.-;) longer(); longer(const ll&amp;); longer(const longer&amp;); longer(const char*); longer(const std::string&amp;); //运算符重载 (-.-;) longer operator +()const; longer operator +(const longer&amp;)const; longer operator -()const; longer operator -(const longer&amp;)const; longer operator *(const longer&amp;)const; longer operator /(const longer&amp;)const; longer operator %(const longer&amp;)const; longer&amp; operator ++(); longer operator ++(int); longer&amp; operator --(); longer operator --(int); longer&amp; operator =(const ll&amp;); longer&amp; operator =(const longer&amp;); longer&amp; operator =(const char*); longer&amp; operator =(const std::string&amp;); longer&amp; operator +=(const longer&amp;); longer&amp; operator -=(const longer&amp;); longer&amp; operator *=(const longer&amp;); longer&amp; operator /=(const longer&amp;); inline bool operator &lt;(const longer&amp;)const; inline bool operator &gt;(const longer&amp;)const; inline bool operator &lt;=(const longer&amp;)const; inline bool operator &gt;=(const longer&amp;)const; inline bool operator ==(const longer&amp;)const; inline bool operator !=(const longer&amp;)const; friend std::istream&amp; operator &gt;&gt;(std::istream&amp;, longer&amp;); friend std::ostream&amp; operator &lt;&lt;(std::ostream&amp;, const longer&amp;); //其他函数 (-.-;) int digit()const; static longer lrabs(const longer&amp;); //求绝对值 static longer lrsqrt(const longer&amp;); //求算数平方根,暂时没打算完成，先占个茅坑,不拉屎private: //类内部调用 (-.-;) longer(const int, const ll&amp;); //分配多少个vector容量，每个数据均为第一个参数 static longer&amp; get_addition(longer&amp;, const longer&amp;, bool); //获得加法结果,仅支持正整数以大加小,无视正负号 static longer&amp; get_subtraction(longer&amp;, const longer&amp;, bool); //获得减法结果,仅支持正整数以大减小,无视正负号 int get_comparison(const longer&amp;)const; //获得比较结果,仅支持正整数相互比较,无视正负号 inline ptrdiff_t get_ptrdiff()const; //获得vector数组元素个数 inline longer&amp; get_zero(); //若结果为0,且若0的sign为负，则改为0&#125;;//必要定义 ↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗constexpr longer::ll longer::MAX;constexpr int longer::DIGIT;//构造函数 ↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗longer::longer() &#123; number.push_back(0); &#125;longer::longer(const ll&amp; n) &#123; *this = n; &#125;longer::longer(const longer&amp; n) &#123; *this = n; &#125;longer::longer(const char* s) &#123; *this = s; &#125;longer::longer(const std::string&amp; s) &#123; *this = s; &#125;longer::longer(const int i, const ll&amp; n) : number(i, n), sign(0) &#123;&#125;//运算符重载 ↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗//加减乘除取余次方longer longer::operator +()const &#123; return *this; &#125;longer longer::operator +(const longer&amp; n)const&#123; bool judge = get_comparison(n) &gt;= 0; longer aa(judge ? *this : n); auto &amp;bb = (judge ? n : *this); if ((!aa.sign) &amp;&amp; (!bb.sign)) return get_addition(aa, bb, 0); //正+正 if ((!aa.sign) &amp;&amp; (bb.sign)) return get_subtraction(aa, bb, !judge); //正+负 if ((aa.sign) &amp;&amp; (!bb.sign)) return get_subtraction(aa, bb, judge); //负+正 return get_addition(aa, bb, 1); //负+负&#125;longer longer::operator -()const &#123; longer t(*this);t.sign = (t.sign ? 0 : 1);return t; &#125;longer longer::operator -(const longer&amp; n)const&#123; bool judge = get_comparison(n) &gt;= 0; longer aa(judge ? *this : n); auto &amp;bb = (judge ? n : *this); if ((!aa.sign) &amp;&amp; (!bb.sign)) return get_subtraction(aa, bb, !judge); //正-正 if ((!aa.sign) &amp;&amp; (bb.sign)) return get_addition(aa, bb, 0); //正-负 if ((aa.sign) &amp;&amp; (!bb.sign)) return get_addition(aa, bb, 1); //负-正 return get_subtraction(aa, bb, judge); //负-负&#125;longer longer::operator *(const longer&amp; n)const&#123;//模拟小学老师教的方法 int leni = get_ptrdiff(), lenj = n.get_ptrdiff(); longer re(leni + lenj, 0); ll flag; sign == n.sign ? re.sign = 0 : re.sign = 1; for (int i = 0;i &lt; leni;++i) &#123; longer t(n); int j; flag = 0; for (j = 0;j &lt; lenj;++j) &#123; t.number[j] = t.number[j] * number[i] + flag; flag = t.number[j] / MAX; t.number[j] -= flag*MAX; &#125; if (flag) t.number.push_back(flag); flag = 0; for (j = 0;j &lt; t.get_ptrdiff();++j) &#123; re.number[i + j] += t.number[j] + flag; if (re.number[i + j] &gt;= MAX) re.number[i + j] -= MAX, flag = 1; else flag = 0; &#125; if (flag) re.number[i + j] += flag; &#125; while (re.get_ptrdiff() &gt; 1 &amp;&amp; !*re.number.rbegin()) re.number.pop_back(); return re.get_zero();&#125;longer longer::operator /(const longer&amp; n)const&#123;//模拟小学老师教的方法 if (n == longer((ll)0)) &#123; std::cerr &lt;&lt; "除数为0!\n";exit(1); &#125; longer th(*this), re((ll)0); re.sign = th.sign = 0; const int times = digit() - n.digit(); for (int i = times;i &gt;= 0;--i) &#123; longer digi(i / DIGIT + 1, 0); *digi.number.rbegin() = ((ll)pow(10, i % DIGIT)); longer t(n*digi); t.sign = 0; while (th.get_comparison(t) == 1) th-=t, re += digi; if (th.get_comparison(t) == 0) &#123; re += digi;break; &#125; &#125; if (sign != n.sign) re.sign = 1; return re.get_zero();&#125;longer longer::operator %(const longer&amp; n)const&#123; longer re(*this - (*this / n)*n); return re.get_zero();&#125;//自增自减longer&amp; longer::operator ++() &#123; return *this = *this + 1; &#125;longer longer::operator ++(int) &#123; longer t = *this;*this = *this + 1;return t; &#125;longer&amp; longer::operator --() &#123; return *this = *this - 1; &#125;longer longer::operator --(int) &#123; longer t = *this;*this = *this - 1;return t; &#125;//赋值longer&amp; longer::operator =(const ll&amp; n)&#123; if (n &lt; 0) sign = 1, number.push_back(-n); else sign = 0, number.push_back(n); return *this;&#125;longer&amp; longer::operator =(const longer&amp; n)&#123; number = n.number; sign = n.sign; return *this;&#125;longer&amp; longer::operator =(const char* s)&#123; return *this = std::string(s);&#125;longer&amp; longer::operator =(const std::string&amp; s)&#123; auto ps = s.rbegin(); char c[DIGIT + 1], *pc; ll temp; sign = 0; while (ps != s.rend()) &#123; *(pc = &amp;c[DIGIT]) = '\0'; int i; for (i = 0;i &lt; DIGIT &amp;&amp; ps != s.rend();++i) *--pc = *ps++; if (*(ps - 1) == '-') *pc = '0', sign = 1; while (i++ &lt; DIGIT) *--pc = '0'; std::istringstream in(c); in &gt;&gt; temp; number.push_back(temp); &#125; if (get_ptrdiff()&gt;1 &amp;&amp; !*number.rbegin()) number.pop_back(); return *this;&#125;longer&amp; longer::operator +=(const longer&amp; n) &#123; return *this = *this + n; &#125;longer&amp; longer::operator -=(const longer&amp; n) &#123; return *this = *this - n; &#125;longer&amp; longer::operator *=(const longer&amp; n) &#123; return *this = *this * n; &#125;longer&amp; longer::operator /=(const longer&amp; n) &#123; return *this = *this / n; &#125;//比较inline bool longer::operator &lt;(const longer&amp; n)const&#123; if ((!sign) &amp;&amp; (n.sign)) return 0; if ((sign) &amp;&amp; (!n.sign)) return 1; if ((!sign) &amp;&amp; (!n.sign)) return get_comparison(n) == -1; return get_comparison(n) == 1;&#125;inline bool longer::operator &gt;(const longer&amp; n)const&#123; if ((!sign) &amp;&amp; (n.sign)) return 1; if ((sign) &amp;&amp; (!n.sign)) return 0; if ((!sign) &amp;&amp; (!n.sign)) return get_comparison(n) == 1; return get_comparison(n) == -1;&#125;inline bool longer::operator &lt;=(const longer&amp; n)const&#123; if ((!sign) &amp;&amp; (n.sign)) return 0; if ((sign) &amp;&amp; (!n.sign)) return 1; if ((!sign) &amp;&amp; (!n.sign)) return get_comparison(n) &lt;= 0; return get_comparison(n) &gt;= 0;&#125;inline bool longer::operator &gt;=(const longer&amp; n)const&#123; if ((!sign) &amp;&amp; (n.sign)) return 1; if ((sign) &amp;&amp; (!n.sign)) return 0; if ((!sign) &amp;&amp; (!n.sign)) return get_comparison(n) &gt;= 0; return get_comparison(n) &lt;= 0;&#125;inline bool longer::operator ==(const longer&amp; n)const&#123; if (((!sign) &amp;&amp; (n.sign)) || ((sign) &amp;&amp; (!n.sign))) return 0; return !get_comparison(n);&#125;inline bool longer::operator !=(const longer&amp; n)const&#123; if (((!sign) &amp;&amp; (n.sign)) || ((sign) &amp;&amp; (!n.sign))) return 1; return get_comparison(n) != 0;&#125;//输入输出std::istream&amp; operator &gt;&gt;(std::istream&amp; is, longer&amp; n)&#123; std::string s;is &gt;&gt; s; n = s; return is;&#125;std::ostream&amp; operator &lt;&lt;(std::ostream&amp; os, const longer&amp; n)&#123; auto p = n.number.rbegin(); if (n.sign) os &lt;&lt; '-'; os &lt;&lt; *p; for (++p;p != n.number.rend();++p) &#123; int i = 0;auto n = *p; while (n /= 10) ++i; for (;++i &lt; longer::DIGIT;std::cout &lt;&lt; '0'); os &lt;&lt; *p; &#125; return os;&#125;//其他函数 ↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗int longer::digit()const&#123; int a = (get_ptrdiff() - 1) * DIGIT; ll b = *number.rbegin(); do ++a;while (b /= 10); return a;&#125;longer longer::lrabs(const longer&amp; n) &#123; longer t(n);if (t.sign) t.sign = 0;return t; &#125;//类内部调用 ↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗↖(-(●●)-)↗longer&amp; longer::get_addition(longer&amp; aa, const longer&amp; bb, bool si)&#123; auto a = aa.number.begin(), &amp;aend = aa.number.end(); auto b = bb.number.begin(), &amp;bend = bb.number.end(); bool flag = 0; aa.sign = si; do &#123; *a += (b == bend ? 0 : *b++) + flag; if (*a &gt;= MAX) *a -= MAX, flag = 1; else if (flag) flag = 0; &#125; while (++a != aend &amp;&amp; (b != bend || flag)); if (flag) aa.number.push_back(flag); return aa.get_zero();&#125;longer&amp; longer::get_subtraction(longer&amp; aa, const longer&amp; bb, bool si)&#123; auto a = aa.number.begin(), &amp;aend = aa.number.end(); auto b = bb.number.begin(), &amp;bend = bb.number.end(); bool flag = 0; aa.sign = si; do &#123; *a -= (b == bend ? 0 : *b++) + flag; if (*a &lt; 0) *a += MAX, flag = 1; else if (flag) flag = 0; &#125; while (++a != aend &amp;&amp; (b != bend || flag)); while (aa.get_ptrdiff()&gt;1 &amp;&amp; !*aa.number.rbegin()) aa.number.pop_back(); return aa.get_zero();&#125;int longer::get_comparison(const longer&amp; n)const&#123;//返回1:左值大,0相等,-1右值大 if (get_ptrdiff() &lt; n.get_ptrdiff()) return -1; if (get_ptrdiff() &gt; n.get_ptrdiff()) return 1; auto a = number.rbegin(), b = n.number.rbegin(); while (a != number.rend()) &#123; if (*a &lt; *b) return -1; if (*a &gt; *b) return 1; ++a, ++b; &#125; return 0;&#125;inline ptrdiff_t longer::get_ptrdiff()const &#123; return number.end() - number.begin(); &#125;inline longer&amp; longer::get_zero()&#123; if (get_ptrdiff() == 1 &amp;&amp; number[0] == 0 &amp;&amp; sign == 1) sign = 0; return *this;&#125;#endif]]></content>
      <categories>
        <category>算法竞赛</category>
      </categories>
      <tags>
        <tag>造轮子</tag>
        <tag>大数模板</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 第2章习题]]></title>
    <url>%2Fposts%2F10776.html</url>
    <content type="text"><![CDATA[题目：算法竞赛入门经典 2-1 水仙花数 代码： 123456#include&lt;iostream&gt;void main()&#123; for (int i = 100;i &lt; 999;++i) if ((i % 10)*(i % 10)*(i % 10) + (i % 100 / 10)*(i % 100 / 10)*(i % 100 / 10) + (i / 100)*(i / 100)*(i / 100) == i) std::cout &lt;&lt; i &lt;&lt; '\n';&#125; 题目：算法竞赛入门经典 2-2 韩信点兵 代码： 12345678910111213141516#include&lt;iostream&gt;using namespace std;void main()&#123; int a,b,c,times=0; while (cin &gt;&gt; a &gt;&gt; b &gt;&gt; c) &#123; cout &lt;&lt; "Case " &lt;&lt; ++times &lt;&lt; ": "; c &lt; 3?c += 14 : c+=7;; for (;c &lt;= 100;c += 7) if (c % 5 == b&amp;&amp;c % 3 == a) &#123; cout &lt;&lt; c &lt;&lt; '\n'; break; &#125; if (c &gt; 100) cout &lt;&lt; "No answer\n"; &#125;&#125; 题目：算法竞赛入门经典 2-3 倒三角形 代码： 12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; int n;cin &gt;&gt; n; for (int i = 0;i &lt; n;++i) &#123; for (int j = 0;j &lt; i;++j) cout &lt;&lt; ' '; for (int j = 0;j &lt; 2 * (n - i) - 1;++j) cout &lt;&lt; '*'; cout &lt;&lt; '\n'; &#125; return 0;&#125; 题目：算法竞赛入门经典 2-4 子序列的和 代码： 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;double f(int a, int b)&#123; double sum = 0; for (;a &lt;= b;++a) sum += 1.0 / a / a; return sum;&#125;int main()&#123; int n, m,times=0; cout &lt;&lt; setprecision(5)&lt;&lt;fixed; do &#123; do &#123; cin &gt;&gt; n &gt;&gt; m; if (n == 0 &amp;&amp; m == 0) return 0; &#125; while (n &gt;= m || n &lt;= 0); cout &lt;&lt; "Case " &lt;&lt; ++times &lt;&lt; ": " &lt;&lt; f(n, m) &lt;&lt; endl; &#125; while (1); return 0;&#125; 题目：算法竞赛入门经典 2-5 分数化小数 代码： 123456789101112131415161718#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; int a, b, c,CASE=0; while (1) &#123; do &#123; cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) return 0; &#125; while (a &gt; 1e6 || b &gt; 1e6 || c &gt; 100); cout &lt;&lt; "Case " &lt;&lt; ++CASE &lt;&lt; ": " &lt;&lt; fixed &lt;&lt; setprecision(c) &lt;&lt; (double)a / (double)b &lt;&lt; endl;; &#125; return 0;&#125; 题目：算法竞赛入门经典 2-6 排列 代码： 123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;int ge(int n) &#123; return n % 10; &#125;int shi(int n) &#123; return (n % 100) / 10; &#125;int bai(int n) &#123; return n / 100; &#125;int main()&#123; int n[9],i,j; for (int num = 123;num &lt;= 321;++num) &#123; n[0] = bai(num), n[1] = shi(num), n[2] = ge(num); n[3] = bai(2 * num), n[4] = shi(2 * num), n[5] = ge(2 * num); n[6] = bai(3 * num), n[7] = shi(3 * num), n[8] = ge(3 * num); for (i = 0;i &lt; 8;++i) &#123; for (j = i + 1;j &lt; 9;++j) if (n[i] == n[j]) break; if (j &lt; 9) break; &#125; if (i == 8 &amp;&amp; j == 9) cout &lt;&lt; num &lt;&lt; endl; &#125; return 0;&#125; 分析： 2-2无需一个一个地枚举，七个七个地枚举就行，因为每七个里有6个事绝壁不可能的数据。当然应该有更直接的数学方法，我不知道（小学奥数书上是不是有来着）。 2-4所说的陷阱是，6553665536刚好溢出，所以算1/n^2时，写1/n/n，而不要写1 / (n n)。 2-6因为每个数字只能使用一次，所以从123开始枚举，而又要存在3倍关系，所以以321结束枚举]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 3-12UVa11809]]></title>
    <url>%2Fposts%2F17916.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 题目：算法竞赛入门经典 3-4/UVa11809：Floating-Point Numbers 代码： 12345678910111213141516171819202122232425262728293031323334//UVa11809 - Floating-Point Numbers#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;cmath&gt;long long E[12][33], e;double M[12][33], m, re;char str[25], *ps;int main()&#123; for (int i = 0;i &lt;= 9;++i)//M for (int j = 1;j &lt;= 30;++j) &#123;//E m = 1 - pow(2, -1 - i); e = pow(2, j) - 1; re = log10(m) + log10(2)*e; E[i][j] = (long long)re; M[i][j] = pow(10, (re - E[i][j])); &#125;//打表完成，读入数据 while ((std::cin &gt;&gt; str) &amp;&amp; (ps = str) != "0e0") &#123; while (*++ps != 'e');*ps = ' '; std::istringstream s(str); s &gt;&gt; m &gt;&gt; e; for (int i = 0;i &lt;= 9;++i) &#123;//M int j; for (j = 1;j &lt;= 30;++j) &#123;//E if (E[i][j] == e &amp;&amp; (M[i][j] - m &lt; 0.0001 &amp;&amp; m - M[i][j] &lt; 0.0001)) &#123;//double达不到15位的精度，但是其实无所谓，差不离就行 std::cout &lt;&lt; i &lt;&lt; ' ' &lt;&lt; j &lt;&lt; '\n'; break; &#125; &#125; if (j &lt;= 30) break; &#125; &#125; return 0;&#125; 分析：这题对我来说有点难，而且一开始做这题时精神状态不佳，磨洋工磨了一下午也没磨出来。甚至一开始看懂了题目但看不懂题意。。然后第二天继续做，在继承了昨天磨了一下午形成的固化思维下，有点思路但是感觉写下来会很烦琐。于是认认真真去网上看大神的思路。又不敢看太多，看太多了就没有自己的思路了完全是抄了，抄完该忘记的还是忘记。 这题主要看了这位大神的博客：http://blog.csdn.net/crazysillynerd/article/details/43339157 首先他是用的打表。这个方法我知道但一直没想到去用过。而这题刚好说了“The input file contains around 300 line of input”，同时有 9 ≥ M ≥ 0 and 30 ≥ E ≥ 1，10*30刚好300，用读表法再好不过。所以这也是我第一次用读表法。。下次就记住了。 然后怎么打表，我又不会了。。真的菜。。主要就是在两个循环里如何计算M和E。看到这位大大用了log什么的看了几眼没看懂，觉得还是自己动手算比较好，于是拿出草稿纸。事实证明草稿纸果真神器一枚，理思路、演算很有帮助。 我们要做的转化是：M x 10^E=m x 2^e（这个e与2.7的那个e无关），m和e可以根据i、j求出，也就是看成常数。那么两边取log10，得lg M + E x lg 2=lg M + e，左式可算出为re，右式E为long long，M为double，且因为使用的科学记数法，1&lt;=M&lt;10（虽然题目上只说0 &lt; M &lt; 10，但这位大神还去测了，题目中给的数据都是大于1的，钻研精神max），所以0 &lt; lg M &lt; 1，所以E = re - lg M，E为re的取整，即强制转化为long long即可，然后M也可求出。。天，这方法比我之前想的不知道快到哪里去了。。。 然后就是根据输入的数据读表，没什么问题。但是注意到那大神用了istringstream。这玩意我在C++Primer上看到过，当时还想着没什么用。现在才知道其威力！当我看到大神那句： 1for(string::iterator i = in.begin(); i != in.end(); ++i) if(*i == 'e') *i = ' '; 瞬间让字符串可以直接输入到double和long long，简化了不少的代码！我做题目至今，用来用去就那几个东西，primer上看到的那些东西都没怎么用过。论活学活用的重要性。。。 于是最终。。我写出来的代码还是和那大神的还是太像了。。。跟抄作业的一样。。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 3-10UVa1587 3-11UVa1588]]></title>
    <url>%2Fposts%2F21702.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 题目：算法竞赛入门经典 3-10/UVa1587：Box 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//UVa1587 - Box#include&lt;iostream&gt;unsigned rect[6];//每个面各有一个一样的对应面,故12个边只要定义6个,其中每偶奇两个代表一个长方形的两个边长bool flag, times[3];//每个面出现的次数（出现第二次时为true）unsigned tmpx, tmpy, now;int main()&#123; while (scanf("%u%u", &amp;rect[0], &amp;rect[1]) != EOF) &#123; now = 0; flag = times[0] = times[1] = times[2] = 0; if (rect[0] &lt; rect[1]) &#123; auto t = rect[0]; rect[0] = rect[1], rect[1] = t; &#125; for (int i = 1;i &lt; 6;++i) &#123; scanf("%u%u", &amp;tmpx, &amp;tmpy); if (flag) continue; unsigned j; if (tmpx &lt; tmpy) j = tmpx, tmpx = tmpy, tmpy = j; for (j = 0;j &lt;= now;++j) &#123;//判断新输入的数据是不是之前已经输入过的某矩形的对面 if (times[j]) continue;//若当前面已经找到其对面，continue继续寻找 if (rect[2 * j] == tmpx&amp;&amp;rect[2 * j + 1] == tmpy) &#123; times[j] = 1;//找到对面 break; &#125; &#125; if (j &lt;= now) continue;//若已经找到对面 if (++now &gt; 2) &#123; flag = 1;continue; &#125;//若出现了第四组不同的面，则不能组成立方体 rect[2 * now] = tmpx, rect[2 * now + 1] = tmpy; &#125; if (!flag) &#123;//下面进一步判断是否可以组成Box unsigned t;//排序，从大到小把每个矩形排序 for (unsigned i = 0;i &lt; 2;++i) &#123; unsigned max = 2 * i; for (unsigned j = i + 1;j &lt; 3;++j) if (rect[max] &lt; rect[2 * j]) max = 2 * j; t = rect[max], rect[max] = rect[2 * i], rect[2 * i] = t; t = rect[max+1], rect[max+1] = rect[2 * i + 1], rect[2 * i + 1] = t; &#125; if (rect[1] &lt; rect[3]) t = rect[1], rect[1] = rect[3], rect[3] = t; if (rect[2] == rect[4] &amp;&amp; rect[3] &lt; rect[5]) t = rect[3], rect[3] = rect[5], rect[5] = t; if (rect[1] &lt; rect[3]) t = rect[1], rect[1] = rect[3], rect[3] = t; if (rect[0] != rect[2] || rect[1] != rect[4] || rect[3] != rect[5]) flag = 1; //for (int i = 0;i &lt; 3;++i) std::cout &lt;&lt; rect[2 * i] &lt;&lt; '\t' &lt;&lt; rect[2 * i + 1] &lt;&lt; '\n'; &#125; printf(flag ? "IMPOSSIBLE\n" : "POSSIBLE\n"); &#125; return 0;&#125; 分析：因为每个面都有其对面，所以我只定义了3个面的边长，也就是6条边。于是在输入时就可以排除好些impossible的案例。 在代码后半段的进一步判断是否可以组成长方体时，我本来是用的比较烦的方法，比较绕，虽然答案也对而且也不是很耗时间。但是在网上看到了排序法，就是把各个矩形按长宽从大到小排列，排列后很轻松地就可以做出来。于是后来我也用了排序法。（看到了这个好方法我都不好意思把我之前写的贴出来了哈哈。唉，计算机到最后还是拼数学） 比如6个矩形分别为两个5x4的，两个4x3的，两个5x3的，经排序后即为： 5 4 5 3 4 3（对应rect[0]~rect[5]） 则只需判断&quot;if (rect[0] != rect[2] || rect[1] != rect[4] || rect[3] != rect[5]) flag = 1;&quot;即可。 然后我又找到了一个大神的代码，其代码如下： 原文链接：http://blog.csdn.net/kun768/article/details/43701899 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;using namespace std;struct face&#123; int x, y;&#125;a[6];bool check()&#123; if(memcmp(a, a+1, sizeof(face)) || memcmp(a+2, a+3, sizeof(face)) || memcmp(a+4, a+5, sizeof(face))) return false; if(a[0].x!=a[2].x || a[0].y!= a[4].x || a[2].y!=a[4].y) return false; return true;&#125;int main()&#123; while(cin &gt;&gt; a[0].x &gt;&gt; a[0].y &gt;&gt; a[1].x &gt;&gt; a[1].y &gt;&gt; a[2].x &gt;&gt; a[2].y &gt;&gt; a[3].x &gt;&gt; a[3].y &gt;&gt; a[4].x &gt;&gt; a[4].y &gt;&gt; a[5].x &gt;&gt; a[5].y)&#123; for(int i = 0; i &lt; 6; ++i) if(a[i].x &lt; a[i].y) swap(a[i].x, a[i].y); sort(a, a+6, [](const face a, const face b) &#123;return a.x==b.x ? (a.y &gt; b.y) : (a.x &gt; b.x);&#125;); printf("%s\n", check() ? "POSSIBLE" : "IMPOSSIBLE"); &#125; return 0;&#125; 只需短短23行，效率也极高。真的厉害！然后我发现其实我之前只定义3个面也是没必要的，统一判断一样简洁高效。 题目：算法竞赛入门经典 3-11/UVa1588：Kickdown 代码： 12345678910111213141516171819202122232425//UVa1588 - Kickdown#include&lt;iostream&gt;#include&lt;cstring&gt;char a[103], b[103];int calculate(char *x, char *y) &#123; int lenx = strlen(x), leny = strlen(y); for (int i = 0;i &lt;= lenx;++i) &#123; const int len = (leny &lt; lenx - i ? leny : lenx - i); int j; for (j = 0;j != len;++j) if (x[i + j] + y[j] &gt;= 100) break;//'2'的ASCII为50,50+50=100 if (j == len) return (lenx &gt; leny + i ? lenx : leny + i); &#125; return 0;&#125;int main()&#123; while (std::cin &gt;&gt; a &gt;&gt; b) &#123;//scanf输入字符串有bug？ int re_a = calculate(a, b), re_b = calculate(b, a); printf("%d\n", re_a &lt; re_b ? re_a : re_b); &#125; return 0;&#125; 分析：函数从两者的第一个字符开始比较。需要执行两遍函数，两次函数调换了a、b的位置，理解为： 第一遍：a固定不动，b的第一个字符分别指向a的第1个、第2个、第3个……数字，进行比较全数列。 第二遍：b固定不动，a的第一个字符分别指向b的第1个、第2个、第3个……数字，进行比较全数列。 两遍刚好把所有情况找全。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 3-7UVa1368 3-8UVa202 3-9UVa10340]]></title>
    <url>%2Fposts%2F2851.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 都是《算法竞赛入门经典（第二版）》的题目，标题上没写（第二版） 题目：算法竞赛入门经典 3-7/UVa1368：DNA Consensus String 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041//UVa1368 - DNA Consensus String#include&lt;iostream&gt;using namespace std;#define MAX_M 52#define MAX_N 1005char DNA[MAX_M][MAX_N];int main()&#123; int T, m, n, err, num[4];//num用于存放ACGT个数 const int &amp;mm = m, &amp;nn = n;//防止自己代码书写错误 char consensus[MAX_N], ACGT[] = "ACGT";//consensus为计算结果 cin &gt;&gt; T; while (T--) &#123; err = 0; cin &gt;&gt; m &gt;&gt; n; cin.getline(DNA[51], 3);//吸收'\n' for (int i = 0;i &lt; mm;++i) cin.getline(DNA[i], MAX_N); for (int i = 0;i &lt; nn;++i) &#123; num[0] = num[1] = num[2] = num[3] = 0;//初始化或重置num for (int j = 0;j &lt; mm;++j) switch (DNA[j][i]) &#123; case 'A': ++num[0];break; case 'C': ++num[1];break; case 'G': ++num[2];break; case 'T': ++num[3];break; default:cerr &lt;&lt; "Error:1\n";exit(0); &#125; int max = 0; for (int j = 1;j &lt; 4;++j) if (num[j]&gt;num[max])max = j; consensus[i] = ACGT[max]; err += mm - num[max]; &#125; consensus[nn] = '\0'; cout &lt;&lt; consensus &lt;&lt; '\n' &lt;&lt; err &lt;&lt; '\n'; &#125; return 0;&#125; 分析：找出每个DNA序列的第i个的碱基，找到出现最多的项，即为Consensus String的第i个碱基 在算法竞赛入门经典里看到使用常量数组的方法，可以有效减少switch与if的使用，感觉很好用（虽然记得学校教材上也讲到过，但是当时没那么印象深刻）。于是这次在ACGT[]=&quot;ACGT&quot;这里用到了，真心好用呀。 题目：算法竞赛入门经典 3-8/UVa202：Repeating Decimals 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//UVa202 - Repeating Decimals#include&lt;iostream&gt;using namespace std;#define MAX 502unsigned Decimal[MAX];//存放各个小数unsigned Remainder[MAX];//存放各位小数对应的余数int main()&#123; unsigned numerator, denominator;//分子、分母 const unsigned &amp;de = denominator; int temp, digit;//由于分母可以正可以负,先输入temp至int再转为unsigned,digit记录位数(或者说是位数-1) while (cin &gt;&gt; numerator) &#123; cin &gt;&gt; temp; digit = 0; cout &lt;&lt; numerator &lt;&lt; '/' &lt;&lt; temp &lt;&lt; " = "; if (temp &lt; 0)temp = -temp, cout &lt;&lt; '-'; denominator = (unsigned)temp; cout &lt;&lt; numerator / de &lt;&lt; '.'; Decimal[0] = (numerator % de * 10) / de; Remainder[0] = (numerator % de * 10) % de; while (digit &lt; MAX) &#123; unsigned di, t = Remainder[digit++] * 10; Decimal[digit] = t / de; Remainder[digit] = t % de; for (di = 0;di &lt; digit;++di) if (Decimal[di] == Decimal[digit] &amp;&amp; Remainder[di] == Remainder[digit]) break; if (di &lt; digit) &#123; for (int i = 0;i &lt; di;++i) cout &lt;&lt; Decimal[i]; cout &lt;&lt; '('; if (digit - di &lt;= 50) for (int i = di;i &lt; digit;++i) cout &lt;&lt; Decimal[i]; else &#123; for (int i = 0;i &lt; 50;++i) cout &lt;&lt; Decimal[di+i]; cout &lt;&lt; "..."; &#125; cout &lt;&lt; ")\n\t" &lt;&lt; digit - di &lt;&lt; " = number of digits in repeating cycle\n\n"; break; &#125; &#125; if (digit == MAX) &#123; cerr &lt;&lt; "Error:1\n";exit(0); &#125; &#125; return 0;&#125; 分析：算出下一位小数b并与之前每一位小数比较，如果找到一位小数a，a的小数值与对应的余数均与b的小数与余数相等，则这两个数a----b之间的就是循环部分。想不出好办法，不是所有小数都是像1/3一样从第一位开始洗脑循环。 题目：算法竞赛入门经典 3-9/UVa10340：All in All 代码： 123456789101112131415161718192021//UVa10340 - All in All#include&lt;iostream&gt;#define M 101000char s[M], t[M], *ps, *pt;//s短t长int main()&#123; while (std::cin&gt;&gt;s&gt;&gt;t) &#123;//为什么scanf按了crtl^z还是不停止，还得再按一下回车才能结束程序。。。//于是使用scanf导致提交总是超时，因为程序还在等着输入//而cin只要按一下crtl^z再回车，马上就结束了。不懂。。//好吧，于是虽然试图尽量少用cin cout，但是c的东西还是不大会用，不熟练 ps = s, pt = t; while (*ps != '\0') &#123; while (*pt != *ps&amp;&amp;*pt != '\0')++pt; if (*pt == '\0') break; ++ps,++pt; &#125; printf(*ps == '\0' ? "Yes\n" : "No\n"); &#125; return 0;&#125; 分析：不难（上面用cin下面用printf是不是有点违和。。）]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯方块]]></title>
    <url>%2Fposts%2F11121.html</url>
    <content type="text"><![CDATA[和贪吃蛇在同一时期写的，私以为比我在网上找到的那些其他的控制台版的俄罗斯方块更精致! 成品地址：链接: http://pan.baidu.com/s/1jIo9Ovs 密码: 7k8j 当时初学编程，废寝忘食地写着玩的，现在看看优化余地很大。 与之前的贪吃蛇一样R键刷新界面显示，空格暂停，“暂停”两字写在游戏右侧。这次没做花哨的开始界面，也是Visual studio2015写的，一样会生成一个保存分数的文件 上：翻转；下：瞬间下落；左右：就是左右 ESC：退出游戏（退出游戏时做了一个略花哨的动画） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461//俄罗斯方块#include&lt;Windows.h&gt;#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;ctime&gt;using namespace std;/**********************************///根据小键盘,将8、2、4、6定义为上下左右,5为默认,0为退出游戏#define Sb 16//Screen的宽度#define Sh 21//Screen的高度bool Screen[Sh + 3][Sb + 2] = &#123; 0 &#125;;unsigned Speed_mulriple_limit = 2;unsigned Speed_mulriple = 8;unsigned SleepTime = 100;unsigned Score = 0;unsigned Max=0;struct Tetris &#123; bool shape[4][4]; unsigned type; unsigned x, y;&#125;Tnow;/**********************************/void Start();void Game();void End();void Interface();void ScreenPrint();void ScreenClear();void NextShow(unsigned);void Pause();void TBuild(Tetris&amp;, unsigned);void TRotate(Tetris&amp;);void TMove(Tetris&amp;, int);void TDown(Tetris&amp;);void TCopy(Tetris&amp;, const Tetris&amp;);void TShow(const Tetris&amp;);void TClear(const Tetris&amp;);int Judge_down(const Tetris&amp;);int Judge_key();int Judge_eliminate(const Tetris&amp;);int Judge_gameover(const Tetris&amp;);void Pos(unsigned, unsigned);void PosScreen(unsigned, unsigned);void Swap(bool&amp;, bool&amp;);/**********************************/void Start() &#123; system("mode con cols=80 lines=25"); const CONSOLE_CURSOR_INFO cursor&#123; (DWORD)100,FALSE &#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor); srand((unsigned)time(0)); ifstream i("tetris_data.dat", ios_base::binary); if (!i) i.close(); else &#123; unsigned s; i &gt;&gt; s; Max = s; i.close(); &#125; for (int i = 0;i &lt; Sb + 2;++i)Screen[Sh + 2][i] = Screen[Sh + 1][i] = 1; for (int i = 0;i &lt; Sh + 2;++i)Screen[i][0] = Screen[i][Sb + 1] = 1; Pos(12, 16);cout &lt;&lt; "要开始游戏,请先关闭输入法,再";system("pause");system("cls"); Interface();&#125;void Game() &#123; unsigned type_now = rand() % 7; unsigned type_next = rand() % 7; TBuild(Tnow, type_now); NextShow(type_next); Tetris Tp;//记录前面一步以方便删除轨迹 TCopy(Tp, Tnow); int count = 1; int speed_count = 1; while (++count) &#123; if (Judge_down(Tnow)) &#123; Tp.type = 233; ScreenPrint(); if (int lines=Judge_eliminate(Tnow)) &#123; Score += 15*lines-5; if (Score &gt; Max)Max = Score; ++speed_count; speed_count %= 6; if (!speed_count&amp;&amp;Speed_mulriple&gt;Speed_mulriple_limit)Speed_mulriple -= 1; Pos(14, 56);cout &lt;&lt; Score; Pos(15, 56);cout &lt;&lt; SleepTime*Speed_mulriple &lt;&lt; 's'; Pos(16, 58);cout &lt;&lt; Max; ScreenClear(); ScreenPrint(); Sleep(10); &#125; type_now = type_next; type_next = rand() % 7; TBuild(Tnow, type_now); Judge_gameover(Tnow); NextShow(type_next); &#125; switch (Judge_key()) &#123; case 8:TRotate(Tnow);break; case 4:TMove(Tnow, 4);break; case 6:TMove(Tnow, 6);break; case 2:TDown(Tnow);break; case 0:PosScreen(10, 4);cout &lt;&lt; "Escape from Tetris!";End(); &#125; TClear(Tp); TShow(Tnow); TCopy(Tp, Tnow); if (!(count %= Speed_mulriple)) &#123; count = 1;++Tnow.x; &#125; Sleep(SleepTime); &#125;&#125;void End() &#123; ofstream o("tetris_data.dat", ios_base::binary); if (!o) o.close(); else &#123; o &lt;&lt; Max; o.close(); &#125; PosScreen(1, 1); int num = 0; int times = 0; int sl = 3; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 119); while (num &lt; 336) &#123; int i, j; PosScreen(times + 1, times + 1); for (i = times + 1;i &lt; Sb - times;++i) &#123; cout &lt;&lt; "■"; ++num; Sleep(sl); &#125; for (j = times + 1;j &lt; Sh - times;++j) &#123; PosScreen(j, i); cout &lt;&lt; "■"; ++num; Sleep(sl); &#125; for (;i &gt; times + 1;--i) &#123; PosScreen(j, i); cout &lt;&lt; "■"; ++num; Sleep(sl); &#125; for (;j &gt; times + 1;--j) &#123; PosScreen(j, i); cout &lt;&lt; "■"; ++num; Sleep(sl); &#125; ++times; &#125; exit(0);&#125;void Interface() &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 8); Pos(2, 3);cout &lt;&lt; "■■■■■■■■■■■■■■■■■■\n";//18x for (int i = 3;i &lt; 24;++i)cout &lt;&lt; " ■\n"; cout &lt;&lt; " ■■■■■■■■■■■■■■■■■■\n"; for (int i = 3;i &lt; 24;++i) &#123; Pos(i, 37); cout &lt;&lt; "■"; if (i &lt;= 8 || i &gt;= 12) &#123; Pos(i, 47); cout &lt;&lt; "■"; Pos(i, 69); cout &lt;&lt; "■"; &#125; &#125; Pos(2, 47); cout &lt;&lt; "■■■■■■■■■■■■";//12x Pos(8, 47); cout &lt;&lt; "■■■■■■■■■■■■"; Pos(12, 47); cout &lt;&lt; "■■■■■■■■■■■■"; Pos(24, 47); cout &lt;&lt; "■■■■■■■■■■■■"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(9, 53);cout &lt;&lt; "下一个 方块"; Pos(14, 51);cout &lt;&lt; "得分:" &lt;&lt; Score; Pos(15, 51);cout &lt;&lt; "速度:" &lt;&lt; SleepTime*Speed_mulriple &lt;&lt; 's'; Pos(16, 51);cout &lt;&lt; "最高分:" &lt;&lt; Max; Pos(17, 51);cout &lt;&lt; "按R键图像复位"; Pos(18, 54);cout &lt;&lt; "用于输入法导"; Pos(19, 54);cout &lt;&lt; "致的显示错误"; Pos(20, 51);cout &lt;&lt; "上下左右操控"; Pos(21, 51);cout &lt;&lt; "按空格键暂停"; Pos(22, 51);cout &lt;&lt; "按ESC结束游戏";&#125;void ScreenPrint() &#123; for (int i = 1;i &lt;= Sh;++i) &#123; for (int j = 1;j &lt;= Sb;++j) &#123; if (Screen[i][j]) &#123; PosScreen(i, j); cout &lt;&lt; "■"; &#125; &#125; &#125;&#125;void ScreenClear() &#123; for (int i = 1;i &lt;= Sh;++i) for (int j = 1;j &lt;= Sb;++j) &#123; PosScreen(i, j);cout &lt;&lt; " "; &#125;&#125;void NextShow(unsigned t) &#123; Pos(3, 49);cout &lt;&lt; " "; Pos(4, 49);cout &lt;&lt; " "; Pos(5, 49);cout &lt;&lt; " "; Pos(6, 49);cout &lt;&lt; " "; Pos(7, 49);cout &lt;&lt; " "; if (t == 0) &#123; Pos(5, 55);cout &lt;&lt; "■■■■"; &#125; else if (t == 1) &#123; Pos(4, 57);cout &lt;&lt; "■■";Pos(5, 57);cout &lt;&lt; "■■"; &#125; else if (t == 2) &#123; Pos(4, 59);cout &lt;&lt; "■";Pos(5, 55);cout &lt;&lt; "■■■"; &#125; else if (t == 3) &#123; Pos(4, 57);cout &lt;&lt; "■";Pos(5, 55);cout &lt;&lt; "■■■"; &#125; else if (t == 4) &#123; Pos(4, 55);cout &lt;&lt; "■";Pos(5, 55);cout &lt;&lt; "■■■"; &#125; else if (t == 5) &#123; Pos(4, 57);cout &lt;&lt; "■■";Pos(5, 55);cout &lt;&lt; "■■"; &#125; else &#123; Pos(4, 55);cout &lt;&lt; "■■";Pos(5, 57);cout &lt;&lt; "■■"; &#125;&#125;void Pause() &#123; Pos(11, 55);cout &lt;&lt; "暂 停"; do &#123; Sleep(200); &#125; while (!GetAsyncKeyState(VK_SPACE)); Pos(11, 55);cout &lt;&lt; " ";&#125;void TBuild(Tetris&amp; t, unsigned sh) &#123; t.x = 0; t.type = sh; switch (sh) &#123; case 0: &#123; t.shape[0][0] = 0;t.shape[0][1] = 0;t.shape[0][2] = 0;t.shape[0][3] = 0;// t.shape[1][0] = 1;t.shape[1][1] = 1;t.shape[1][2] = 1;t.shape[1][3] = 1;//■■■■ t.shape[2][0] = 0;t.shape[2][1] = 0;t.shape[2][2] = 0;t.shape[2][3] = 0;// t.shape[3][0] = 0;t.shape[3][1] = 0;t.shape[3][2] = 0;t.shape[3][3] = 0;//青色 t.y = 7; break; &#125; case 1: &#123; t.shape[0][0] = 1;t.shape[0][1] = 1;t.shape[0][2] = 0;t.shape[0][3] = 0;//■■ t.shape[1][0] = 1;t.shape[1][1] = 1;t.shape[1][2] = 0;t.shape[1][3] = 0;//■■ t.shape[2][0] = 0;t.shape[2][1] = 0;t.shape[2][2] = 0;t.shape[2][3] = 0;// t.shape[3][0] = 0;t.shape[3][1] = 0;t.shape[3][2] = 0;t.shape[3][3] = 0;//蓝 t.y = 8; break; &#125; case 2: &#123; t.shape[0][0] = 0;t.shape[0][1] = 0;t.shape[0][2] = 1;t.shape[0][3] = 0;// ■ t.shape[1][0] = 1;t.shape[1][1] = 1;t.shape[1][2] = 1;t.shape[1][3] = 0;//■■■ t.shape[2][0] = 0;t.shape[2][1] = 0;t.shape[2][2] = 0;t.shape[2][3] = 0;// t.shape[3][0] = 0;t.shape[3][1] = 0;t.shape[3][2] = 0;t.shape[3][3] = 0;//紫 t.y = 7; break; &#125; case 3: &#123; t.shape[0][0] = 0;t.shape[0][1] = 1;t.shape[0][2] = 0;t.shape[0][3] = 0;// ■ t.shape[1][0] = 1;t.shape[1][1] = 1;t.shape[1][2] = 1;t.shape[1][3] = 0;//■■■ t.shape[2][0] = 0;t.shape[2][1] = 0;t.shape[2][2] = 0;t.shape[2][3] = 0;// t.shape[3][0] = 0;t.shape[3][1] = 0;t.shape[3][2] = 0;t.shape[3][3] = 0;//绿 t.y = 7; break; &#125; case 4: &#123; t.shape[0][0] = 1;t.shape[0][1] = 0;t.shape[0][2] = 0;t.shape[0][3] = 0;//■ t.shape[1][0] = 1;t.shape[1][1] = 1;t.shape[1][2] = 1;t.shape[1][3] = 0;//■■■ t.shape[2][0] = 0;t.shape[2][1] = 0;t.shape[2][2] = 0;t.shape[2][3] = 0;// t.shape[3][0] = 0;t.shape[3][1] = 0;t.shape[3][2] = 0;t.shape[3][3] = 0;//红 t.y = 7; break; &#125; case 5: &#123; t.shape[0][0] = 0;t.shape[0][1] = 1;t.shape[0][2] = 1;t.shape[0][3] = 0;// ■■ t.shape[1][0] = 1;t.shape[1][1] = 1;t.shape[1][2] = 0;t.shape[1][3] = 0;//■■ t.shape[2][0] = 0;t.shape[2][1] = 0;t.shape[2][2] = 0;t.shape[2][3] = 0;// t.shape[3][0] = 0;t.shape[3][1] = 0;t.shape[3][2] = 0;t.shape[3][3] = 0;//橙色 t.y = 7; break; &#125; case 6: &#123; t.shape[0][0] = 1;t.shape[0][1] = 1;t.shape[0][2] = 0;t.shape[0][3] = 0;//■■ t.shape[1][0] = 0;t.shape[1][1] = 1;t.shape[1][2] = 1;t.shape[1][3] = 0;// ■■ t.shape[2][0] = 0;t.shape[2][1] = 0;t.shape[2][2] = 0;t.shape[2][3] = 0;// t.shape[3][0] = 0;t.shape[3][1] = 0;t.shape[3][2] = 0;t.shape[3][3] = 0;//黄色 t.y = 7; break; &#125; default: &#123;Pos(1, 1);cerr &lt;&lt; "Error 2:方块种类出错!";exit(1);&#125; &#125;&#125;void TRotate(Tetris&amp; t) &#123; if (t.type == 0) &#123; Swap(t.shape[0][1], t.shape[1][0]); Swap(t.shape[2][1], t.shape[1][2]); Swap(t.shape[3][1], t.shape[1][3]); for (int i = 0;i &lt; 4;++i) for (int j = 0;j &lt; 4;++j) if (t.shape[i][j]) if (i + t.x &gt; Sh || j + t.y&gt;Sb || Screen[t.x + i][t.y + j]) &#123; Swap(t.shape[0][1], t.shape[1][0]); Swap(t.shape[2][1], t.shape[1][2]); Swap(t.shape[3][1], t.shape[1][3]); &#125; &#125; else if (t.type == 1); else &#123; bool tmp[3][3]; for (int i = 0;i &lt; 3;++i) for (int j = 0;j &lt; 3;++j) tmp[i][j] = t.shape[i][j]; t.shape[0][0] = tmp[2][0]; t.shape[0][1] = tmp[1][0]; t.shape[0][2] = tmp[0][0]; t.shape[1][0] = tmp[2][1]; t.shape[1][2] = tmp[0][1]; t.shape[2][0] = tmp[2][2]; t.shape[2][1] = tmp[1][2]; t.shape[2][2] = tmp[0][2]; for (int i = 0;i &lt; 3;++i) for (int j = 0;j &lt; 3;++j) if (t.shape[i][j]) if (i + t.x &gt; Sh || j + t.y&gt;Sb || Screen[t.x + i][t.y + j]) &#123; for (int i = 0;i &lt; 3;++i) for (int j = 0;j &lt; 3;++j) t.shape[i][j] = tmp[i][j]; &#125; TShow(t); &#125;&#125;void TMove(Tetris&amp; t, int d) &#123; d -= 5; for (int i = 0;i &lt; 4;++i) for (int j = 0;j &lt; 4;++j) if (t.shape[i][j] &amp;&amp; Screen[t.x + i][t.y + j + d]) return; t.y += d;&#125;void TDown(Tetris&amp; t) &#123; TClear(t); int l = 0, i = 0, j = 0; while (1) &#123; for (i = 0;i &lt; 4;++i) for (j = 0;j &lt; 4;++j) if (t.shape[i][j] &amp;&amp; Screen[t.x + i + 1][t.y + j]) &#123; TShow(t); return; &#125; ++t.x; &#125; Sleep(20);&#125;void TCopy(Tetris&amp; tt, const Tetris&amp; t) &#123; tt.type = t.type; tt.x = t.x, tt.y = t.y; for (int i = 0;i &lt; 4;++i) for (int j = 0;j &lt; 4;++j) tt.shape[i][j] = t.shape[i][j];&#125;void TShow(const Tetris&amp; t) &#123; for (int i = 0;i &lt; 4;++i) for (int j = 0;j &lt; 4;++j) if (t.shape[i][j] &amp;&amp; (t.x + i != 0)) &#123; PosScreen(t.x + i, t.y + j); cout &lt;&lt; "■"; &#125;&#125;void TClear(const Tetris&amp; t) &#123; if (t.type == 233)return; for (int i = 0;i &lt; 4;++i) for (int j = 0;j &lt; 4;++j) if (t.shape[i][j] &amp;&amp; (t.x + i != 0)) &#123; PosScreen(t.x + i, t.y + j); cout &lt;&lt; " "; &#125;&#125;int Judge_down(const Tetris&amp; t) &#123; for (int i = 0;i &lt; 4;++i) for (int j = 0;j &lt; 4;++j) if (t.shape[i][j] &amp;&amp; Screen[t.x + i][t.y + j]) &#123; for (int i = 0;i &lt; 4;++i) for (int j = 0;j &lt; 4;++j) if (t.shape[i][j]) Screen[t.x + i - 1][t.y + j] = 1; return 1; &#125; return 0;&#125;int Judge_key() &#123; unsigned d = 5; if (GetAsyncKeyState(VK_UP)) d = 8; else if (GetAsyncKeyState(VK_DOWN)) d = 2; else if (GetAsyncKeyState(VK_LEFT)) d = 4; else if (GetAsyncKeyState(VK_RIGHT)) d = 6; else if (GetAsyncKeyState(VK_SPACE)) Pause(); else if (GetAsyncKeyState(VK_ESCAPE)) d = 0; else if (GetAsyncKeyState(0x52)) &#123; system("cls"); Interface(); ScreenPrint(); Pos(4, 49);cout &lt;&lt; "R键图像复位导致下一"; Pos(5, 49);cout &lt;&lt; "个方块的显示失效BUG"; Pos(6, 49);cout &lt;&lt; "不高兴修复了"; &#125; return d;&#125;int Judge_eliminate(const Tetris&amp; t) &#123; int judge = 0; for (int i = 0;i &lt; 4;++i) &#123; for (int j = 0;j &lt; 4;++j) if (t.shape[i][j]) &#123; int k; unsigned xx = t.x - 1; for (k = 1;k &lt;= Sb&amp;&amp;Screen[xx + i][k];++k); if (k &gt; Sb) &#123; ++judge; int blank = 0; if (xx == 1) &#123; for (int l = 1;l &lt;= Sb;++l) Screen[1][l] = 0; break; &#125; while (blank != Sb) &#123; blank = 0; for (int l = 1;l &lt;= Sb;++l) &#123; Screen[xx + i][l] = Screen[xx + i - 1][l]; if (!Screen[xx + i - 1][l])++blank; &#125; --xx; &#125; &#125; break; &#125; &#125; return judge;&#125;int Judge_gameover(const Tetris&amp; t) &#123; for (int i = 0;i &lt; 4;++i) if (t.shape[1][i] &amp;&amp; Screen[1][t.y + i]) &#123; PosScreen(10, 6);cout &lt;&lt; "Game Over!"; End(); &#125; return 0;&#125;void Pos(unsigned x, unsigned y) &#123; COORD p; try &#123; if (x &lt; 1 || y &lt; 1) throw 1; &#125;//测试代码，记得删除 catch (int) &#123; Pos(1, 1);cerr &lt;&lt; "Error 1:坐标出错!";exit(1); &#125;//测试代码，记得删除 p.X = y - 1;p.Y = x - 1; SetConsoleCursorPosition(GetStdHandle(STD_OUTPUT_HANDLE), p);&#125;void PosScreen(unsigned x, unsigned y)&#123; Pos(x + 2, 2 * y + 3);&#125;void Swap(bool&amp; a, bool&amp; b) &#123; bool t = a; a = b;b = t;&#125;int main()&#123; Start(); Game(); Pos(11, 50); return 0;&#125; 截图： img]]></content>
      <tags>
        <tag>造轮子</tag>
        <tag>俄罗斯方块</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪吃蛇]]></title>
    <url>%2Fposts%2F17402.html</url>
    <content type="text"><![CDATA[很久以前自己写着玩的，已经是上个学期的事情了，优化可能不是很好。但至少运行着不卡。。 用的Visual Studio2015，代码复制到别的编译器可能出问题。 成品地址：链接: http://pan.baidu.com/s/1nvKrL6T 密码: 57m5 实现的功能：蛇能跑能转弯能吃豆子（废话！）；按空格暂停，所以进游戏时如果发现蛇动不了，那就是你按了空格，再按一下就好；同时有三种豆子，白色的就是普通的豆子，红色的加速效果，蓝色的减速效果。不能穿墙；还有吃到豆子会有系统警告声，不要被吓到，因为这是我让游戏发出声音的最简单的办法了； 因为是当时学编程以来第一次做个成品，于是做了个极其花哨的开始界面，代码里很多都是花在界面上了，其实都是没用的代码 如果最大化窗口，会花屏，按一下R键可以稍微恢复一点界面；游戏会生成一个文件，用于储存最高分，当然完全没有加密什么的，打开就能看到你的所有成绩，你要篡改成99999也是没问题的。 还有完之前关掉输入法，不然界面显示会有问题，界面出问题了按R键刷新 还有，游戏的对话框按钮鼠标不支持，用左右或上下选择，enter确认 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454//贪吃蛇//全屏下一共横里236格，竖里55格//本次横里80格(或者说是40格)，竖里29格#include&lt;Windows.h&gt;#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;ctime&gt;#include&lt;stdlib.h&gt;using namespace std;//-----------------------struct Xsnake &#123; unsigned x, y; Xsnake* next;&#125;*head;struct Xfood &#123; unsigned x, y, colour;//colour:0white 1red 2blue&#125;Food;unsigned Score = 0;unsigned Max = 0;unsigned Length = 5;unsigned SleepTime = 150;unsigned Direction = 8;unsigned SnakeColour = 0;int GameStatus = 0;//0:正常,1:ESC关闭游戏,2:撞墙,3:撞尾巴 //-----------------------int main();void XWelcome();void Xstart();void Xinterface();void Xgame();void Xend();void Pos(unsigned, unsigned);void SnakeShow(Xsnake*);void GetSnake(Xsnake*);Xsnake* SnakeAdd(Xsnake*, unsigned, unsigned);Xsnake* SnakeMove(Xsnake*, unsigned);Xsnake* SnakePush_back(Xsnake*, const unsigned, const unsigned);inline void SnakeTail(Xsnake*, unsigned&amp;, unsigned&amp;);inline void SnakeClear(unsigned, unsigned);int SnakeBite(Xsnake*);void SnakeKey(unsigned&amp;);void SnakeDel(Xsnake*);void FoodCreate(Xsnake*, Xfood&amp;);void FoodShow(const Xfood&amp;);//-----------------------void Pos(unsigned x, unsigned y) &#123; COORD p; p.X = y;p.Y = x; HANDLE h = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(h, p);&#125;void XWelcome() &#123; Pos(5, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(5, 50);cout &lt;&lt; " ／￣￣￣Y￣￣。＼ "; Pos(6, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(6, 50);cout &lt;&lt; " l l "; Pos(7, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(7, 50);cout &lt;&lt; "ヽ,,,,,／ ￣￣￣ ヽ "; Pos(8, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(8, 50);cout &lt;&lt; " |::::: l "; Pos(9, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(9, 50);cout &lt;&lt; " |::: __ __ | "; Pos(10, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(10, 50);cout &lt;&lt; " （6 ＼● ● 丨 "; Pos(11, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(11, 50);cout &lt;&lt; " ! )..( l "; Pos(12, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(12, 50);cout &lt;&lt; " ヽ (三) l "; Pos(13, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(13, 50);cout &lt;&lt; " ／＼ 二 ノ "; Pos(14, 50); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); cout &lt;&lt; " "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(14, 50);cout &lt;&lt; " / ⌒ヽ. ‘ー—一＼ "; Sleep(80); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(12, 71);cout &lt;&lt; ".";Sleep(120); Pos(12, 71);cout &lt;&lt; " 。";Sleep(120); Pos(12, 71);cout &lt;&lt; " o";Sleep(120); Pos(12, 71);cout &lt;&lt; " o";Sleep(120); Pos(12, 71);cout &lt;&lt; " 0";Sleep(120); Pos(12, 76);cout &lt;&lt; " "; Pos(11, 84);cout &lt;&lt; "o";Sleep(120); Pos(11, 84);cout &lt;&lt; " "; Pos(10, 85);cout &lt;&lt; ".";Sleep(120); Pos(10, 85);cout &lt;&lt; " ";&#125;void Xstart() &#123; XWelcome(); const CONSOLE_CURSOR_INFO cursor&#123; (DWORD)100,FALSE &#125;; SetConsoleCursorInfo(GetStdHandle(STD_OUTPUT_HANDLE), &amp;cursor); head = new Xsnake; head-&gt;x = 11;head-&gt;y = 38; head-&gt;next = nullptr; head = SnakeAdd(head, 10, 38);head = SnakeAdd(head, 9, 38); head = SnakeAdd(head, 8, 38);head = SnakeAdd(head, 7, 38); ifstream i("snake_data.dat"); if (!i) i.close(); else &#123; unsigned s; while (i &gt;&gt; s) if (s &gt; Max)Max = s; i.close(); &#125; Pos(16, 48);cout &lt;&lt; "载入完毕，";system("pause"); Pos(16, 48);cout &lt;&lt; " 贪吃蛇 by蟹脑板 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 160); Pos(18, 50);cout &lt;&lt; " 开 始 游 戏 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(20, 50);cout &lt;&lt; " 退 出 游 戏 "; int YN = 8; while (!GetAsyncKeyState(VK_RETURN)) &#123; if (GetAsyncKeyState(VK_UP)) &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 160); Pos(18, 50);cout &lt;&lt; " 开 始 游 戏 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(20, 50);cout &lt;&lt; " 退 出 游 戏 "; YN = 8; &#125; if (GetAsyncKeyState(VK_DOWN)) &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(18, 50);cout &lt;&lt; " 开 始 游 戏 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 160); Pos(20, 50);cout &lt;&lt; " 退 出 游 戏 "; YN = 4; &#125; &#125; if (YN == 4) exit(0); system("cls");&#125;void Xinterface() &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 136); Pos(0, 0); cout &lt;&lt; "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\n";//80x for (unsigned i = 1;i &lt;= 28;++i)cout &lt;&lt; "■\n"; for (unsigned i = 1;i &lt;= 28;++i) &#123; Pos(i, 78); cout &lt;&lt; "■"; &#125; cout &lt;&lt; endl; cout &lt;&lt; "■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(2, 88);cout &lt;&lt; "得分:" &lt;&lt; Score; Pos(3, 88);cout &lt;&lt; "长度:" &lt;&lt; Length; Pos(4, 88);cout &lt;&lt; "速度:" &lt;&lt; 300 - SleepTime; Pos(5, 88);cout &lt;&lt; "历史最高成绩:" &lt;&lt; Max;&#125;void Xgame() &#123; Xinterface(); unsigned tail_x = 0, tail_y = 0; FoodCreate(head, Food); FoodShow(Food); while (Length &lt; 1026) &#123; if (Food.x == head-&gt;x &amp;&amp; Food.y == head-&gt;y) &#123; if (SnakeColour == 1)SleepTime += 40; else if (SnakeColour == 2)SleepTime -= 40; if (Food.colour == 1) &#123; SleepTime -= 40; Score += 8; &#125; else if (Food.colour == 2) &#123; SleepTime += 40; Score -= 6; &#125; SnakeColour = Food.colour; Score += 10; ++Length; head = SnakePush_back(head, tail_x, tail_y); FoodCreate(head, Food); FoodShow(Food); if (SleepTime &gt; 80) SleepTime -= 3; Pos(2, 93);cout &lt;&lt; Score; Pos(3, 93);cout &lt;&lt; Length; Pos(4, 93);cout &lt;&lt; 300 - SleepTime; Pos(5, 101);cout &lt;&lt; Max; char bel = 7;cout &lt;&lt; bel; &#125; else SnakeClear(tail_x, tail_y); SnakeTail(head, tail_x, tail_y); SnakeShow(head); Sleep(SleepTime); SnakeKey(Direction); if (Direction == 0) &#123; GameStatus = 1; break; &#125; head = SnakeMove(head, Direction); if (head-&gt;x == 0 || head-&gt;x == 29 || head-&gt;y == 0 || head-&gt;y == 78) &#123; GameStatus = 2; break; &#125; if (SnakeBite(head)) &#123; GameStatus = 3; break; &#125; &#125;&#125;void Xend() &#123; ofstream o("snake_data.dat", ios_base::app); if (!o) o.close(); else &#123; o &lt;&lt; Score &lt;&lt; endl; o.close(); &#125; switch (GameStatus) &#123; case 1: &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 224); Pos(10, 17);cout &lt;&lt; " 提示 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 14); Pos(11, 17);cout &lt;&lt; "▏ ▕"; Pos(12, 17);cout &lt;&lt; "▏ ▕"; Pos(13, 17);cout &lt;&lt; "▏▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▕\n"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(12, 19);cout &lt;&lt; "即将退出,"; break; &#125; case 2: &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 207); Pos(10, 17);cout &lt;&lt; " 失败 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12); Pos(11, 17);cout &lt;&lt; "▏ ▕"; Pos(12, 17);cout &lt;&lt; "▏ ▕"; Pos(13, 17);cout &lt;&lt; "▏▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▕\n"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(12, 19);cout &lt;&lt; "您撞墙了,"; break; &#125; case 3: &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 223); Pos(10, 17);cout &lt;&lt; " 失败 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 13); Pos(11, 17);cout &lt;&lt; "▏ ▕"; Pos(12, 17);cout &lt;&lt; "▏ ▕"; Pos(13, 17);cout &lt;&lt; "▏▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▕\n"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(12, 19);cout &lt;&lt; "撞到自己,"; break; &#125; default: &#123; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 175); Pos(10, 17);cout &lt;&lt; " 恭喜 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 10); Pos(11, 17);cout &lt;&lt; "▏ ▕"; Pos(12, 17);cout &lt;&lt; "▏ ▕"; Pos(13, 17);cout &lt;&lt; "▏▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▕\n"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(12, 19);cout &lt;&lt; "恭喜通关,"; break; &#125; &#125; Pos(12, 28);system("pause"); Pos(27, 88);SnakeDel(head); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 191); Pos(10, 17);cout &lt;&lt; " 提示 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 11); Pos(11, 17);cout &lt;&lt; "▏ ▕"; Pos(12, 17);cout &lt;&lt; "▏ ▕"; Pos(13, 17);cout &lt;&lt; "▏ ▕"; Pos(14, 17);cout &lt;&lt; "▏ ▕"; Pos(15, 17);cout &lt;&lt; "▏▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▕\n"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(12, 19);cout &lt;&lt; "是否再玩一局？"; Pos(14, 24);cout &lt;&lt; " 是 "; Pos(14, 46);cout &lt;&lt; " 否 "; int YN = 6; while (!GetAsyncKeyState(VK_RETURN)) &#123; if (GetAsyncKeyState(VK_LEFT)) &#123; YN = 4; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 191); Pos(14, 24);cout &lt;&lt; " 是 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(14, 46);cout &lt;&lt; " 否 "; &#125; if (GetAsyncKeyState(VK_RIGHT)) &#123; YN = 6; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); Pos(14, 24);cout &lt;&lt; " 是 "; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 191); Pos(14, 46);cout &lt;&lt; " 否 "; &#125; &#125; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15); if (YN == 4) &#123; Score = 0; Max = 0; Length = 5; SleepTime = 150; Direction = 8; SnakeColour = 0; main(); &#125; else Pos(29, 88);&#125;void FoodCreate(Xsnake* s, Xfood&amp; f) &#123; srand((unsigned)time(0)); do &#123; f.y = 2 * (rand() % 38 + 1); f.x = rand() % 28 + 1; while (s) &#123; if (s-&gt;x == f.x&amp;&amp;s-&gt;y == f.y) break; s = s-&gt;next; &#125; &#125; while (s); f.colour = rand() % 8; if (f.colour &gt; 2) f.colour = 0;&#125;void FoodShow(const Xfood&amp; f) &#123; Pos(f.x, f.y); if (f.colour == 1)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12); else if (f.colour == 2)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 9); cout &lt;&lt; "●"; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);&#125;Xsnake* SnakeAdd(Xsnake* s, unsigned xx, unsigned yy) &#123; Xsnake* n = new Xsnake; n-&gt;x = xx;n-&gt;y = yy; n-&gt;next = s; return n;&#125;Xsnake* SnakeMove(Xsnake* s, unsigned direction) &#123; Xsnake* h = s; Xsnake* n = s; while (s-&gt;next) &#123; n = s; s = s-&gt;next; &#125; s-&gt;next = h; n-&gt;next = nullptr; switch (direction) &#123; case 4: s-&gt;y = (s-&gt;next)-&gt;y - 2, s-&gt;x = (s-&gt;next)-&gt;x;break; case 6: s-&gt;y = (s-&gt;next)-&gt;y + 2, s-&gt;x = (s-&gt;next)-&gt;x;break; case 8: s-&gt;x = (s-&gt;next)-&gt;x - 1, s-&gt;y = (s-&gt;next)-&gt;y;break; case 2: s-&gt;x = (s-&gt;next)-&gt;x + 1, s-&gt;y = (s-&gt;next)-&gt;y;break; default: exit(1); &#125; return s;&#125;int SnakeBite(Xsnake* s) &#123; unsigned xx = s-&gt;x, yy = s-&gt;y; while (s-&gt;next) &#123; s = s-&gt;next; if (s-&gt;x == xx&amp;&amp;s-&gt;y == yy) return 1; &#125; return 0;&#125;Xsnake* SnakePush_back(Xsnake* s, const unsigned xx, const unsigned yy) &#123; Xsnake* ss = s; while (s-&gt;next) s = s-&gt;next; Xsnake* n = new Xsnake; n-&gt;x = xx, n-&gt;y = yy; n-&gt;next = nullptr; s-&gt;next = n; return ss;&#125;inline void SnakeTail(Xsnake* s, unsigned&amp; xx, unsigned&amp; yy) &#123; while (s-&gt;next)s = s-&gt;next; xx = s-&gt;x;yy = s-&gt;y;&#125;inline void SnakeClear(unsigned xx, unsigned yy) &#123; if (xx&amp;&amp; yy) &#123; Pos(xx, yy);cout &lt;&lt; " "; &#125;&#125;void SnakeDel(Xsnake* s) &#123; Xsnake* n; int i = 0; while (s) &#123; n = s; s = s-&gt;next; delete n; ++i; &#125; cout &lt;&lt; "本次游戏中贪吃蛇长度为" &lt;&lt; i &lt;&lt; '.';&#125;void SnakeShow(Xsnake* s) &#123; if (SnakeColour == 1)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 12); else if (SnakeColour == 2)SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 9); while (s) &#123; Pos(s-&gt;x, s-&gt;y);cout &lt;&lt; "■"; s = s-&gt;next; &#125; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), 15);&#125;void SnakeKey(unsigned&amp; d) &#123; if (GetAsyncKeyState(VK_UP) &amp;&amp; d != 2) d = 8; else if (GetAsyncKeyState(VK_DOWN) &amp;&amp; d != 8) d = 2; else if (GetAsyncKeyState(VK_LEFT) &amp;&amp; d != 6) d = 4; else if (GetAsyncKeyState(VK_RIGHT) &amp;&amp; d != 4) d = 6; else if (GetAsyncKeyState(VK_SPACE)) &#123; Pos(14, 35);cout &lt;&lt; "暂 停"; do &#123; Sleep(200); &#125; while (!GetAsyncKeyState(VK_SPACE)); Pos(14, 35);cout &lt;&lt; " "; SnakeShow(head); FoodShow(Food); &#125; else if (GetAsyncKeyState(VK_ESCAPE)) d = 0; else if (GetAsyncKeyState(0x52)) Xinterface(), FoodShow(Food);&#125;//-----------------------int main()&#123; system("mode con cols=120 lines=30"); system("cls"); Pos(0, 0); Xstart(); Xgame(); Xend(); return 0;&#125;//----------------------- 截图： img img img]]></content>
      <tags>
        <tag>造轮子</tag>
        <tag>贪吃蛇</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 3-4UVa455 3-5UVa227 3-6UVa232]]></title>
    <url>%2Fposts%2F24341.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO 题目：算法竞赛入门经典 3-4/UVa455：Periodic Strings 代码： 12345678910111213141516171819202122//UVa455#include&lt;iostream&gt;int main()&#123; char str[82]; int num; std::cin &gt;&gt; num; while (num--) &#123; std::cin&gt;&gt;str; char *ps = str; while (*++ps != '\0') &#123; while (*ps != *str &amp;&amp; *ps != '\0') ++ps; if (*ps == '\0') break;//循环长度即本身 char *begin = str, *end = ps; while (*++begin == *++end); if (*end == '\0'&amp;&amp;!((begin - str) % (ps - str))) break;//&amp;&amp;的后面的部分为了排除形如abcabcab的情况 &#125; std::cout &lt;&lt; ps - str &lt;&lt; '\n'; if (num) std::cout &lt;&lt; '\n'; &#125; return 0;&#125; 分析：首先找到与输入的字符串的第一个字符相等的字符，然后判断是否循环，不是循环则继续找下一个与的哥字符相等的字符，直到读入'\0'，则循环即本身 而判断从第一个字符到此字符的前一个字符是否构成循环的办法是，此字符与首字符对应的下一个、下两个字符进行比较，直到遇到'\0'，则说明有可能是相等的 如 abcdabcdabcdabcdabcdabcd ​ ↑向右一个个比较 找到可能的循环点 ​ ↓向右一个个比较 ​ abcdabcdabcdabcdabcdabcd 但此比较会漏掉如abcabcabcabcabcab的情况，最后一个ab导致整个字符串无循环，用!((begin - str) % (ps - str))来检查是不是循环了整数倍 题目：算法竞赛入门经典 3-5/UVa227：Puzzle 代码：（已更新为accept版本） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//UVa227#include&lt;iostream&gt;using namespace std;int main()&#123; //freopen("test.in", "r", stdin); //freopen("out.txt", "w", stdout); char puzzle[5][6]; int x, y, num = 0; char step; while (cin.getline(puzzle[0], 6) &amp;&amp; puzzle[0][0] != 'Z') &#123; if (num) cout &lt;&lt; '\n'; bool flag = 0;//操作失败 for (int i = 1;i &lt; 5;++i) cin.getline(puzzle[i], 6); for (x = 0;x &lt; 5;++x) &#123;//找出空格位置 for (y = 0;y &lt; 5;++y) if (puzzle[x][y] == ' ') break; if (y != 5) break; &#125; while ((cin &gt;&gt; step) &amp;&amp; step != '0') &#123; int cx = x, cy = y;//计算对应字母的坐标 switch (step) &#123; case 'A':cx -= 1;break; case 'B':cx += 1;break; case 'L':cy -= 1;break; case 'R':cy += 1; &#125; if (cx &gt;= 0 &amp;&amp; cx &lt;= 4 &amp;&amp; cy &gt;= 0 &amp;&amp; cy &lt;= 4) &#123;//替换字母和空格 puzzle[x][y] = puzzle[cx][cy]; puzzle[x = cx][y = cy] = ' ';//同时x、y变化为新的地址 &#125; else &#123;//操作失败的情况 while ((cin &gt;&gt; step) &amp;&amp; step != '0');//吸收非法步骤后面的所有步骤 flag = 1; break; &#125; &#125; cout &lt;&lt; "Puzzle #" &lt;&lt; ++num &lt;&lt; ":\n"; if (flag) cout &lt;&lt; "This puzzle has no final configuration.\n"; else &#123; for (int i = 0;i &lt; 5;++i) &#123; cout &lt;&lt; puzzle[i][0]; for (int j = 1;j &lt; 5;++j) cout &lt;&lt; ' ' &lt;&lt; puzzle[i][j]; cout &lt;&lt; '\n'; &#125; &#125; cin.getline(puzzle[0], 3);//吸收'\n' &#125; return 0;&#125; 抱怨：查了N次没找到错误是什么，看了网上和同学许多人的代码，思路都差不多，自己做了N组数据来检测我的答案都正确，而且貌似不是输出格式的原因。拿到了一份别人已经通过了的代码，输出重定向到文件，比较我的输出和他的输出，甚至做了个程序来比较两个输出文件内容是不是一样，但就是一样。那么应该是特殊数据导致失败，然而是在想不出有什么特殊数据会让它错误的。。。大神求告知。 （更新：找同学给我看了一下，他也基本没改什么，但又上传了一遍，莫名其妙过了。。。虽然不知道之前哪里不对，但是上面的代码也更新为通过了的版本了） 他似乎就仅仅是把本来的 1234567switch (step) &#123; case 'A':cx -= 1;break; case 'B':cx += 1;break; case 'L':cy -= 1;break; case 'R':cy += 1;break; default:cerr&lt;&lt;"Error:1\n";exit(0); &#125; 改成了现在的代码。好像就改了这个（之前由于没有通过，我也自己改了一小些的，改的都是些貌似无关紧要的东西，所以至今不知道是什么原因导致了之前的WA。。。。不爽） 分析：注意个吸收cin后末尾的''就行。还有吸收错误步骤后的所有步骤。本来很简单的题目，第一天莫名死活wrong answer不过，第二天莫名其妙又过了。。 题目：算法竞赛入门经典 3-6/UVa232：Crossword Answers 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344//UVa232#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; char puzzle[10][10]; int num = 0; int px, py;//puzzle的长宽高 while ((cin &gt;&gt; px) &amp;&amp; px != 0) &#123; if (num) cout &lt;&lt; '\n'; cin &gt;&gt; py; for (int i = 0;i &lt; px;++i) for (int j = 0;j &lt; py;++j) cin &gt;&gt; puzzle[i][j]; cout &lt;&lt; "puzzle #" &lt;&lt; ++num &lt;&lt; ":\nAcross"; int number = 0; for (int i = 0;i &lt; px;++i) for (int j = 0;j &lt; py;++j) if (puzzle[i][j] != '*' &amp;&amp; (i == 0 || j == 0 || puzzle[i - 1][j] == '*' || puzzle[i][j - 1] == '*')) &#123;//找出起始格 ++number; if (j == 0 || puzzle[i][j - 1] == '*') &#123;//输出 int jj = j; cout &lt;&lt; '\n' &lt;&lt; setw(3) &lt;&lt; number &lt;&lt; '.' &lt;&lt; puzzle[i][jj++]; while (jj &lt; py&amp;&amp;puzzle[i][jj] != '*') cout &lt;&lt; puzzle[i][jj++]; &#125; &#125; number = 0; cout &lt;&lt; "\nDown"; //down与找across的步骤类似,由于分开输出，就分开循环,总感觉效率上、代码重复率上欠妥 for (int i = 0;i &lt; px;++i) for (int j = 0;j &lt; py;++j) if (puzzle[i][j] != '*' &amp;&amp; (i == 0 || j == 0 || puzzle[i - 1][j] == '*' || puzzle[i][j - 1] == '*')) &#123; ++number; if (i == 0 || puzzle[i - 1][j] == '*') &#123; int ii = i; cout &lt;&lt; '\n' &lt;&lt; setw(3) &lt;&lt; number &lt;&lt; '.' &lt;&lt; puzzle[ii++][j]; while (ii &lt; px&amp;&amp;puzzle[ii][j] != '*') cout &lt;&lt; puzzle[ii++][j]; &#125; &#125; cout &lt;&lt; '\n'; &#125; return 0;&#125; 分析：如中间注释所示，感觉我这样分开来算横里竖里的结果有点麻烦了，代码也重复性大。 但是由于它要求Across与Down分开输入，所以就这样了。本来我还想①把across直接输出，down的先存到字符串里去，最后一口气输出来，还想着或者②定义一个[10][10]的int数组，第一遍across循环时找出所有eligible，第二遍输出down就快了。 现在想想还是①比较快，但是当时比较懒，没有改。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法竞赛入门经典 3-1UVa1585 3-2UVa1586 3-3UVa1225]]></title>
    <url>%2Fposts%2F45638.html</url>
    <content type="text"><![CDATA[书上具体所有题目：http://pan.baidu.com/s/1hssH0KO（我也是在网上找到的pdf，但不记得是从哪里搜刮到的了，就重新上传了一遍） PS：第一次写博客分享我的代码，不知道我对csdn的使用姿势对不对。想不出来要说些什么哈o(▽)o，那就直接开工，先写一篇试试。 题目：算法竞赛入门经典 3-1/UVa1585：Score 代码： 1234567891011121314151617#include&lt;iostream&gt;#define MAX 83int main()&#123; int num; std::cin &gt;&gt; num; while (num--) &#123; char str[MAX], *ch = str; int score = 0, sum = 0; std::cin &gt;&gt; str; while (*ch != '\0') sum += (*(ch++) == 'X' ? score = 0 : ++score); std::cout &lt;&lt; sum &lt;&lt; '\n'; &#125; return 0;&#125; 分析：MAX定为83而不是题目限制的80是为了传说中的鲁棒性，其他好像没什么好说的。。。下一题。。 题目：算法竞赛入门经典 3-2/UVa1586：Molar Mass 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;iostream&gt;#include&lt;iomanip&gt;inline float f(char c)//得到分子量&#123; switch (c) &#123; case 'C':return 12.01; case 'H':return 1.008; case 'O':return 16.00; case 'N':return 14.01; default:std::cerr &lt;&lt; "error!\n"; &#125; std::cout &lt;&lt; '\'' &lt;&lt; c &lt;&lt; '\''; exit(0);&#125;inline bool g(char c)//判断char的内容是不是数字&#123; if (c &gt;= '0'&amp;&amp;c &lt;= '9') return 1;return 0;&#125;int main()&#123; int num;//判断输入个数 std::cin &gt;&gt; num; std::cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(3); while (num--) &#123; float sum = 0; char str[83], *ch = str; std::cin&gt;&gt;str; while (*ch != '\0') &#123;//此情况下不是'\0'就是字母 int n = 0; char c = *ch; while (g(*++ch))//是数字 n = n * 10 + *ch - '0'; if (!n) n = 1; sum += f(c)*n;//若不是字母则报错结束程序 &#125; std::cout &lt;&lt; sum &lt;&lt; '\n'; &#125; return 0;&#125; 分析：这次写了注释，好像也没什么好说的了。。不过对于inline，我知道编译器如果觉得这个函数不够小巧，会忽略inline，但我一直不知道要多小才能编译器不忽略inline。然后因为程序比较小，所以没有给两个函数取名字，直接叫f和g。 题目：算法竞赛入门经典 3-3/UVa1225：Digit Counting 代码： 123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;cmath&gt;int main()&#123; int num; std::cin &gt;&gt; num; while (num--) &#123; int n, n2,d=1, times[10] = &#123; 0 &#125;;//n:输入的数字,n2:备份n,times:保存各数字出现的次数 do std::cin &gt;&gt; n;while (n &gt;= 10000); n2 = n; while (n2 /= 10) ++d;//d为位数 n2 = n; int t = 1, sum = 0;//t不断乘以10,sum代表所有数字一样多的部分 while (d--) &#123;//f代表某一位 int f = n2 % 10; n2 /= 10; sum += n2*t; times[0] += (n2 - 1)*t;//0太奇葩，总比别人少一个，单独算 for (int i = 0;i &lt; f;++i) times[i] += t; times[f] += 1 + n%t;//当前位最大数字分开算 t *= 10; &#125; std::cout &lt;&lt; times[0]; for (int i = 1;i &lt; 10;++i) std::cout &lt;&lt; ' ' &lt;&lt; (times[i] += sum); std::cout &lt;&lt; '\n'; &#125; return 0;&#125; 分析：这题我看过网上其他人的做法，他们竟然真的把这个长长的数字串写进了字符数组，然后再遍历数组数一遍。总感觉这字符数组长度得爆炸而且慢。 这题的规律是：（划横线的是具体的那个数字）（以123为例） 第一列也就是121的那列，代表（除了零）所有数共有的部分（就比如123的前100中每个数字出现的一样多），在代码里用sum表示，比如对于十位上的每个数字，都出现了123/(10^2)10次 第二列 也就是XXX各+1那列，代表特殊的那几个地方，就比如十位上数字是2，那么那超过100的23（准确说是20，个位上3不算在里面的原因在最后一列）就在此计算，但此计算不包括2 而最后一列又是最特殊的，比如十位上的2的与别人不同的地方在此计算，十位2开头的数120、121、122、123，十位上的2出现（123%10+1）=4次 零我是分开单独算的，因为它比较奇葩，就比如1、2、3而不是01、02、03，十位上的0是不写的，其实规律一样的。 嗯、工科男表达能力太差了。。感觉我越说越复杂。。。果然多写写博客练练表达是有好处的。 这次就上传这几题，看题目难度和代码长度来判断每次上传多少题目。]]></content>
      <categories>
        <category>算法竞赛</category>
        <category>算法竞赛入门经典 (第2版)</category>
      </categories>
      <tags>
        <tag>UVa</tag>
        <tag>算法竞赛入门经典</tag>
      </tags>
  </entry>
</search>
